
message Queue.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002ef2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  00002ef2  00002f86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ba  0080007c  0080007c  00002fa2  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00002fa4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  000036f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  000037e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003b1b  00000000  00000000  00003980  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000df1  00000000  00000000  0000749b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001648  00000000  00000000  0000828c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000cb8  00000000  00000000  000098d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001654  00000000  00000000  0000a58c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000455f  00000000  00000000  0000bbe0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  0001013f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 49 09 	jmp	0x1292	; 0x1292 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ef       	ldi	r30, 0xF2	; 242
      68:	fe e2       	ldi	r31, 0x2E	; 46
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 33       	cpi	r26, 0x36	; 54
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a5 07 	call	0xf4a	; 0xf4a <main>
      8a:	0c 94 77 17 	jmp	0x2eee	; 0x2eee <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_vsetPINDir>:

#include <avr/io.h>
#include "std_macros.h"
void DIO_vsetPINDir(unsigned char portname,unsigned char pinnumber,unsigned char direction)
{
	switch(portname)
      92:	82 34       	cpi	r24, 0x42	; 66
      94:	51 f1       	breq	.+84     	; 0xea <DIO_vsetPINDir+0x58>
      96:	83 34       	cpi	r24, 0x43	; 67
      98:	20 f4       	brcc	.+8      	; 0xa2 <DIO_vsetPINDir+0x10>
      9a:	81 34       	cpi	r24, 0x41	; 65
      9c:	09 f0       	breq	.+2      	; 0xa0 <DIO_vsetPINDir+0xe>
      9e:	7b c0       	rjmp	.+246    	; 0x196 <DIO_vsetPINDir+0x104>
      a0:	07 c0       	rjmp	.+14     	; 0xb0 <DIO_vsetPINDir+0x1e>
      a2:	83 34       	cpi	r24, 0x43	; 67
      a4:	09 f4       	brne	.+2      	; 0xa8 <DIO_vsetPINDir+0x16>
      a6:	3e c0       	rjmp	.+124    	; 0x124 <DIO_vsetPINDir+0x92>
      a8:	84 34       	cpi	r24, 0x44	; 68
      aa:	09 f0       	breq	.+2      	; 0xae <DIO_vsetPINDir+0x1c>
      ac:	74 c0       	rjmp	.+232    	; 0x196 <DIO_vsetPINDir+0x104>
      ae:	57 c0       	rjmp	.+174    	; 0x15e <DIO_vsetPINDir+0xcc>
	{
		
		
		case 'A':
		if(direction==1)
      b0:	41 30       	cpi	r20, 0x01	; 1
      b2:	69 f4       	brne	.+26     	; 0xce <DIO_vsetPINDir+0x3c>
		{
			SET_BIT(DDRA,pinnumber);//Set the direction of the given pin in port A as output
      b4:	2a b3       	in	r18, 0x1a	; 26
      b6:	81 e0       	ldi	r24, 0x01	; 1
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	ac 01       	movw	r20, r24
      bc:	02 c0       	rjmp	.+4      	; 0xc2 <DIO_vsetPINDir+0x30>
      be:	44 0f       	add	r20, r20
      c0:	55 1f       	adc	r21, r21
      c2:	6a 95       	dec	r22
      c4:	e2 f7       	brpl	.-8      	; 0xbe <DIO_vsetPINDir+0x2c>
      c6:	ba 01       	movw	r22, r20
      c8:	62 2b       	or	r22, r18
      ca:	6a bb       	out	0x1a, r22	; 26
      cc:	08 95       	ret
		}
		else
		{
			CLR_BIT(DDRA,pinnumber);//Set the direction of the given pin in port A as input
      ce:	2a b3       	in	r18, 0x1a	; 26
      d0:	81 e0       	ldi	r24, 0x01	; 1
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	ac 01       	movw	r20, r24
      d6:	02 c0       	rjmp	.+4      	; 0xdc <DIO_vsetPINDir+0x4a>
      d8:	44 0f       	add	r20, r20
      da:	55 1f       	adc	r21, r21
      dc:	6a 95       	dec	r22
      de:	e2 f7       	brpl	.-8      	; 0xd8 <DIO_vsetPINDir+0x46>
      e0:	ba 01       	movw	r22, r20
      e2:	60 95       	com	r22
      e4:	62 23       	and	r22, r18
      e6:	6a bb       	out	0x1a, r22	; 26
      e8:	08 95       	ret
		}
		break;
		case 'B':
		if(direction==1)
      ea:	41 30       	cpi	r20, 0x01	; 1
      ec:	69 f4       	brne	.+26     	; 0x108 <DIO_vsetPINDir+0x76>
		{
			SET_BIT(DDRB,pinnumber);//Set the direction of the given pin in port B as output
      ee:	27 b3       	in	r18, 0x17	; 23
      f0:	81 e0       	ldi	r24, 0x01	; 1
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	ac 01       	movw	r20, r24
      f6:	02 c0       	rjmp	.+4      	; 0xfc <DIO_vsetPINDir+0x6a>
      f8:	44 0f       	add	r20, r20
      fa:	55 1f       	adc	r21, r21
      fc:	6a 95       	dec	r22
      fe:	e2 f7       	brpl	.-8      	; 0xf8 <DIO_vsetPINDir+0x66>
     100:	ba 01       	movw	r22, r20
     102:	62 2b       	or	r22, r18
     104:	67 bb       	out	0x17, r22	; 23
     106:	08 95       	ret
		}
		else
		{
			CLR_BIT(DDRB,pinnumber);//Set the direction of the given pin in port B as input
     108:	27 b3       	in	r18, 0x17	; 23
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	90 e0       	ldi	r25, 0x00	; 0
     10e:	ac 01       	movw	r20, r24
     110:	02 c0       	rjmp	.+4      	; 0x116 <DIO_vsetPINDir+0x84>
     112:	44 0f       	add	r20, r20
     114:	55 1f       	adc	r21, r21
     116:	6a 95       	dec	r22
     118:	e2 f7       	brpl	.-8      	; 0x112 <DIO_vsetPINDir+0x80>
     11a:	ba 01       	movw	r22, r20
     11c:	60 95       	com	r22
     11e:	62 23       	and	r22, r18
     120:	67 bb       	out	0x17, r22	; 23
     122:	08 95       	ret
		}
		break;
		case 'C':
		if(direction==1)
     124:	41 30       	cpi	r20, 0x01	; 1
     126:	69 f4       	brne	.+26     	; 0x142 <DIO_vsetPINDir+0xb0>
		{
			SET_BIT(DDRC,pinnumber);//Set the direction of the given pin in port C as output
     128:	24 b3       	in	r18, 0x14	; 20
     12a:	81 e0       	ldi	r24, 0x01	; 1
     12c:	90 e0       	ldi	r25, 0x00	; 0
     12e:	ac 01       	movw	r20, r24
     130:	02 c0       	rjmp	.+4      	; 0x136 <DIO_vsetPINDir+0xa4>
     132:	44 0f       	add	r20, r20
     134:	55 1f       	adc	r21, r21
     136:	6a 95       	dec	r22
     138:	e2 f7       	brpl	.-8      	; 0x132 <DIO_vsetPINDir+0xa0>
     13a:	ba 01       	movw	r22, r20
     13c:	62 2b       	or	r22, r18
     13e:	64 bb       	out	0x14, r22	; 20
     140:	08 95       	ret
		}
		else
		{
			CLR_BIT(DDRC,pinnumber);//Set the direction of the given pin in port C as input
     142:	24 b3       	in	r18, 0x14	; 20
     144:	81 e0       	ldi	r24, 0x01	; 1
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	ac 01       	movw	r20, r24
     14a:	02 c0       	rjmp	.+4      	; 0x150 <DIO_vsetPINDir+0xbe>
     14c:	44 0f       	add	r20, r20
     14e:	55 1f       	adc	r21, r21
     150:	6a 95       	dec	r22
     152:	e2 f7       	brpl	.-8      	; 0x14c <DIO_vsetPINDir+0xba>
     154:	ba 01       	movw	r22, r20
     156:	60 95       	com	r22
     158:	62 23       	and	r22, r18
     15a:	64 bb       	out	0x14, r22	; 20
     15c:	08 95       	ret
		}
		break;
		case 'D':
		if(direction==1)
     15e:	41 30       	cpi	r20, 0x01	; 1
     160:	69 f4       	brne	.+26     	; 0x17c <DIO_vsetPINDir+0xea>
		{
			SET_BIT(DDRD,pinnumber);//Set the direction of the given pin in port D as output
     162:	21 b3       	in	r18, 0x11	; 17
     164:	81 e0       	ldi	r24, 0x01	; 1
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	ac 01       	movw	r20, r24
     16a:	02 c0       	rjmp	.+4      	; 0x170 <DIO_vsetPINDir+0xde>
     16c:	44 0f       	add	r20, r20
     16e:	55 1f       	adc	r21, r21
     170:	6a 95       	dec	r22
     172:	e2 f7       	brpl	.-8      	; 0x16c <DIO_vsetPINDir+0xda>
     174:	ba 01       	movw	r22, r20
     176:	62 2b       	or	r22, r18
     178:	61 bb       	out	0x11, r22	; 17
     17a:	08 95       	ret
		}
		else
		{
			CLR_BIT(DDRD,pinnumber);//Set the direction of the given pin in port D as input
     17c:	21 b3       	in	r18, 0x11	; 17
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	ac 01       	movw	r20, r24
     184:	02 c0       	rjmp	.+4      	; 0x18a <DIO_vsetPINDir+0xf8>
     186:	44 0f       	add	r20, r20
     188:	55 1f       	adc	r21, r21
     18a:	6a 95       	dec	r22
     18c:	e2 f7       	brpl	.-8      	; 0x186 <DIO_vsetPINDir+0xf4>
     18e:	ba 01       	movw	r22, r20
     190:	60 95       	com	r22
     192:	62 23       	and	r22, r18
     194:	61 bb       	out	0x11, r22	; 17
     196:	08 95       	ret

00000198 <DIO_write>:
}


void DIO_write(unsigned char portname,unsigned char pinnumber,unsigned char outputvalue)
{
	switch(portname)
     198:	82 34       	cpi	r24, 0x42	; 66
     19a:	51 f1       	breq	.+84     	; 0x1f0 <DIO_write+0x58>
     19c:	83 34       	cpi	r24, 0x43	; 67
     19e:	20 f4       	brcc	.+8      	; 0x1a8 <DIO_write+0x10>
     1a0:	81 34       	cpi	r24, 0x41	; 65
     1a2:	09 f0       	breq	.+2      	; 0x1a6 <DIO_write+0xe>
     1a4:	7b c0       	rjmp	.+246    	; 0x29c <DIO_write+0x104>
     1a6:	07 c0       	rjmp	.+14     	; 0x1b6 <DIO_write+0x1e>
     1a8:	83 34       	cpi	r24, 0x43	; 67
     1aa:	09 f4       	brne	.+2      	; 0x1ae <DIO_write+0x16>
     1ac:	3e c0       	rjmp	.+124    	; 0x22a <DIO_write+0x92>
     1ae:	84 34       	cpi	r24, 0x44	; 68
     1b0:	09 f0       	breq	.+2      	; 0x1b4 <DIO_write+0x1c>
     1b2:	74 c0       	rjmp	.+232    	; 0x29c <DIO_write+0x104>
     1b4:	57 c0       	rjmp	.+174    	; 0x264 <DIO_write+0xcc>
	{
		case 'A' :
		
		if(outputvalue==1)
     1b6:	41 30       	cpi	r20, 0x01	; 1
     1b8:	69 f4       	brne	.+26     	; 0x1d4 <DIO_write+0x3c>
		{
			SET_BIT(PORTA,pinnumber);//Set the value of the given pin in port A as High
     1ba:	2b b3       	in	r18, 0x1b	; 27
     1bc:	81 e0       	ldi	r24, 0x01	; 1
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	ac 01       	movw	r20, r24
     1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <DIO_write+0x30>
     1c4:	44 0f       	add	r20, r20
     1c6:	55 1f       	adc	r21, r21
     1c8:	6a 95       	dec	r22
     1ca:	e2 f7       	brpl	.-8      	; 0x1c4 <DIO_write+0x2c>
     1cc:	ba 01       	movw	r22, r20
     1ce:	62 2b       	or	r22, r18
     1d0:	6b bb       	out	0x1b, r22	; 27
     1d2:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTA,pinnumber);//Set the value of the given pin in port A as Low
     1d4:	2b b3       	in	r18, 0x1b	; 27
     1d6:	81 e0       	ldi	r24, 0x01	; 1
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	ac 01       	movw	r20, r24
     1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <DIO_write+0x4a>
     1de:	44 0f       	add	r20, r20
     1e0:	55 1f       	adc	r21, r21
     1e2:	6a 95       	dec	r22
     1e4:	e2 f7       	brpl	.-8      	; 0x1de <DIO_write+0x46>
     1e6:	ba 01       	movw	r22, r20
     1e8:	60 95       	com	r22
     1ea:	62 23       	and	r22, r18
     1ec:	6b bb       	out	0x1b, r22	; 27
     1ee:	08 95       	ret
		}
		break ;
		case 'B':
		
		if(outputvalue==1)
     1f0:	41 30       	cpi	r20, 0x01	; 1
     1f2:	69 f4       	brne	.+26     	; 0x20e <DIO_write+0x76>
		{
			SET_BIT(PORTB,pinnumber);//Set the value of the given pin in port B as High
     1f4:	28 b3       	in	r18, 0x18	; 24
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	ac 01       	movw	r20, r24
     1fc:	02 c0       	rjmp	.+4      	; 0x202 <DIO_write+0x6a>
     1fe:	44 0f       	add	r20, r20
     200:	55 1f       	adc	r21, r21
     202:	6a 95       	dec	r22
     204:	e2 f7       	brpl	.-8      	; 0x1fe <DIO_write+0x66>
     206:	ba 01       	movw	r22, r20
     208:	62 2b       	or	r22, r18
     20a:	68 bb       	out	0x18, r22	; 24
     20c:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTB,pinnumber);//Set the value of the given pin in port B as Low
     20e:	28 b3       	in	r18, 0x18	; 24
     210:	81 e0       	ldi	r24, 0x01	; 1
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	ac 01       	movw	r20, r24
     216:	02 c0       	rjmp	.+4      	; 0x21c <DIO_write+0x84>
     218:	44 0f       	add	r20, r20
     21a:	55 1f       	adc	r21, r21
     21c:	6a 95       	dec	r22
     21e:	e2 f7       	brpl	.-8      	; 0x218 <DIO_write+0x80>
     220:	ba 01       	movw	r22, r20
     222:	60 95       	com	r22
     224:	62 23       	and	r22, r18
     226:	68 bb       	out	0x18, r22	; 24
     228:	08 95       	ret
		}
		break ;
		case 'C' :
		
		if(outputvalue==1)
     22a:	41 30       	cpi	r20, 0x01	; 1
     22c:	69 f4       	brne	.+26     	; 0x248 <DIO_write+0xb0>
		{
			SET_BIT(PORTC,pinnumber);//Set the value of the given pin in port C as High
     22e:	25 b3       	in	r18, 0x15	; 21
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	ac 01       	movw	r20, r24
     236:	02 c0       	rjmp	.+4      	; 0x23c <DIO_write+0xa4>
     238:	44 0f       	add	r20, r20
     23a:	55 1f       	adc	r21, r21
     23c:	6a 95       	dec	r22
     23e:	e2 f7       	brpl	.-8      	; 0x238 <DIO_write+0xa0>
     240:	ba 01       	movw	r22, r20
     242:	62 2b       	or	r22, r18
     244:	65 bb       	out	0x15, r22	; 21
     246:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTC,pinnumber);//Set the value of the given pin in port C as Low
     248:	25 b3       	in	r18, 0x15	; 21
     24a:	81 e0       	ldi	r24, 0x01	; 1
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	ac 01       	movw	r20, r24
     250:	02 c0       	rjmp	.+4      	; 0x256 <DIO_write+0xbe>
     252:	44 0f       	add	r20, r20
     254:	55 1f       	adc	r21, r21
     256:	6a 95       	dec	r22
     258:	e2 f7       	brpl	.-8      	; 0x252 <DIO_write+0xba>
     25a:	ba 01       	movw	r22, r20
     25c:	60 95       	com	r22
     25e:	62 23       	and	r22, r18
     260:	65 bb       	out	0x15, r22	; 21
     262:	08 95       	ret
		}
		break ;
		case 'D':
		
		if(outputvalue==1)
     264:	41 30       	cpi	r20, 0x01	; 1
     266:	69 f4       	brne	.+26     	; 0x282 <DIO_write+0xea>
		{
			SET_BIT(PORTD,pinnumber);//Set the value of the given pin in port D as High
     268:	22 b3       	in	r18, 0x12	; 18
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	ac 01       	movw	r20, r24
     270:	02 c0       	rjmp	.+4      	; 0x276 <DIO_write+0xde>
     272:	44 0f       	add	r20, r20
     274:	55 1f       	adc	r21, r21
     276:	6a 95       	dec	r22
     278:	e2 f7       	brpl	.-8      	; 0x272 <DIO_write+0xda>
     27a:	ba 01       	movw	r22, r20
     27c:	62 2b       	or	r22, r18
     27e:	62 bb       	out	0x12, r22	; 18
     280:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTD,pinnumber);//Set the value of the given pin in port D as Low
     282:	22 b3       	in	r18, 0x12	; 18
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	ac 01       	movw	r20, r24
     28a:	02 c0       	rjmp	.+4      	; 0x290 <DIO_write+0xf8>
     28c:	44 0f       	add	r20, r20
     28e:	55 1f       	adc	r21, r21
     290:	6a 95       	dec	r22
     292:	e2 f7       	brpl	.-8      	; 0x28c <DIO_write+0xf4>
     294:	ba 01       	movw	r22, r20
     296:	60 95       	com	r22
     298:	62 23       	and	r22, r18
     29a:	62 bb       	out	0x12, r22	; 18
     29c:	08 95       	ret

0000029e <DIO_u8read>:


unsigned char DIO_u8read(unsigned char portname,unsigned char pinnumber)
{
	unsigned char return_value=0;
	switch(portname)
     29e:	82 34       	cpi	r24, 0x42	; 66
     2a0:	f1 f0       	breq	.+60     	; 0x2de <DIO_u8read+0x40>
     2a2:	83 34       	cpi	r24, 0x43	; 67
     2a4:	20 f4       	brcc	.+8      	; 0x2ae <DIO_u8read+0x10>
     2a6:	81 34       	cpi	r24, 0x41	; 65
     2a8:	09 f0       	breq	.+2      	; 0x2ac <DIO_u8read+0xe>
     2aa:	4f c0       	rjmp	.+158    	; 0x34a <DIO_u8read+0xac>
     2ac:	06 c0       	rjmp	.+12     	; 0x2ba <DIO_u8read+0x1c>
     2ae:	83 34       	cpi	r24, 0x43	; 67
     2b0:	41 f1       	breq	.+80     	; 0x302 <DIO_u8read+0x64>
     2b2:	84 34       	cpi	r24, 0x44	; 68
     2b4:	09 f0       	breq	.+2      	; 0x2b8 <DIO_u8read+0x1a>
     2b6:	49 c0       	rjmp	.+146    	; 0x34a <DIO_u8read+0xac>
     2b8:	36 c0       	rjmp	.+108    	; 0x326 <DIO_u8read+0x88>
	{
		case 'A' :
		return_value=READ_BIT(PINA,pinnumber);//Read the value from the given pin in port A
     2ba:	29 b3       	in	r18, 0x19	; 25
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	06 2e       	mov	r0, r22
     2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_u8read+0x2a>
     2c4:	88 0f       	add	r24, r24
     2c6:	99 1f       	adc	r25, r25
     2c8:	0a 94       	dec	r0
     2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_u8read+0x26>
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	82 23       	and	r24, r18
     2d0:	93 23       	and	r25, r19
     2d2:	02 c0       	rjmp	.+4      	; 0x2d8 <DIO_u8read+0x3a>
     2d4:	95 95       	asr	r25
     2d6:	87 95       	ror	r24
     2d8:	6a 95       	dec	r22
     2da:	e2 f7       	brpl	.-8      	; 0x2d4 <DIO_u8read+0x36>
		break;
     2dc:	08 95       	ret
		
		case 'B' :
		return_value=READ_BIT(PINB,pinnumber);//Read the value from the given pin in port B
     2de:	26 b3       	in	r18, 0x16	; 22
     2e0:	81 e0       	ldi	r24, 0x01	; 1
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	06 2e       	mov	r0, r22
     2e6:	02 c0       	rjmp	.+4      	; 0x2ec <DIO_u8read+0x4e>
     2e8:	88 0f       	add	r24, r24
     2ea:	99 1f       	adc	r25, r25
     2ec:	0a 94       	dec	r0
     2ee:	e2 f7       	brpl	.-8      	; 0x2e8 <DIO_u8read+0x4a>
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	82 23       	and	r24, r18
     2f4:	93 23       	and	r25, r19
     2f6:	02 c0       	rjmp	.+4      	; 0x2fc <DIO_u8read+0x5e>
     2f8:	95 95       	asr	r25
     2fa:	87 95       	ror	r24
     2fc:	6a 95       	dec	r22
     2fe:	e2 f7       	brpl	.-8      	; 0x2f8 <DIO_u8read+0x5a>
		break;
     300:	08 95       	ret
		
		case 'C' :
		return_value=READ_BIT(PINC,pinnumber);//Read the value from the given pin in port C
     302:	23 b3       	in	r18, 0x13	; 19
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	06 2e       	mov	r0, r22
     30a:	02 c0       	rjmp	.+4      	; 0x310 <DIO_u8read+0x72>
     30c:	88 0f       	add	r24, r24
     30e:	99 1f       	adc	r25, r25
     310:	0a 94       	dec	r0
     312:	e2 f7       	brpl	.-8      	; 0x30c <DIO_u8read+0x6e>
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	82 23       	and	r24, r18
     318:	93 23       	and	r25, r19
     31a:	02 c0       	rjmp	.+4      	; 0x320 <DIO_u8read+0x82>
     31c:	95 95       	asr	r25
     31e:	87 95       	ror	r24
     320:	6a 95       	dec	r22
     322:	e2 f7       	brpl	.-8      	; 0x31c <DIO_u8read+0x7e>
		break;
     324:	08 95       	ret
		
		case 'D' :
		return_value=READ_BIT(PIND,pinnumber);//Read the value from the given pin in port D
     326:	20 b3       	in	r18, 0x10	; 16
     328:	81 e0       	ldi	r24, 0x01	; 1
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	06 2e       	mov	r0, r22
     32e:	02 c0       	rjmp	.+4      	; 0x334 <DIO_u8read+0x96>
     330:	88 0f       	add	r24, r24
     332:	99 1f       	adc	r25, r25
     334:	0a 94       	dec	r0
     336:	e2 f7       	brpl	.-8      	; 0x330 <DIO_u8read+0x92>
     338:	30 e0       	ldi	r19, 0x00	; 0
     33a:	82 23       	and	r24, r18
     33c:	93 23       	and	r25, r19
     33e:	02 c0       	rjmp	.+4      	; 0x344 <DIO_u8read+0xa6>
     340:	95 95       	asr	r25
     342:	87 95       	ror	r24
     344:	6a 95       	dec	r22
     346:	e2 f7       	brpl	.-8      	; 0x340 <DIO_u8read+0xa2>
		break;
     348:	08 95       	ret
}


unsigned char DIO_u8read(unsigned char portname,unsigned char pinnumber)
{
	unsigned char return_value=0;
     34a:	80 e0       	ldi	r24, 0x00	; 0
		break;
		default: 
		break;
	}
	return return_value ;
}
     34c:	08 95       	ret

0000034e <DIO_toggle>:
void DIO_toggle(unsigned char portname,unsigned char pinnumber)
{
	switch(portname)
     34e:	82 34       	cpi	r24, 0x42	; 66
     350:	b9 f0       	breq	.+46     	; 0x380 <DIO_toggle+0x32>
     352:	83 34       	cpi	r24, 0x43	; 67
     354:	18 f4       	brcc	.+6      	; 0x35c <DIO_toggle+0xe>
     356:	81 34       	cpi	r24, 0x41	; 65
     358:	c9 f5       	brne	.+114    	; 0x3cc <DIO_toggle+0x7e>
     35a:	05 c0       	rjmp	.+10     	; 0x366 <DIO_toggle+0x18>
     35c:	83 34       	cpi	r24, 0x43	; 67
     35e:	e9 f0       	breq	.+58     	; 0x39a <DIO_toggle+0x4c>
     360:	84 34       	cpi	r24, 0x44	; 68
     362:	a1 f5       	brne	.+104    	; 0x3cc <DIO_toggle+0x7e>
     364:	27 c0       	rjmp	.+78     	; 0x3b4 <DIO_toggle+0x66>
	{
		case 'A':
		TOG_BIT(PORTA,pinnumber);//Toggle the value of the given pin in port A
     366:	2b b3       	in	r18, 0x1b	; 27
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	ac 01       	movw	r20, r24
     36e:	02 c0       	rjmp	.+4      	; 0x374 <DIO_toggle+0x26>
     370:	44 0f       	add	r20, r20
     372:	55 1f       	adc	r21, r21
     374:	6a 95       	dec	r22
     376:	e2 f7       	brpl	.-8      	; 0x370 <DIO_toggle+0x22>
     378:	ba 01       	movw	r22, r20
     37a:	62 27       	eor	r22, r18
     37c:	6b bb       	out	0x1b, r22	; 27
		break;
     37e:	08 95       	ret
		case 'B':
		TOG_BIT(PORTB,pinnumber);//Toggle the value of the given pin in port B
     380:	28 b3       	in	r18, 0x18	; 24
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	ac 01       	movw	r20, r24
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_toggle+0x40>
     38a:	44 0f       	add	r20, r20
     38c:	55 1f       	adc	r21, r21
     38e:	6a 95       	dec	r22
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_toggle+0x3c>
     392:	ba 01       	movw	r22, r20
     394:	62 27       	eor	r22, r18
     396:	68 bb       	out	0x18, r22	; 24
		break;
     398:	08 95       	ret
		case 'C':
		TOG_BIT(PORTC,pinnumber);//Toggle the value of the given pin in port C
     39a:	25 b3       	in	r18, 0x15	; 21
     39c:	81 e0       	ldi	r24, 0x01	; 1
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	ac 01       	movw	r20, r24
     3a2:	02 c0       	rjmp	.+4      	; 0x3a8 <DIO_toggle+0x5a>
     3a4:	44 0f       	add	r20, r20
     3a6:	55 1f       	adc	r21, r21
     3a8:	6a 95       	dec	r22
     3aa:	e2 f7       	brpl	.-8      	; 0x3a4 <DIO_toggle+0x56>
     3ac:	ba 01       	movw	r22, r20
     3ae:	62 27       	eor	r22, r18
     3b0:	65 bb       	out	0x15, r22	; 21
		break;
     3b2:	08 95       	ret
		case 'D':
		TOG_BIT(PORTD,pinnumber);//Toggle the value of the given pin in port D
     3b4:	22 b3       	in	r18, 0x12	; 18
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	ac 01       	movw	r20, r24
     3bc:	02 c0       	rjmp	.+4      	; 0x3c2 <DIO_toggle+0x74>
     3be:	44 0f       	add	r20, r20
     3c0:	55 1f       	adc	r21, r21
     3c2:	6a 95       	dec	r22
     3c4:	e2 f7       	brpl	.-8      	; 0x3be <DIO_toggle+0x70>
     3c6:	ba 01       	movw	r22, r20
     3c8:	62 27       	eor	r22, r18
     3ca:	62 bb       	out	0x12, r22	; 18
     3cc:	08 95       	ret

000003ce <DIO_set_port_direction>:
		default: break;
	}
}
void DIO_set_port_direction(unsigned char portname,unsigned char direction)
{
	switch(portname)
     3ce:	82 34       	cpi	r24, 0x42	; 66
     3d0:	61 f0       	breq	.+24     	; 0x3ea <DIO_set_port_direction+0x1c>
     3d2:	83 34       	cpi	r24, 0x43	; 67
     3d4:	18 f4       	brcc	.+6      	; 0x3dc <DIO_set_port_direction+0xe>
     3d6:	81 34       	cpi	r24, 0x41	; 65
     3d8:	69 f4       	brne	.+26     	; 0x3f4 <DIO_set_port_direction+0x26>
     3da:	05 c0       	rjmp	.+10     	; 0x3e6 <DIO_set_port_direction+0x18>
     3dc:	83 34       	cpi	r24, 0x43	; 67
     3de:	39 f0       	breq	.+14     	; 0x3ee <DIO_set_port_direction+0x20>
     3e0:	84 34       	cpi	r24, 0x44	; 68
     3e2:	41 f4       	brne	.+16     	; 0x3f4 <DIO_set_port_direction+0x26>
     3e4:	06 c0       	rjmp	.+12     	; 0x3f2 <DIO_set_port_direction+0x24>
	{
		case 'A' :
		DDRA=direction; //set the direction of port A
     3e6:	6a bb       	out	0x1a, r22	; 26
		break ;
     3e8:	08 95       	ret
		case 'B':
		DDRB=direction; //set the direction of port B
     3ea:	67 bb       	out	0x17, r22	; 23
		break ;
     3ec:	08 95       	ret
		case 'C' :
		DDRC=direction; //set the direction of port C
     3ee:	64 bb       	out	0x14, r22	; 20
		break ;
     3f0:	08 95       	ret
		case 'D':
		DDRD=direction; //set the direction of port D
     3f2:	61 bb       	out	0x11, r22	; 17
     3f4:	08 95       	ret

000003f6 <DIO_write_port>:
	}
	
}
void DIO_write_port(unsigned char portname,unsigned char portvalue)
{
	switch(portname)
     3f6:	82 34       	cpi	r24, 0x42	; 66
     3f8:	61 f0       	breq	.+24     	; 0x412 <DIO_write_port+0x1c>
     3fa:	83 34       	cpi	r24, 0x43	; 67
     3fc:	18 f4       	brcc	.+6      	; 0x404 <DIO_write_port+0xe>
     3fe:	81 34       	cpi	r24, 0x41	; 65
     400:	69 f4       	brne	.+26     	; 0x41c <DIO_write_port+0x26>
     402:	05 c0       	rjmp	.+10     	; 0x40e <DIO_write_port+0x18>
     404:	83 34       	cpi	r24, 0x43	; 67
     406:	39 f0       	breq	.+14     	; 0x416 <DIO_write_port+0x20>
     408:	84 34       	cpi	r24, 0x44	; 68
     40a:	41 f4       	brne	.+16     	; 0x41c <DIO_write_port+0x26>
     40c:	06 c0       	rjmp	.+12     	; 0x41a <DIO_write_port+0x24>
	{
		case 'A' :
		PORTA=portvalue; //Write the given value to the port A
     40e:	6b bb       	out	0x1b, r22	; 27
		break ;
     410:	08 95       	ret
		case 'B':
		PORTB=portvalue; //Write the given value to the port B
     412:	68 bb       	out	0x18, r22	; 24
		break ;
     414:	08 95       	ret
		case 'C' :
		PORTC=portvalue; //Write the given value to the port C
     416:	65 bb       	out	0x15, r22	; 21
		break ;
     418:	08 95       	ret
		case 'D':
		PORTD=portvalue; //Write the given value to the port D
     41a:	62 bb       	out	0x12, r22	; 18
     41c:	08 95       	ret

0000041e <DIO_read_port>:
}

unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char return_val=0;
	switch(portname)
     41e:	82 34       	cpi	r24, 0x42	; 66
     420:	61 f0       	breq	.+24     	; 0x43a <DIO_read_port+0x1c>
     422:	83 34       	cpi	r24, 0x43	; 67
     424:	18 f4       	brcc	.+6      	; 0x42c <DIO_read_port+0xe>
     426:	81 34       	cpi	r24, 0x41	; 65
     428:	71 f4       	brne	.+28     	; 0x446 <DIO_read_port+0x28>
     42a:	05 c0       	rjmp	.+10     	; 0x436 <DIO_read_port+0x18>
     42c:	83 34       	cpi	r24, 0x43	; 67
     42e:	39 f0       	breq	.+14     	; 0x43e <DIO_read_port+0x20>
     430:	84 34       	cpi	r24, 0x44	; 68
     432:	49 f4       	brne	.+18     	; 0x446 <DIO_read_port+0x28>
     434:	06 c0       	rjmp	.+12     	; 0x442 <DIO_read_port+0x24>
	{
		case 'A' :
		return_val=PINA; // read the value of port A 
     436:	89 b3       	in	r24, 0x19	; 25
		break ;
     438:	08 95       	ret
		case 'B':
		return_val=PINB; // read the value of port B 
     43a:	86 b3       	in	r24, 0x16	; 22
		break ;
     43c:	08 95       	ret
		case 'C' :
		return_val=PINC; // read the value of port C 
     43e:	83 b3       	in	r24, 0x13	; 19
		break ;
     440:	08 95       	ret
		case 'D':
		return_val=PIND; // read the value of port D 
     442:	80 b3       	in	r24, 0x10	; 16
		break ;
     444:	08 95       	ret
	}
}

unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char return_val=0;
     446:	80 e0       	ldi	r24, 0x00	; 0
		break ;
		default:
		break ;
	}
	return return_val;
}
     448:	08 95       	ret

0000044a <DIO_vconnectpullup>:

void DIO_vconnectpullup(char portname ,char pinnumber, char connect_pullup)
{
	switch(portname)
     44a:	82 34       	cpi	r24, 0x42	; 66
     44c:	51 f1       	breq	.+84     	; 0x4a2 <DIO_vconnectpullup+0x58>
     44e:	83 34       	cpi	r24, 0x43	; 67
     450:	20 f4       	brcc	.+8      	; 0x45a <DIO_vconnectpullup+0x10>
     452:	81 34       	cpi	r24, 0x41	; 65
     454:	09 f0       	breq	.+2      	; 0x458 <DIO_vconnectpullup+0xe>
     456:	7b c0       	rjmp	.+246    	; 0x54e <DIO_vconnectpullup+0x104>
     458:	07 c0       	rjmp	.+14     	; 0x468 <DIO_vconnectpullup+0x1e>
     45a:	83 34       	cpi	r24, 0x43	; 67
     45c:	09 f4       	brne	.+2      	; 0x460 <DIO_vconnectpullup+0x16>
     45e:	3e c0       	rjmp	.+124    	; 0x4dc <DIO_vconnectpullup+0x92>
     460:	84 34       	cpi	r24, 0x44	; 68
     462:	09 f0       	breq	.+2      	; 0x466 <DIO_vconnectpullup+0x1c>
     464:	74 c0       	rjmp	.+232    	; 0x54e <DIO_vconnectpullup+0x104>
     466:	57 c0       	rjmp	.+174    	; 0x516 <DIO_vconnectpullup+0xcc>
	{
		case 'A':
		if(connect_pullup==1)
     468:	41 30       	cpi	r20, 0x01	; 1
     46a:	69 f4       	brne	.+26     	; 0x486 <DIO_vconnectpullup+0x3c>
		{
			SET_BIT(PORTA,pinnumber);
     46c:	2b b3       	in	r18, 0x1b	; 27
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	ac 01       	movw	r20, r24
     474:	02 c0       	rjmp	.+4      	; 0x47a <DIO_vconnectpullup+0x30>
     476:	44 0f       	add	r20, r20
     478:	55 1f       	adc	r21, r21
     47a:	6a 95       	dec	r22
     47c:	e2 f7       	brpl	.-8      	; 0x476 <DIO_vconnectpullup+0x2c>
     47e:	ba 01       	movw	r22, r20
     480:	62 2b       	or	r22, r18
     482:	6b bb       	out	0x1b, r22	; 27
     484:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTA,pinnumber);
     486:	2b b3       	in	r18, 0x1b	; 27
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	ac 01       	movw	r20, r24
     48e:	02 c0       	rjmp	.+4      	; 0x494 <DIO_vconnectpullup+0x4a>
     490:	44 0f       	add	r20, r20
     492:	55 1f       	adc	r21, r21
     494:	6a 95       	dec	r22
     496:	e2 f7       	brpl	.-8      	; 0x490 <DIO_vconnectpullup+0x46>
     498:	ba 01       	movw	r22, r20
     49a:	60 95       	com	r22
     49c:	62 23       	and	r22, r18
     49e:	6b bb       	out	0x1b, r22	; 27
     4a0:	08 95       	ret
		}
		break;
		case 'B':
		if(connect_pullup==1)
     4a2:	41 30       	cpi	r20, 0x01	; 1
     4a4:	69 f4       	brne	.+26     	; 0x4c0 <DIO_vconnectpullup+0x76>
		{
			SET_BIT(PORTB,pinnumber);
     4a6:	28 b3       	in	r18, 0x18	; 24
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	ac 01       	movw	r20, r24
     4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <DIO_vconnectpullup+0x6a>
     4b0:	44 0f       	add	r20, r20
     4b2:	55 1f       	adc	r21, r21
     4b4:	6a 95       	dec	r22
     4b6:	e2 f7       	brpl	.-8      	; 0x4b0 <DIO_vconnectpullup+0x66>
     4b8:	ba 01       	movw	r22, r20
     4ba:	62 2b       	or	r22, r18
     4bc:	68 bb       	out	0x18, r22	; 24
     4be:	08 95       	ret
		}
		else
		{
			CLR_BIT(PORTB,pinnumber);
     4c0:	28 b3       	in	r18, 0x18	; 24
     4c2:	81 e0       	ldi	r24, 0x01	; 1
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	ac 01       	movw	r20, r24
     4c8:	02 c0       	rjmp	.+4      	; 0x4ce <DIO_vconnectpullup+0x84>
     4ca:	44 0f       	add	r20, r20
     4cc:	55 1f       	adc	r21, r21
     4ce:	6a 95       	dec	r22
     4d0:	e2 f7       	brpl	.-8      	; 0x4ca <DIO_vconnectpullup+0x80>
     4d2:	ba 01       	movw	r22, r20
     4d4:	60 95       	com	r22
     4d6:	62 23       	and	r22, r18
     4d8:	68 bb       	out	0x18, r22	; 24
     4da:	08 95       	ret
		}
		break;
		case 'C':
		if(connect_pullup==1)
     4dc:	41 30       	cpi	r20, 0x01	; 1
     4de:	69 f4       	brne	.+26     	; 0x4fa <DIO_vconnectpullup+0xb0>
		{
			SET_BIT(PORTC,pinnumber);
     4e0:	25 b3       	in	r18, 0x15	; 21
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	ac 01       	movw	r20, r24
     4e8:	02 c0       	rjmp	.+4      	; 0x4ee <DIO_vconnectpullup+0xa4>
     4ea:	44 0f       	add	r20, r20
     4ec:	55 1f       	adc	r21, r21
     4ee:	6a 95       	dec	r22
     4f0:	e2 f7       	brpl	.-8      	; 0x4ea <DIO_vconnectpullup+0xa0>
     4f2:	ba 01       	movw	r22, r20
     4f4:	62 2b       	or	r22, r18
     4f6:	65 bb       	out	0x15, r22	; 21
     4f8:	08 95       	ret
			
		}
		else
		{
			CLR_BIT(PORTC,pinnumber);
     4fa:	25 b3       	in	r18, 0x15	; 21
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	ac 01       	movw	r20, r24
     502:	02 c0       	rjmp	.+4      	; 0x508 <DIO_vconnectpullup+0xbe>
     504:	44 0f       	add	r20, r20
     506:	55 1f       	adc	r21, r21
     508:	6a 95       	dec	r22
     50a:	e2 f7       	brpl	.-8      	; 0x504 <DIO_vconnectpullup+0xba>
     50c:	ba 01       	movw	r22, r20
     50e:	60 95       	com	r22
     510:	62 23       	and	r22, r18
     512:	65 bb       	out	0x15, r22	; 21
     514:	08 95       	ret
		}
		break;
		case 'D':
		if(connect_pullup==1)
     516:	41 30       	cpi	r20, 0x01	; 1
     518:	69 f4       	brne	.+26     	; 0x534 <DIO_vconnectpullup+0xea>
		{
			SET_BIT(PORTD,pinnumber);
     51a:	22 b3       	in	r18, 0x12	; 18
     51c:	81 e0       	ldi	r24, 0x01	; 1
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	ac 01       	movw	r20, r24
     522:	02 c0       	rjmp	.+4      	; 0x528 <DIO_vconnectpullup+0xde>
     524:	44 0f       	add	r20, r20
     526:	55 1f       	adc	r21, r21
     528:	6a 95       	dec	r22
     52a:	e2 f7       	brpl	.-8      	; 0x524 <DIO_vconnectpullup+0xda>
     52c:	ba 01       	movw	r22, r20
     52e:	62 2b       	or	r22, r18
     530:	62 bb       	out	0x12, r22	; 18
     532:	08 95       	ret
			
		}
		else
		{
			CLR_BIT(PORTD,pinnumber);
     534:	22 b3       	in	r18, 0x12	; 18
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	ac 01       	movw	r20, r24
     53c:	02 c0       	rjmp	.+4      	; 0x542 <DIO_vconnectpullup+0xf8>
     53e:	44 0f       	add	r20, r20
     540:	55 1f       	adc	r21, r21
     542:	6a 95       	dec	r22
     544:	e2 f7       	brpl	.-8      	; 0x53e <DIO_vconnectpullup+0xf4>
     546:	ba 01       	movw	r22, r20
     548:	60 95       	com	r22
     54a:	62 23       	and	r22, r18
     54c:	62 bb       	out	0x12, r22	; 18
     54e:	08 95       	ret

00000550 <write_low_nibble>:
	}
}

void write_low_nibble(unsigned char portname,unsigned char value)
{
	value&=0x0f;
     550:	6f 70       	andi	r22, 0x0F	; 15
	switch(portname)
     552:	82 34       	cpi	r24, 0x42	; 66
     554:	81 f0       	breq	.+32     	; 0x576 <write_low_nibble+0x26>
     556:	83 34       	cpi	r24, 0x43	; 67
     558:	18 f4       	brcc	.+6      	; 0x560 <write_low_nibble+0x10>
     55a:	81 34       	cpi	r24, 0x41	; 65
     55c:	f1 f4       	brne	.+60     	; 0x59a <write_low_nibble+0x4a>
     55e:	05 c0       	rjmp	.+10     	; 0x56a <write_low_nibble+0x1a>
     560:	83 34       	cpi	r24, 0x43	; 67
     562:	79 f0       	breq	.+30     	; 0x582 <write_low_nibble+0x32>
     564:	84 34       	cpi	r24, 0x44	; 68
     566:	c9 f4       	brne	.+50     	; 0x59a <write_low_nibble+0x4a>
     568:	12 c0       	rjmp	.+36     	; 0x58e <write_low_nibble+0x3e>
	{
		case 'A':
		PORTA&=0xf0;
     56a:	8b b3       	in	r24, 0x1b	; 27
     56c:	80 7f       	andi	r24, 0xF0	; 240
     56e:	8b bb       	out	0x1b, r24	; 27
		PORTA|=value;
     570:	8b b3       	in	r24, 0x1b	; 27
     572:	86 2b       	or	r24, r22
     574:	8b bb       	out	0x1b, r24	; 27
		case 'B':
		PORTB&=0xf0;
     576:	88 b3       	in	r24, 0x18	; 24
     578:	80 7f       	andi	r24, 0xF0	; 240
     57a:	88 bb       	out	0x18, r24	; 24
		PORTB|=value;
     57c:	88 b3       	in	r24, 0x18	; 24
     57e:	86 2b       	or	r24, r22
     580:	88 bb       	out	0x18, r24	; 24
		case 'C':
		PORTC&=0xf0;
     582:	85 b3       	in	r24, 0x15	; 21
     584:	80 7f       	andi	r24, 0xF0	; 240
     586:	85 bb       	out	0x15, r24	; 21
		PORTC|=value;
     588:	85 b3       	in	r24, 0x15	; 21
     58a:	86 2b       	or	r24, r22
     58c:	85 bb       	out	0x15, r24	; 21
		case 'D':
		PORTD&=0xf0;
     58e:	82 b3       	in	r24, 0x12	; 18
     590:	80 7f       	andi	r24, 0xF0	; 240
     592:	82 bb       	out	0x12, r24	; 18
		PORTD|=value;
     594:	82 b3       	in	r24, 0x12	; 18
     596:	68 2b       	or	r22, r24
     598:	62 bb       	out	0x12, r22	; 18
     59a:	08 95       	ret

0000059c <write_high_nibble>:
	}
}

void write_high_nibble(unsigned char portname,unsigned char value)
{
	value<<=4;
     59c:	62 95       	swap	r22
     59e:	60 7f       	andi	r22, 0xF0	; 240
	switch(portname)
     5a0:	82 34       	cpi	r24, 0x42	; 66
     5a2:	81 f0       	breq	.+32     	; 0x5c4 <write_high_nibble+0x28>
     5a4:	83 34       	cpi	r24, 0x43	; 67
     5a6:	18 f4       	brcc	.+6      	; 0x5ae <write_high_nibble+0x12>
     5a8:	81 34       	cpi	r24, 0x41	; 65
     5aa:	f1 f4       	brne	.+60     	; 0x5e8 <write_high_nibble+0x4c>
     5ac:	05 c0       	rjmp	.+10     	; 0x5b8 <write_high_nibble+0x1c>
     5ae:	83 34       	cpi	r24, 0x43	; 67
     5b0:	79 f0       	breq	.+30     	; 0x5d0 <write_high_nibble+0x34>
     5b2:	84 34       	cpi	r24, 0x44	; 68
     5b4:	c9 f4       	brne	.+50     	; 0x5e8 <write_high_nibble+0x4c>
     5b6:	12 c0       	rjmp	.+36     	; 0x5dc <write_high_nibble+0x40>
	{
		case 'A':
		PORTA&=0x0f;
     5b8:	8b b3       	in	r24, 0x1b	; 27
     5ba:	8f 70       	andi	r24, 0x0F	; 15
     5bc:	8b bb       	out	0x1b, r24	; 27
		PORTA|=value;
     5be:	8b b3       	in	r24, 0x1b	; 27
     5c0:	86 2b       	or	r24, r22
     5c2:	8b bb       	out	0x1b, r24	; 27
		case 'B':
		PORTB&=0x0f;
     5c4:	88 b3       	in	r24, 0x18	; 24
     5c6:	8f 70       	andi	r24, 0x0F	; 15
     5c8:	88 bb       	out	0x18, r24	; 24
		PORTB|=value;
     5ca:	88 b3       	in	r24, 0x18	; 24
     5cc:	86 2b       	or	r24, r22
     5ce:	88 bb       	out	0x18, r24	; 24
		case 'C':
		PORTC&=0x0f;
     5d0:	85 b3       	in	r24, 0x15	; 21
     5d2:	8f 70       	andi	r24, 0x0F	; 15
     5d4:	85 bb       	out	0x15, r24	; 21
		PORTC|=value;
     5d6:	85 b3       	in	r24, 0x15	; 21
     5d8:	86 2b       	or	r24, r22
     5da:	85 bb       	out	0x15, r24	; 21
		case 'D':
		PORTD&=0x0f;
     5dc:	82 b3       	in	r24, 0x12	; 18
     5de:	8f 70       	andi	r24, 0x0F	; 15
     5e0:	82 bb       	out	0x12, r24	; 18
		PORTD|=value;
     5e2:	82 b3       	in	r24, 0x12	; 18
     5e4:	68 2b       	or	r22, r24
     5e6:	62 bb       	out	0x12, r22	; 18
     5e8:	08 95       	ret

000005ea <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     5ea:	44 23       	and	r20, r20
     5ec:	41 f4       	brne	.+16     	; 0x5fe <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     5ee:	68 23       	and	r22, r24
     5f0:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	61 15       	cp	r22, r1
     5f6:	71 05       	cpc	r23, r1
     5f8:	51 f4       	brne	.+20     	; 0x60e <prvTestWaitCondition+0x24>
     5fa:	80 e0       	ldi	r24, 0x00	; 0
     5fc:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     5fe:	9b 01       	movw	r18, r22
     600:	28 23       	and	r18, r24
     602:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	62 17       	cp	r22, r18
     608:	73 07       	cpc	r23, r19
     60a:	09 f0       	breq	.+2      	; 0x60e <prvTestWaitCondition+0x24>
     60c:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     60e:	08 95       	ret

00000610 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     614:	8b e0       	ldi	r24, 0x0B	; 11
     616:	90 e0       	ldi	r25, 0x00	; 0
     618:	0e 94 9e 04 	call	0x93c	; 0x93c <pvPortMalloc>
     61c:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     61e:	00 97       	sbiw	r24, 0x00	; 0
     620:	31 f0       	breq	.+12     	; 0x62e <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     622:	fc 01       	movw	r30, r24
     624:	11 92       	st	Z+, r1
     626:	11 92       	st	Z+, r1
     628:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     62a:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     62e:	8c 2f       	mov	r24, r28
     630:	9d 2f       	mov	r25, r29
     632:	df 91       	pop	r29
     634:	cf 91       	pop	r28
     636:	08 95       	ret

00000638 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     638:	af 92       	push	r10
     63a:	bf 92       	push	r11
     63c:	cf 92       	push	r12
     63e:	df 92       	push	r13
     640:	ef 92       	push	r14
     642:	ff 92       	push	r15
     644:	0f 93       	push	r16
     646:	1f 93       	push	r17
     648:	cf 93       	push	r28
     64a:	df 93       	push	r29
     64c:	5c 01       	movw	r10, r24
     64e:	6b 01       	movw	r12, r22
     650:	e4 2e       	mov	r14, r20
     652:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     654:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     658:	f5 01       	movw	r30, r10
     65a:	c0 81       	ld	r28, Z
     65c:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     65e:	ce 01       	movw	r24, r28
     660:	b6 01       	movw	r22, r12
     662:	4f 2d       	mov	r20, r15
     664:	0e 94 f5 02 	call	0x5ea	; 0x5ea <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     668:	88 23       	and	r24, r24
     66a:	51 f0       	breq	.+20     	; 0x680 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     66c:	ee 20       	and	r14, r14
     66e:	01 f1       	breq	.+64     	; 0x6b0 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     670:	c0 94       	com	r12
     672:	d0 94       	com	r13
     674:	cc 22       	and	r12, r28
     676:	dd 22       	and	r13, r29
     678:	f5 01       	movw	r30, r10
     67a:	d1 82       	std	Z+1, r13	; 0x01
     67c:	c0 82       	st	Z, r12
     67e:	18 c0       	rjmp	.+48     	; 0x6b0 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     680:	01 15       	cp	r16, r1
     682:	11 05       	cpc	r17, r1
     684:	a9 f0       	breq	.+42     	; 0x6b0 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     686:	ee 20       	and	r14, r14
     688:	19 f4       	brne	.+6      	; 0x690 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     68a:	60 e0       	ldi	r22, 0x00	; 0
     68c:	70 e0       	ldi	r23, 0x00	; 0
     68e:	02 c0       	rjmp	.+4      	; 0x694 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     690:	60 e0       	ldi	r22, 0x00	; 0
     692:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     694:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     696:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     698:	6c 29       	or	r22, r12
     69a:	7d 29       	or	r23, r13
     69c:	c5 01       	movw	r24, r10
     69e:	02 96       	adiw	r24, 0x02	; 2
     6a0:	a8 01       	movw	r20, r16
     6a2:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     6a6:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     6aa:	88 23       	and	r24, r24
     6ac:	39 f4       	brne	.+14     	; 0x6bc <xEventGroupWaitBits+0x84>
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     6b0:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
     6b4:	ce 01       	movw	r24, r28
     6b6:	21 c0       	rjmp	.+66     	; 0x6fa <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     6b8:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     6bc:	0e 94 ef 14 	call	0x29de	; 0x29de <uxTaskResetEventItemValue>
     6c0:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     6c2:	91 fd       	sbrc	r25, 1
     6c4:	18 c0       	rjmp	.+48     	; 0x6f6 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     6c6:	0f b6       	in	r0, 0x3f	; 63
     6c8:	f8 94       	cli
     6ca:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     6cc:	f5 01       	movw	r30, r10
     6ce:	c0 81       	ld	r28, Z
     6d0:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     6d2:	ce 01       	movw	r24, r28
     6d4:	b6 01       	movw	r22, r12
     6d6:	4f 2d       	mov	r20, r15
     6d8:	0e 94 f5 02 	call	0x5ea	; 0x5ea <prvTestWaitCondition>
     6dc:	88 23       	and	r24, r24
     6de:	49 f0       	breq	.+18     	; 0x6f2 <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     6e0:	ee 20       	and	r14, r14
     6e2:	39 f0       	breq	.+14     	; 0x6f2 <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     6e4:	c0 94       	com	r12
     6e6:	d0 94       	com	r13
     6e8:	cc 22       	and	r12, r28
     6ea:	dd 22       	and	r13, r29
     6ec:	f5 01       	movw	r30, r10
     6ee:	d1 82       	std	Z+1, r13	; 0x01
     6f0:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     6f2:	0f 90       	pop	r0
     6f4:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     6f6:	ce 01       	movw	r24, r28
     6f8:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	1f 91       	pop	r17
     700:	0f 91       	pop	r16
     702:	ff 90       	pop	r15
     704:	ef 90       	pop	r14
     706:	df 90       	pop	r13
     708:	cf 90       	pop	r12
     70a:	bf 90       	pop	r11
     70c:	af 90       	pop	r10
     70e:	08 95       	ret

00000710 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     710:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     718:	80 81       	ld	r24, Z
     71a:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     71c:	60 95       	com	r22
     71e:	70 95       	com	r23
     720:	68 23       	and	r22, r24
     722:	79 23       	and	r23, r25
     724:	71 83       	std	Z+1, r23	; 0x01
     726:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     728:	0f 90       	pop	r0
     72a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     72c:	08 95       	ret

0000072e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     72e:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     730:	80 81       	ld	r24, Z
     732:	91 81       	ldd	r25, Z+1	; 0x01
     734:	08 95       	ret

00000736 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     736:	af 92       	push	r10
     738:	bf 92       	push	r11
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
     742:	0f 93       	push	r16
     744:	1f 93       	push	r17
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
     74a:	8c 01       	movw	r16, r24
     74c:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74e:	0f 2e       	mov	r0, r31
     750:	f5 e0       	ldi	r31, 0x05	; 5
     752:	cf 2e       	mov	r12, r31
     754:	dd 24       	eor	r13, r13
     756:	f0 2d       	mov	r31, r0
     758:	c8 0e       	add	r12, r24
     75a:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     75c:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     760:	d8 01       	movw	r26, r16
     762:	17 96       	adiw	r26, 0x07	; 7
     764:	ed 91       	ld	r30, X+
     766:	fc 91       	ld	r31, X
     768:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     76a:	8d 91       	ld	r24, X+
     76c:	9c 91       	ld	r25, X
     76e:	11 97       	sbiw	r26, 0x01	; 1
     770:	8c 2b       	or	r24, r28
     772:	9d 2b       	or	r25, r29
     774:	11 96       	adiw	r26, 0x01	; 1
     776:	9c 93       	st	X, r25
     778:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     77a:	ce 16       	cp	r12, r30
     77c:	df 06       	cpc	r13, r31
     77e:	c1 f1       	breq	.+112    	; 0x7f0 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     780:	aa 24       	eor	r10, r10
     782:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     784:	ff 24       	eor	r15, r15
     786:	f3 94       	inc	r15
     788:	ee 24       	eor	r14, r14
     78a:	01 c0       	rjmp	.+2      	; 0x78e <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     78c:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     78e:	c2 81       	ldd	r28, Z+2	; 0x02
     790:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     792:	80 81       	ld	r24, Z
     794:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     796:	bc 01       	movw	r22, r24
     798:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     79a:	9c 01       	movw	r18, r24
     79c:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     79e:	92 fd       	sbrc	r25, 2
     7a0:	0b c0       	rjmp	.+22     	; 0x7b8 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     7a2:	d8 01       	movw	r26, r16
     7a4:	8d 91       	ld	r24, X+
     7a6:	9c 91       	ld	r25, X
     7a8:	11 97       	sbiw	r26, 0x01	; 1
     7aa:	82 23       	and	r24, r18
     7ac:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     7ae:	4f 2d       	mov	r20, r15
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	69 f4       	brne	.+26     	; 0x7ce <xEventGroupSetBits+0x98>
     7b4:	4e 2d       	mov	r20, r14
     7b6:	0b c0       	rjmp	.+22     	; 0x7ce <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     7b8:	d8 01       	movw	r26, r16
     7ba:	8d 91       	ld	r24, X+
     7bc:	9c 91       	ld	r25, X
     7be:	11 97       	sbiw	r26, 0x01	; 1
     7c0:	82 23       	and	r24, r18
     7c2:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     7c4:	4f 2d       	mov	r20, r15
     7c6:	28 17       	cp	r18, r24
     7c8:	39 07       	cpc	r19, r25
     7ca:	09 f0       	breq	.+2      	; 0x7ce <xEventGroupSetBits+0x98>
     7cc:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     7ce:	44 23       	and	r20, r20
     7d0:	59 f0       	breq	.+22     	; 0x7e8 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     7d2:	70 ff       	sbrs	r23, 0
     7d4:	02 c0       	rjmp	.+4      	; 0x7da <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     7d6:	a2 2a       	or	r10, r18
     7d8:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     7da:	d8 01       	movw	r26, r16
     7dc:	6d 91       	ld	r22, X+
     7de:	7c 91       	ld	r23, X
     7e0:	72 60       	ori	r23, 0x02	; 2
     7e2:	cf 01       	movw	r24, r30
     7e4:	0e 94 cd 13 	call	0x279a	; 0x279a <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     7e8:	cc 16       	cp	r12, r28
     7ea:	dd 06       	cpc	r13, r29
     7ec:	79 f6       	brne	.-98     	; 0x78c <xEventGroupSetBits+0x56>
     7ee:	02 c0       	rjmp	.+4      	; 0x7f4 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     7f0:	aa 24       	eor	r10, r10
     7f2:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     7f4:	c5 01       	movw	r24, r10
     7f6:	80 95       	com	r24
     7f8:	90 95       	com	r25
     7fa:	f8 01       	movw	r30, r16
     7fc:	a0 80       	ld	r10, Z
     7fe:	b1 80       	ldd	r11, Z+1	; 0x01
     800:	a8 22       	and	r10, r24
     802:	b9 22       	and	r11, r25
     804:	b1 82       	std	Z+1, r11	; 0x01
     806:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     808:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     80c:	d8 01       	movw	r26, r16
     80e:	8c 91       	ld	r24, X
     810:	11 96       	adiw	r26, 0x01	; 1
     812:	9c 91       	ld	r25, X
     814:	11 97       	sbiw	r26, 0x01	; 1
     816:	df 91       	pop	r29
     818:	cf 91       	pop	r28
     81a:	1f 91       	pop	r17
     81c:	0f 91       	pop	r16
     81e:	ff 90       	pop	r15
     820:	ef 90       	pop	r14
     822:	df 90       	pop	r13
     824:	cf 90       	pop	r12
     826:	bf 90       	pop	r11
     828:	af 90       	pop	r10
     82a:	08 95       	ret

0000082c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     82c:	af 92       	push	r10
     82e:	bf 92       	push	r11
     830:	cf 92       	push	r12
     832:	df 92       	push	r13
     834:	ef 92       	push	r14
     836:	ff 92       	push	r15
     838:	0f 93       	push	r16
     83a:	1f 93       	push	r17
     83c:	cf 93       	push	r28
     83e:	df 93       	push	r29
     840:	6c 01       	movw	r12, r24
     842:	eb 01       	movw	r28, r22
     844:	7a 01       	movw	r14, r20
     846:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     848:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     84c:	f6 01       	movw	r30, r12
     84e:	00 81       	ld	r16, Z
     850:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     852:	c6 01       	movw	r24, r12
     854:	be 01       	movw	r22, r28
     856:	0e 94 9b 03 	call	0x736	; 0x736 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     85a:	c0 2b       	or	r28, r16
     85c:	d1 2b       	or	r29, r17
     85e:	c7 01       	movw	r24, r14
     860:	8c 23       	and	r24, r28
     862:	9d 23       	and	r25, r29
     864:	8e 15       	cp	r24, r14
     866:	9f 05       	cpc	r25, r15
     868:	51 f4       	brne	.+20     	; 0x87e <__stack+0x1f>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     86a:	80 95       	com	r24
     86c:	90 95       	com	r25
     86e:	f6 01       	movw	r30, r12
     870:	20 81       	ld	r18, Z
     872:	31 81       	ldd	r19, Z+1	; 0x01
     874:	82 23       	and	r24, r18
     876:	93 23       	and	r25, r19
     878:	91 83       	std	Z+1, r25	; 0x01
     87a:	80 83       	st	Z, r24
     87c:	12 c0       	rjmp	.+36     	; 0x8a2 <__stack+0x43>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     87e:	a1 14       	cp	r10, r1
     880:	b1 04       	cpc	r11, r1
     882:	61 f0       	breq	.+24     	; 0x89c <__stack+0x3d>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     884:	b7 01       	movw	r22, r14
     886:	75 60       	ori	r23, 0x05	; 5
     888:	c6 01       	movw	r24, r12
     88a:	02 96       	adiw	r24, 0x02	; 2
     88c:	a5 01       	movw	r20, r10
     88e:	0e 94 69 13 	call	0x26d2	; 0x26d2 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     892:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     896:	88 23       	and	r24, r24
     898:	49 f4       	brne	.+18     	; 0x8ac <__stack+0x4d>
     89a:	06 c0       	rjmp	.+12     	; 0x8a8 <__stack+0x49>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     89c:	f6 01       	movw	r30, r12
     89e:	c0 81       	ld	r28, Z
     8a0:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     8a2:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
     8a6:	1c c0       	rjmp	.+56     	; 0x8e0 <__stack+0x81>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     8a8:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     8ac:	0e 94 ef 14 	call	0x29de	; 0x29de <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     8b0:	91 fd       	sbrc	r25, 1
     8b2:	14 c0       	rjmp	.+40     	; 0x8dc <__stack+0x7d>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     8b4:	0f b6       	in	r0, 0x3f	; 63
     8b6:	f8 94       	cli
     8b8:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     8ba:	f6 01       	movw	r30, r12
     8bc:	80 81       	ld	r24, Z
     8be:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     8c0:	97 01       	movw	r18, r14
     8c2:	28 23       	and	r18, r24
     8c4:	39 23       	and	r19, r25
     8c6:	2e 15       	cp	r18, r14
     8c8:	3f 05       	cpc	r19, r15
     8ca:	31 f4       	brne	.+12     	; 0x8d8 <__stack+0x79>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8cc:	20 95       	com	r18
     8ce:	30 95       	com	r19
     8d0:	28 23       	and	r18, r24
     8d2:	39 23       	and	r19, r25
     8d4:	31 83       	std	Z+1, r19	; 0x01
     8d6:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     8d8:	0f 90       	pop	r0
     8da:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     8dc:	ec 01       	movw	r28, r24
     8de:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     8e0:	8c 2f       	mov	r24, r28
     8e2:	9d 2f       	mov	r25, r29
     8e4:	df 91       	pop	r29
     8e6:	cf 91       	pop	r28
     8e8:	1f 91       	pop	r17
     8ea:	0f 91       	pop	r16
     8ec:	ff 90       	pop	r15
     8ee:	ef 90       	pop	r14
     8f0:	df 90       	pop	r13
     8f2:	cf 90       	pop	r12
     8f4:	bf 90       	pop	r11
     8f6:	af 90       	pop	r10
     8f8:	08 95       	ret

000008fa <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     900:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     904:	8a 81       	ldd	r24, Y+2	; 0x02
     906:	88 23       	and	r24, r24
     908:	49 f0       	breq	.+18     	; 0x91c <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     90a:	8f 81       	ldd	r24, Y+7	; 0x07
     90c:	98 85       	ldd	r25, Y+8	; 0x08
     90e:	60 e0       	ldi	r22, 0x00	; 0
     910:	72 e0       	ldi	r23, 0x02	; 2
     912:	0e 94 cd 13 	call	0x279a	; 0x279a <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     916:	8a 81       	ldd	r24, Y+2	; 0x02
     918:	88 23       	and	r24, r24
     91a:	b9 f7       	brne	.-18     	; 0x90a <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     91c:	ce 01       	movw	r24, r28
     91e:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     922:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
}
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     92c:	ba 01       	movw	r22, r20
     92e:	0e 94 9b 03 	call	0x736	; 0x736 <xEventGroupSetBits>
}
     932:	08 95       	ret

00000934 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     934:	ba 01       	movw	r22, r20
     936:	0e 94 88 03 	call	0x710	; 0x710 <xEventGroupClearBits>
}
     93a:	08 95       	ret

0000093c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     93c:	0f 93       	push	r16
     93e:	1f 93       	push	r17
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     946:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     94a:	80 91 7c 00 	lds	r24, 0x007C
     94e:	88 23       	and	r24, r24
     950:	f9 f4       	brne	.+62     	; 0x990 <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     952:	86 e8       	ldi	r24, 0x86	; 134
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	90 93 7e 00 	sts	0x007E, r25
     95a:	80 93 7d 00 	sts	0x007D, r24
	xStart.xBlockSize = ( size_t ) 0;
     95e:	10 92 80 00 	sts	0x0080, r1
     962:	10 92 7f 00 	sts	0x007F, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     966:	8f e1       	ldi	r24, 0x1F	; 31
     968:	93 e0       	ldi	r25, 0x03	; 3
     96a:	90 93 84 00 	sts	0x0084, r25
     96e:	80 93 83 00 	sts	0x0083, r24
	xEnd.pxNextFreeBlock = NULL;
     972:	e3 e8       	ldi	r30, 0x83	; 131
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	12 92       	st	-Z, r1
     978:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     97a:	90 93 89 00 	sts	0x0089, r25
     97e:	80 93 88 00 	sts	0x0088, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     982:	f0 93 87 00 	sts	0x0087, r31
     986:	e0 93 86 00 	sts	0x0086, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	80 93 7c 00 	sts	0x007C, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     990:	20 97       	sbiw	r28, 0x00	; 0
     992:	09 f4       	brne	.+2      	; 0x996 <pvPortMalloc+0x5a>
     994:	62 c0       	rjmp	.+196    	; 0xa5a <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     996:	9e 01       	movw	r18, r28
     998:	2c 5f       	subi	r18, 0xFC	; 252
     99a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     99c:	23 96       	adiw	r28, 0x03	; 3
     99e:	83 e0       	ldi	r24, 0x03	; 3
     9a0:	ce 31       	cpi	r28, 0x1E	; 30
     9a2:	d8 07       	cpc	r29, r24
     9a4:	08 f0       	brcs	.+2      	; 0x9a8 <pvPortMalloc+0x6c>
     9a6:	5c c0       	rjmp	.+184    	; 0xa60 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     9a8:	e0 91 7d 00 	lds	r30, 0x007D
     9ac:	f0 91 7e 00 	lds	r31, 0x007E

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     9b0:	ad e7       	ldi	r26, 0x7D	; 125
     9b2:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     9b4:	02 c0       	rjmp	.+4      	; 0x9ba <pvPortMalloc+0x7e>
     9b6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     9b8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     9ba:	82 81       	ldd	r24, Z+2	; 0x02
     9bc:	93 81       	ldd	r25, Z+3	; 0x03
     9be:	82 17       	cp	r24, r18
     9c0:	93 07       	cpc	r25, r19
     9c2:	20 f4       	brcc	.+8      	; 0x9cc <pvPortMalloc+0x90>
     9c4:	80 81       	ld	r24, Z
     9c6:	91 81       	ldd	r25, Z+1	; 0x01
     9c8:	00 97       	sbiw	r24, 0x00	; 0
     9ca:	a9 f7       	brne	.-22     	; 0x9b6 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     9cc:	c0 e0       	ldi	r28, 0x00	; 0
     9ce:	e1 38       	cpi	r30, 0x81	; 129
     9d0:	fc 07       	cpc	r31, r28
     9d2:	09 f4       	brne	.+2      	; 0x9d6 <pvPortMalloc+0x9a>
     9d4:	48 c0       	rjmp	.+144    	; 0xa66 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     9d6:	8d 91       	ld	r24, X+
     9d8:	9c 91       	ld	r25, X
     9da:	11 97       	sbiw	r26, 0x01	; 1
     9dc:	8c 01       	movw	r16, r24
     9de:	0c 5f       	subi	r16, 0xFC	; 252
     9e0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     9e2:	80 81       	ld	r24, Z
     9e4:	91 81       	ldd	r25, Z+1	; 0x01
     9e6:	11 96       	adiw	r26, 0x01	; 1
     9e8:	9c 93       	st	X, r25
     9ea:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     9ec:	82 81       	ldd	r24, Z+2	; 0x02
     9ee:	93 81       	ldd	r25, Z+3	; 0x03
     9f0:	82 1b       	sub	r24, r18
     9f2:	93 0b       	sbc	r25, r19
     9f4:	89 30       	cpi	r24, 0x09	; 9
     9f6:	91 05       	cpc	r25, r1
     9f8:	18 f1       	brcs	.+70     	; 0xa40 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     9fa:	af 01       	movw	r20, r30
     9fc:	42 0f       	add	r20, r18
     9fe:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     a00:	da 01       	movw	r26, r20
     a02:	13 96       	adiw	r26, 0x03	; 3
     a04:	9c 93       	st	X, r25
     a06:	8e 93       	st	-X, r24
     a08:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     a0a:	33 83       	std	Z+3, r19	; 0x03
     a0c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     a0e:	12 96       	adiw	r26, 0x02	; 2
     a10:	2d 91       	ld	r18, X+
     a12:	3c 91       	ld	r19, X
     a14:	13 97       	sbiw	r26, 0x03	; 3
     a16:	6d e7       	ldi	r22, 0x7D	; 125
     a18:	70 e0       	ldi	r23, 0x00	; 0
     a1a:	01 c0       	rjmp	.+2      	; 0xa1e <pvPortMalloc+0xe2>
     a1c:	bd 01       	movw	r22, r26
     a1e:	eb 01       	movw	r28, r22
     a20:	a8 81       	ld	r26, Y
     a22:	b9 81       	ldd	r27, Y+1	; 0x01
     a24:	12 96       	adiw	r26, 0x02	; 2
     a26:	8d 91       	ld	r24, X+
     a28:	9c 91       	ld	r25, X
     a2a:	13 97       	sbiw	r26, 0x03	; 3
     a2c:	82 17       	cp	r24, r18
     a2e:	93 07       	cpc	r25, r19
     a30:	a8 f3       	brcs	.-22     	; 0xa1c <pvPortMalloc+0xe0>
     a32:	ea 01       	movw	r28, r20
     a34:	b9 83       	std	Y+1, r27	; 0x01
     a36:	a8 83       	st	Y, r26
     a38:	db 01       	movw	r26, r22
     a3a:	11 96       	adiw	r26, 0x01	; 1
     a3c:	5c 93       	st	X, r21
     a3e:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     a40:	80 91 60 00 	lds	r24, 0x0060
     a44:	90 91 61 00 	lds	r25, 0x0061
     a48:	22 81       	ldd	r18, Z+2	; 0x02
     a4a:	33 81       	ldd	r19, Z+3	; 0x03
     a4c:	82 1b       	sub	r24, r18
     a4e:	93 0b       	sbc	r25, r19
     a50:	90 93 61 00 	sts	0x0061, r25
     a54:	80 93 60 00 	sts	0x0060, r24
     a58:	08 c0       	rjmp	.+16     	; 0xa6a <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     a5a:	00 e0       	ldi	r16, 0x00	; 0
     a5c:	10 e0       	ldi	r17, 0x00	; 0
     a5e:	05 c0       	rjmp	.+10     	; 0xa6a <pvPortMalloc+0x12e>
     a60:	00 e0       	ldi	r16, 0x00	; 0
     a62:	10 e0       	ldi	r17, 0x00	; 0
     a64:	02 c0       	rjmp	.+4      	; 0xa6a <pvPortMalloc+0x12e>
     a66:	00 e0       	ldi	r16, 0x00	; 0
     a68:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     a6a:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     a6e:	80 2f       	mov	r24, r16
     a70:	91 2f       	mov	r25, r17
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	1f 91       	pop	r17
     a78:	0f 91       	pop	r16
     a7a:	08 95       	ret

00000a7c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a7c:	0f 93       	push	r16
     a7e:	1f 93       	push	r17
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     a86:	00 97       	sbiw	r24, 0x00	; 0
     a88:	39 f1       	breq	.+78     	; 0xad8 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     a8a:	8c 01       	movw	r16, r24
     a8c:	04 50       	subi	r16, 0x04	; 4
     a8e:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     a90:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     a94:	f8 01       	movw	r30, r16
     a96:	22 81       	ldd	r18, Z+2	; 0x02
     a98:	33 81       	ldd	r19, Z+3	; 0x03
     a9a:	ad e7       	ldi	r26, 0x7D	; 125
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <vPortFree+0x26>
     aa0:	df 01       	movw	r26, r30
     aa2:	ed 91       	ld	r30, X+
     aa4:	fc 91       	ld	r31, X
     aa6:	11 97       	sbiw	r26, 0x01	; 1
     aa8:	82 81       	ldd	r24, Z+2	; 0x02
     aaa:	93 81       	ldd	r25, Z+3	; 0x03
     aac:	82 17       	cp	r24, r18
     aae:	93 07       	cpc	r25, r19
     ab0:	b8 f3       	brcs	.-18     	; 0xaa0 <vPortFree+0x24>
     ab2:	24 97       	sbiw	r28, 0x04	; 4
     ab4:	f9 83       	std	Y+1, r31	; 0x01
     ab6:	e8 83       	st	Y, r30
     ab8:	0d 93       	st	X+, r16
     aba:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     abc:	80 91 60 00 	lds	r24, 0x0060
     ac0:	90 91 61 00 	lds	r25, 0x0061
     ac4:	2a 81       	ldd	r18, Y+2	; 0x02
     ac6:	3b 81       	ldd	r19, Y+3	; 0x03
     ac8:	82 0f       	add	r24, r18
     aca:	93 1f       	adc	r25, r19
     acc:	90 93 61 00 	sts	0x0061, r25
     ad0:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     ad4:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
	}
}
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	1f 91       	pop	r17
     ade:	0f 91       	pop	r16
     ae0:	08 95       	ret

00000ae2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     ae2:	80 91 60 00 	lds	r24, 0x0060
     ae6:	90 91 61 00 	lds	r25, 0x0061
     aea:	08 95       	ret

00000aec <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     aec:	08 95       	ret

00000aee <keypad_vInit>:
 *  Author: Mohamed Zaghlol
 */ 
 #include "keypad_driver.h"
 void keypad_vInit()
 {
	 DIO_vsetPINDir('D',0,1);
     aee:	84 e4       	ldi	r24, 0x44	; 68
     af0:	60 e0       	ldi	r22, 0x00	; 0
     af2:	41 e0       	ldi	r20, 0x01	; 1
     af4:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',1,1);
     af8:	84 e4       	ldi	r24, 0x44	; 68
     afa:	61 e0       	ldi	r22, 0x01	; 1
     afc:	41 e0       	ldi	r20, 0x01	; 1
     afe:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',2,1);
     b02:	84 e4       	ldi	r24, 0x44	; 68
     b04:	62 e0       	ldi	r22, 0x02	; 2
     b06:	41 e0       	ldi	r20, 0x01	; 1
     b08:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',3,1);
     b0c:	84 e4       	ldi	r24, 0x44	; 68
     b0e:	63 e0       	ldi	r22, 0x03	; 3
     b10:	41 e0       	ldi	r20, 0x01	; 1
     b12:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',4,0);
     b16:	84 e4       	ldi	r24, 0x44	; 68
     b18:	64 e0       	ldi	r22, 0x04	; 4
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',5,0);
     b20:	84 e4       	ldi	r24, 0x44	; 68
     b22:	65 e0       	ldi	r22, 0x05	; 5
     b24:	40 e0       	ldi	r20, 0x00	; 0
     b26:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',6,0);
     b2a:	84 e4       	ldi	r24, 0x44	; 68
     b2c:	66 e0       	ldi	r22, 0x06	; 6
     b2e:	40 e0       	ldi	r20, 0x00	; 0
     b30:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vsetPINDir('D',7,0);
     b34:	84 e4       	ldi	r24, 0x44	; 68
     b36:	67 e0       	ldi	r22, 0x07	; 7
     b38:	40 e0       	ldi	r20, 0x00	; 0
     b3a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	 DIO_vconnectpullup('D',4,1);
     b3e:	84 e4       	ldi	r24, 0x44	; 68
     b40:	64 e0       	ldi	r22, 0x04	; 4
     b42:	41 e0       	ldi	r20, 0x01	; 1
     b44:	0e 94 25 02 	call	0x44a	; 0x44a <DIO_vconnectpullup>
	 DIO_vconnectpullup('D',5,1);
     b48:	84 e4       	ldi	r24, 0x44	; 68
     b4a:	65 e0       	ldi	r22, 0x05	; 5
     b4c:	41 e0       	ldi	r20, 0x01	; 1
     b4e:	0e 94 25 02 	call	0x44a	; 0x44a <DIO_vconnectpullup>
	 DIO_vconnectpullup('D',6,1);
     b52:	84 e4       	ldi	r24, 0x44	; 68
     b54:	66 e0       	ldi	r22, 0x06	; 6
     b56:	41 e0       	ldi	r20, 0x01	; 1
     b58:	0e 94 25 02 	call	0x44a	; 0x44a <DIO_vconnectpullup>
	 DIO_vconnectpullup('D',7,1);
     b5c:	84 e4       	ldi	r24, 0x44	; 68
     b5e:	67 e0       	ldi	r22, 0x07	; 7
     b60:	41 e0       	ldi	r20, 0x01	; 1
     b62:	0e 94 25 02 	call	0x44a	; 0x44a <DIO_vconnectpullup>
	  
 }
     b66:	08 95       	ret

00000b68 <keypad_u8check_press>:
 char keypad_u8check_press()
 {
     b68:	0f 93       	push	r16
     b6a:	1f 93       	push	r17
     b6c:	cf 93       	push	r28
     b6e:	df 93       	push	r29
     b70:	cd b7       	in	r28, 0x3d	; 61
     b72:	de b7       	in	r29, 0x3e	; 62
     b74:	60 97       	sbiw	r28, 0x10	; 16
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	de bf       	out	0x3e, r29	; 62
     b7c:	0f be       	out	0x3f, r0	; 63
     b7e:	cd bf       	out	0x3d, r28	; 61
	 char arr[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'A','0','=','+'}};
     b80:	de 01       	movw	r26, r28
     b82:	11 96       	adiw	r26, 0x01	; 1
     b84:	e2 e6       	ldi	r30, 0x62	; 98
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	80 e1       	ldi	r24, 0x10	; 16
     b8a:	01 90       	ld	r0, Z+
     b8c:	0d 92       	st	X+, r0
     b8e:	81 50       	subi	r24, 0x01	; 1
     b90:	e1 f7       	brne	.-8      	; 0xb8a <keypad_u8check_press+0x22>
	 char row,coloumn,x;
	 char returnval=NOTPRESSED;
	 for(row=0;row<4;row++)
     b92:	00 e0       	ldi	r16, 0x00	; 0
	 {
		DIO_write('D',0,1);
     b94:	84 e4       	ldi	r24, 0x44	; 68
     b96:	60 e0       	ldi	r22, 0x00	; 0
     b98:	41 e0       	ldi	r20, 0x01	; 1
     b9a:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
		DIO_write('D',1,1);
     b9e:	84 e4       	ldi	r24, 0x44	; 68
     ba0:	61 e0       	ldi	r22, 0x01	; 1
     ba2:	41 e0       	ldi	r20, 0x01	; 1
     ba4:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
		DIO_write('D',2,1);
     ba8:	84 e4       	ldi	r24, 0x44	; 68
     baa:	62 e0       	ldi	r22, 0x02	; 2
     bac:	41 e0       	ldi	r20, 0x01	; 1
     bae:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
		DIO_write('D',3,1);
     bb2:	84 e4       	ldi	r24, 0x44	; 68
     bb4:	63 e0       	ldi	r22, 0x03	; 3
     bb6:	41 e0       	ldi	r20, 0x01	; 1
     bb8:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
		DIO_write('D',row,0);
     bbc:	84 e4       	ldi	r24, 0x44	; 68
     bbe:	60 2f       	mov	r22, r16
     bc0:	40 e0       	ldi	r20, 0x00	; 0
     bc2:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
	
		for(coloumn=0;coloumn<4;coloumn++)
     bc6:	10 e0       	ldi	r17, 0x00	; 0
	 DIO_vconnectpullup('D',5,1);
	 DIO_vconnectpullup('D',6,1);
	 DIO_vconnectpullup('D',7,1);
	  
 }
 char keypad_u8check_press()
     bc8:	61 2f       	mov	r22, r17
     bca:	6c 5f       	subi	r22, 0xFC	; 252
		DIO_write('D',3,1);
		DIO_write('D',row,0);
	
		for(coloumn=0;coloumn<4;coloumn++)
		{
			x=DIO_u8read('D',(coloumn+4));
     bcc:	84 e4       	ldi	r24, 0x44	; 68
     bce:	0e 94 4f 01 	call	0x29e	; 0x29e <DIO_u8read>
			if(x==0)
     bd2:	88 23       	and	r24, r24
     bd4:	61 f4       	brne	.+24     	; 0xbee <keypad_u8check_press+0x86>
			 {
				 returnval=arr[row][coloumn];
     bd6:	e0 2f       	mov	r30, r16
     bd8:	f0 e0       	ldi	r31, 0x00	; 0
     bda:	ee 0f       	add	r30, r30
     bdc:	ff 1f       	adc	r31, r31
     bde:	ee 0f       	add	r30, r30
     be0:	ff 1f       	adc	r31, r31
     be2:	e1 0f       	add	r30, r17
     be4:	f1 1d       	adc	r31, r1
     be6:	ec 0f       	add	r30, r28
     be8:	fd 1f       	adc	r31, r29
     bea:	81 81       	ldd	r24, Z+1	; 0x01
     bec:	04 c0       	rjmp	.+8      	; 0xbf6 <keypad_u8check_press+0x8e>
		DIO_write('D',1,1);
		DIO_write('D',2,1);
		DIO_write('D',3,1);
		DIO_write('D',row,0);
	
		for(coloumn=0;coloumn<4;coloumn++)
     bee:	1f 5f       	subi	r17, 0xFF	; 255
     bf0:	14 30       	cpi	r17, 0x04	; 4
     bf2:	51 f7       	brne	.-44     	; 0xbc8 <keypad_u8check_press+0x60>
     bf4:	0b c0       	rjmp	.+22     	; 0xc0c <keypad_u8check_press+0xa4>
		{
			break;
		}
	}	 
	 return returnval ;	 
     bf6:	60 96       	adiw	r28, 0x10	; 16
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	de bf       	out	0x3e, r29	; 62
     bfe:	0f be       	out	0x3f, r0	; 63
     c00:	cd bf       	out	0x3d, r28	; 61
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	08 95       	ret
 char keypad_u8check_press()
 {
	 char arr[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'A','0','=','+'}};
	 char row,coloumn,x;
	 char returnval=NOTPRESSED;
	 for(row=0;row<4;row++)
     c0c:	0f 5f       	subi	r16, 0xFF	; 255
     c0e:	04 30       	cpi	r16, 0x04	; 4
     c10:	09 f6       	brne	.-126    	; 0xb94 <keypad_u8check_press+0x2c>
     c12:	8f ef       	ldi	r24, 0xFF	; 255
     c14:	f0 cf       	rjmp	.-32     	; 0xbf6 <keypad_u8check_press+0x8e>

00000c16 <send_falling_edge>:
}


static void send_falling_edge(void)
{
	DIO_write('B',EN,1);
     c16:	82 e4       	ldi	r24, 0x42	; 66
     c18:	60 e0       	ldi	r22, 0x00	; 0
     c1a:	41 e0       	ldi	r20, 0x01	; 1
     c1c:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c20:	8f e9       	ldi	r24, 0x9F	; 159
     c22:	9f e0       	ldi	r25, 0x0F	; 15
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	f1 f7       	brne	.-4      	; 0xc24 <send_falling_edge+0xe>
     c28:	00 c0       	rjmp	.+0      	; 0xc2a <send_falling_edge+0x14>
     c2a:	00 00       	nop
	_delay_ms(2);
	DIO_write('B',EN,0);
     c2c:	82 e4       	ldi	r24, 0x42	; 66
     c2e:	60 e0       	ldi	r22, 0x00	; 0
     c30:	40 e0       	ldi	r20, 0x00	; 0
     c32:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
     c36:	8f e9       	ldi	r24, 0x9F	; 159
     c38:	9f e0       	ldi	r25, 0x0F	; 15
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	f1 f7       	brne	.-4      	; 0xc3a <send_falling_edge+0x24>
     c3e:	00 c0       	rjmp	.+0      	; 0xc40 <send_falling_edge+0x2a>
     c40:	00 00       	nop
	_delay_ms(2);
}
     c42:	08 95       	ret

00000c44 <LCD_vSend_cmd>:
void LCD_vSend_cmd(char cmd)
{
     c44:	68 2f       	mov	r22, r24
	#if defined eight_bits_mode
	DIO_write_port('A',cmd);
     c46:	81 e4       	ldi	r24, 0x41	; 65
     c48:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <DIO_write_port>
	DIO_write('B',RS,0);
     c4c:	82 e4       	ldi	r24, 0x42	; 66
     c4e:	61 e0       	ldi	r22, 0x01	; 1
     c50:	40 e0       	ldi	r20, 0x00	; 0
     c52:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
	send_falling_edge();
     c56:	0e 94 0b 06 	call	0xc16	; 0xc16 <send_falling_edge>
     c5a:	8f ec       	ldi	r24, 0xCF	; 207
     c5c:	97 e0       	ldi	r25, 0x07	; 7
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	f1 f7       	brne	.-4      	; 0xc5e <LCD_vSend_cmd+0x1a>
     c62:	00 c0       	rjmp	.+0      	; 0xc64 <LCD_vSend_cmd+0x20>
     c64:	00 00       	nop
	write_high_nibble('A',cmd);
	DIO_write('B',RS,0);
	send_falling_edge();
	#endif
	_delay_ms(1);
}
     c66:	08 95       	ret

00000c68 <LCD_vInit>:
     c68:	8f ef       	ldi	r24, 0xFF	; 255
     c6a:	91 ee       	ldi	r25, 0xE1	; 225
     c6c:	a4 e0       	ldi	r26, 0x04	; 4
     c6e:	81 50       	subi	r24, 0x01	; 1
     c70:	90 40       	sbci	r25, 0x00	; 0
     c72:	a0 40       	sbci	r26, 0x00	; 0
     c74:	e1 f7       	brne	.-8      	; 0xc6e <LCD_vInit+0x6>
     c76:	00 c0       	rjmp	.+0      	; 0xc78 <LCD_vInit+0x10>
     c78:	00 00       	nop

void LCD_vInit(void)
{
	_delay_ms(200);
	#if defined eight_bits_mode
	DIO_vsetPINDir('A',0,1);
     c7a:	81 e4       	ldi	r24, 0x41	; 65
     c7c:	60 e0       	ldi	r22, 0x00	; 0
     c7e:	41 e0       	ldi	r20, 0x01	; 1
     c80:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',1,1);
     c84:	81 e4       	ldi	r24, 0x41	; 65
     c86:	61 e0       	ldi	r22, 0x01	; 1
     c88:	41 e0       	ldi	r20, 0x01	; 1
     c8a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',2,1);
     c8e:	81 e4       	ldi	r24, 0x41	; 65
     c90:	62 e0       	ldi	r22, 0x02	; 2
     c92:	41 e0       	ldi	r20, 0x01	; 1
     c94:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',3,1);
     c98:	81 e4       	ldi	r24, 0x41	; 65
     c9a:	63 e0       	ldi	r22, 0x03	; 3
     c9c:	41 e0       	ldi	r20, 0x01	; 1
     c9e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',4,1);
     ca2:	81 e4       	ldi	r24, 0x41	; 65
     ca4:	64 e0       	ldi	r22, 0x04	; 4
     ca6:	41 e0       	ldi	r20, 0x01	; 1
     ca8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',5,1);
     cac:	81 e4       	ldi	r24, 0x41	; 65
     cae:	65 e0       	ldi	r22, 0x05	; 5
     cb0:	41 e0       	ldi	r20, 0x01	; 1
     cb2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',6,1);
     cb6:	81 e4       	ldi	r24, 0x41	; 65
     cb8:	66 e0       	ldi	r22, 0x06	; 6
     cba:	41 e0       	ldi	r20, 0x01	; 1
     cbc:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('A',7,1);
     cc0:	81 e4       	ldi	r24, 0x41	; 65
     cc2:	67 e0       	ldi	r22, 0x07	; 7
     cc4:	41 e0       	ldi	r20, 0x01	; 1
     cc6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('B',EN,1);
     cca:	82 e4       	ldi	r24, 0x42	; 66
     ccc:	60 e0       	ldi	r22, 0x00	; 0
     cce:	41 e0       	ldi	r20, 0x01	; 1
     cd0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('B',RW,1);
     cd4:	82 e4       	ldi	r24, 0x42	; 66
     cd6:	62 e0       	ldi	r22, 0x02	; 2
     cd8:	41 e0       	ldi	r20, 0x01	; 1
     cda:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_vsetPINDir('B',RS,1);
     cde:	82 e4       	ldi	r24, 0x42	; 66
     ce0:	61 e0       	ldi	r22, 0x01	; 1
     ce2:	41 e0       	ldi	r20, 0x01	; 1
     ce4:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vsetPINDir>
	DIO_write('B',RW,0);
     ce8:	82 e4       	ldi	r24, 0x42	; 66
     cea:	62 e0       	ldi	r22, 0x02	; 2
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
	LCD_vSend_cmd(EIGHT_BITS); //8 bit mode
     cf2:	88 e3       	ldi	r24, 0x38	; 56
     cf4:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     cf8:	af ec       	ldi	r26, 0xCF	; 207
     cfa:	b7 e0       	ldi	r27, 0x07	; 7
     cfc:	11 97       	sbiw	r26, 0x01	; 1
     cfe:	f1 f7       	brne	.-4      	; 0xcfc <LCD_vInit+0x94>
     d00:	00 c0       	rjmp	.+0      	; 0xd02 <LCD_vInit+0x9a>
     d02:	00 00       	nop
	_delay_ms(1);
	LCD_vSend_cmd(CURSOR_ON_DISPLAN_ON);//display on cursor on
     d04:	8e e0       	ldi	r24, 0x0E	; 14
     d06:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     d0a:	8f ec       	ldi	r24, 0xCF	; 207
     d0c:	97 e0       	ldi	r25, 0x07	; 7
     d0e:	01 97       	sbiw	r24, 0x01	; 1
     d10:	f1 f7       	brne	.-4      	; 0xd0e <LCD_vInit+0xa6>
     d12:	00 c0       	rjmp	.+0      	; 0xd14 <LCD_vInit+0xac>
     d14:	00 00       	nop
	_delay_ms(1);
	LCD_vSend_cmd(CLR_SCREEN);//clear the screen
     d16:	81 e0       	ldi	r24, 0x01	; 1
     d18:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     d1c:	af e1       	ldi	r26, 0x1F	; 31
     d1e:	be e4       	ldi	r27, 0x4E	; 78
     d20:	11 97       	sbiw	r26, 0x01	; 1
     d22:	f1 f7       	brne	.-4      	; 0xd20 <LCD_vInit+0xb8>
     d24:	00 c0       	rjmp	.+0      	; 0xd26 <LCD_vInit+0xbe>
     d26:	00 00       	nop
	_delay_ms(10);
	LCD_vSend_cmd(ENTRY_MODE); //entry mode
     d28:	86 e0       	ldi	r24, 0x06	; 6
     d2a:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     d2e:	8f ec       	ldi	r24, 0xCF	; 207
     d30:	97 e0       	ldi	r25, 0x07	; 7
     d32:	01 97       	sbiw	r24, 0x01	; 1
     d34:	f1 f7       	brne	.-4      	; 0xd32 <LCD_vInit+0xca>
     d36:	00 c0       	rjmp	.+0      	; 0xd38 <LCD_vInit+0xd0>
     d38:	00 00       	nop
	LCD_vSend_cmd(CLR_SCREEN);//clear the screen
	_delay_ms(10);
	LCD_vSend_cmd(ENTRY_MODE); //entry mode
	_delay_ms(1);
	#endif
}
     d3a:	08 95       	ret

00000d3c <LCD_vSend_char>:
	#endif
	_delay_ms(1);
}

void LCD_vSend_char(char data)
{
     d3c:	68 2f       	mov	r22, r24
	#if defined eight_bits_mode
	DIO_write_port('A',data);
     d3e:	81 e4       	ldi	r24, 0x41	; 65
     d40:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <DIO_write_port>
	DIO_write('B',RS,1);
     d44:	82 e4       	ldi	r24, 0x42	; 66
     d46:	61 e0       	ldi	r22, 0x01	; 1
     d48:	41 e0       	ldi	r20, 0x01	; 1
     d4a:	0e 94 cc 00 	call	0x198	; 0x198 <DIO_write>
	send_falling_edge();
     d4e:	0e 94 0b 06 	call	0xc16	; 0xc16 <send_falling_edge>
     d52:	8f ec       	ldi	r24, 0xCF	; 207
     d54:	97 e0       	ldi	r25, 0x07	; 7
     d56:	01 97       	sbiw	r24, 0x01	; 1
     d58:	f1 f7       	brne	.-4      	; 0xd56 <LCD_vSend_char+0x1a>
     d5a:	00 c0       	rjmp	.+0      	; 0xd5c <LCD_vSend_char+0x20>
     d5c:	00 00       	nop
	write_high_nibble('A',data);
	DIO_write('B',RS,1);
	send_falling_edge();
	#endif
	_delay_ms(1);
}
     d5e:	08 95       	ret

00000d60 <LCD_vSend_string>:


void LCD_vSend_string(char *data)
{
     d60:	cf 93       	push	r28
     d62:	df 93       	push	r29
     d64:	ec 01       	movw	r28, r24
	while((*data)!='\0')
     d66:	88 81       	ld	r24, Y
     d68:	88 23       	and	r24, r24
     d6a:	31 f0       	breq	.+12     	; 0xd78 <LCD_vSend_string+0x18>
	#endif
	_delay_ms(1);
}


void LCD_vSend_string(char *data)
     d6c:	21 96       	adiw	r28, 0x01	; 1
{
	while((*data)!='\0')
	{
		LCD_vSend_char(*data);
     d6e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <LCD_vSend_char>
}


void LCD_vSend_string(char *data)
{
	while((*data)!='\0')
     d72:	89 91       	ld	r24, Y+
     d74:	88 23       	and	r24, r24
     d76:	d9 f7       	brne	.-10     	; 0xd6e <LCD_vSend_string+0xe>
	{
		LCD_vSend_char(*data);
		data++;
	}
}
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <LCD_clearscreen>:
void LCD_clearscreen()
{
	LCD_vSend_cmd(CLR_SCREEN);
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     d84:	8f e1       	ldi	r24, 0x1F	; 31
     d86:	9e e4       	ldi	r25, 0x4E	; 78
     d88:	01 97       	sbiw	r24, 0x01	; 1
     d8a:	f1 f7       	brne	.-4      	; 0xd88 <LCD_clearscreen+0xa>
     d8c:	00 c0       	rjmp	.+0      	; 0xd8e <LCD_clearscreen+0x10>
     d8e:	00 00       	nop
	_delay_ms(10);
}
     d90:	08 95       	ret

00000d92 <LCD_movecursor>:
void LCD_movecursor(char row,char coloumn)
{
	char data ;
	if(row>2||row<1||coloumn>16||coloumn<1)
     d92:	28 2f       	mov	r18, r24
     d94:	21 50       	subi	r18, 0x01	; 1
     d96:	22 30       	cpi	r18, 0x02	; 2
     d98:	70 f4       	brcc	.+28     	; 0xdb6 <LCD_movecursor+0x24>
     d9a:	61 31       	cpi	r22, 0x11	; 17
     d9c:	70 f4       	brcc	.+28     	; 0xdba <LCD_movecursor+0x28>
     d9e:	66 23       	and	r22, r22
     da0:	71 f0       	breq	.+28     	; 0xdbe <LCD_movecursor+0x2c>
	{
		data=0x80;
	}
	else if(row==1)
     da2:	81 30       	cpi	r24, 0x01	; 1
     da4:	19 f4       	brne	.+6      	; 0xdac <LCD_movecursor+0x1a>
	{
		data=0x80+coloumn-1 ;
     da6:	96 2f       	mov	r25, r22
     da8:	91 58       	subi	r25, 0x81	; 129
     daa:	0a c0       	rjmp	.+20     	; 0xdc0 <LCD_movecursor+0x2e>
	}
	else if (row==2)
     dac:	82 30       	cpi	r24, 0x02	; 2
     dae:	41 f4       	brne	.+16     	; 0xdc0 <LCD_movecursor+0x2e>
	{
		data=0xc0+coloumn-1;
     db0:	96 2f       	mov	r25, r22
     db2:	91 54       	subi	r25, 0x41	; 65
     db4:	05 c0       	rjmp	.+10     	; 0xdc0 <LCD_movecursor+0x2e>
void LCD_movecursor(char row,char coloumn)
{
	char data ;
	if(row>2||row<1||coloumn>16||coloumn<1)
	{
		data=0x80;
     db6:	90 e8       	ldi	r25, 0x80	; 128
     db8:	03 c0       	rjmp	.+6      	; 0xdc0 <LCD_movecursor+0x2e>
     dba:	90 e8       	ldi	r25, 0x80	; 128
     dbc:	01 c0       	rjmp	.+2      	; 0xdc0 <LCD_movecursor+0x2e>
     dbe:	90 e8       	ldi	r25, 0x80	; 128
	}
	else if (row==2)
	{
		data=0xc0+coloumn-1;
	}
	LCD_vSend_cmd(data);
     dc0:	89 2f       	mov	r24, r25
     dc2:	0e 94 22 06 	call	0xc44	; 0xc44 <LCD_vSend_cmd>
     dc6:	8f ec       	ldi	r24, 0xCF	; 207
     dc8:	97 e0       	ldi	r25, 0x07	; 7
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	f1 f7       	brne	.-4      	; 0xdca <LCD_movecursor+0x38>
     dce:	00 c0       	rjmp	.+0      	; 0xdd0 <LCD_movecursor+0x3e>
     dd0:	00 00       	nop
	_delay_ms(1);
}
     dd2:	08 95       	ret

00000dd4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     dd4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dd6:	03 96       	adiw	r24, 0x03	; 3
     dd8:	92 83       	std	Z+2, r25	; 0x02
     dda:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ddc:	2f ef       	ldi	r18, 0xFF	; 255
     dde:	3f ef       	ldi	r19, 0xFF	; 255
     de0:	34 83       	std	Z+4, r19	; 0x04
     de2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     de4:	96 83       	std	Z+6, r25	; 0x06
     de6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     de8:	90 87       	std	Z+8, r25	; 0x08
     dea:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     dec:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     dee:	08 95       	ret

00000df0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     df0:	fc 01       	movw	r30, r24
     df2:	11 86       	std	Z+9, r1	; 0x09
     df4:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     df6:	08 95       	ret

00000df8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     df8:	cf 93       	push	r28
     dfa:	df 93       	push	r29
     dfc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     dfe:	dc 01       	movw	r26, r24
     e00:	11 96       	adiw	r26, 0x01	; 1
     e02:	cd 91       	ld	r28, X+
     e04:	dc 91       	ld	r29, X
     e06:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e08:	d3 83       	std	Z+3, r29	; 0x03
     e0a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e0c:	2c 81       	ldd	r18, Y+4	; 0x04
     e0e:	3d 81       	ldd	r19, Y+5	; 0x05
     e10:	35 83       	std	Z+5, r19	; 0x05
     e12:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e14:	ac 81       	ldd	r26, Y+4	; 0x04
     e16:	bd 81       	ldd	r27, Y+5	; 0x05
     e18:	13 96       	adiw	r26, 0x03	; 3
     e1a:	7c 93       	st	X, r23
     e1c:	6e 93       	st	-X, r22
     e1e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     e20:	7d 83       	std	Y+5, r23	; 0x05
     e22:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e24:	91 87       	std	Z+9, r25	; 0x09
     e26:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e28:	fc 01       	movw	r30, r24
     e2a:	20 81       	ld	r18, Z
     e2c:	2f 5f       	subi	r18, 0xFF	; 255
     e2e:	20 83       	st	Z, r18
}
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	08 95       	ret

00000e36 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
     e3a:	ac 01       	movw	r20, r24
     e3c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e3e:	28 81       	ld	r18, Y
     e40:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e42:	8f ef       	ldi	r24, 0xFF	; 255
     e44:	2f 3f       	cpi	r18, 0xFF	; 255
     e46:	38 07       	cpc	r19, r24
     e48:	21 f4       	brne	.+8      	; 0xe52 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e4a:	fa 01       	movw	r30, r20
     e4c:	a7 81       	ldd	r26, Z+7	; 0x07
     e4e:	b0 85       	ldd	r27, Z+8	; 0x08
     e50:	0d c0       	rjmp	.+26     	; 0xe6c <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e52:	da 01       	movw	r26, r20
     e54:	13 96       	adiw	r26, 0x03	; 3
     e56:	01 c0       	rjmp	.+2      	; 0xe5a <vListInsert+0x24>
     e58:	df 01       	movw	r26, r30
     e5a:	12 96       	adiw	r26, 0x02	; 2
     e5c:	ed 91       	ld	r30, X+
     e5e:	fc 91       	ld	r31, X
     e60:	13 97       	sbiw	r26, 0x03	; 3
     e62:	80 81       	ld	r24, Z
     e64:	91 81       	ldd	r25, Z+1	; 0x01
     e66:	28 17       	cp	r18, r24
     e68:	39 07       	cpc	r19, r25
     e6a:	b0 f7       	brcc	.-20     	; 0xe58 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e6c:	12 96       	adiw	r26, 0x02	; 2
     e6e:	ed 91       	ld	r30, X+
     e70:	fc 91       	ld	r31, X
     e72:	13 97       	sbiw	r26, 0x03	; 3
     e74:	fb 83       	std	Y+3, r31	; 0x03
     e76:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     e78:	d5 83       	std	Z+5, r29	; 0x05
     e7a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     e7c:	bd 83       	std	Y+5, r27	; 0x05
     e7e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     e80:	13 96       	adiw	r26, 0x03	; 3
     e82:	dc 93       	st	X, r29
     e84:	ce 93       	st	-X, r28
     e86:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e88:	59 87       	std	Y+9, r21	; 0x09
     e8a:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     e8c:	fa 01       	movw	r30, r20
     e8e:	80 81       	ld	r24, Z
     e90:	8f 5f       	subi	r24, 0xFF	; 255
     e92:	80 83       	st	Z, r24
}
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	08 95       	ret

00000e9a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     e9a:	cf 93       	push	r28
     e9c:	df 93       	push	r29
     e9e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     ea0:	c0 85       	ldd	r28, Z+8	; 0x08
     ea2:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ea4:	a2 81       	ldd	r26, Z+2	; 0x02
     ea6:	b3 81       	ldd	r27, Z+3	; 0x03
     ea8:	84 81       	ldd	r24, Z+4	; 0x04
     eaa:	95 81       	ldd	r25, Z+5	; 0x05
     eac:	15 96       	adiw	r26, 0x05	; 5
     eae:	9c 93       	st	X, r25
     eb0:	8e 93       	st	-X, r24
     eb2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     eb4:	a4 81       	ldd	r26, Z+4	; 0x04
     eb6:	b5 81       	ldd	r27, Z+5	; 0x05
     eb8:	82 81       	ldd	r24, Z+2	; 0x02
     eba:	93 81       	ldd	r25, Z+3	; 0x03
     ebc:	13 96       	adiw	r26, 0x03	; 3
     ebe:	9c 93       	st	X, r25
     ec0:	8e 93       	st	-X, r24
     ec2:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ec4:	a9 81       	ldd	r26, Y+1	; 0x01
     ec6:	ba 81       	ldd	r27, Y+2	; 0x02
     ec8:	ae 17       	cp	r26, r30
     eca:	bf 07       	cpc	r27, r31
     ecc:	31 f4       	brne	.+12     	; 0xeda <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ece:	14 96       	adiw	r26, 0x04	; 4
     ed0:	8d 91       	ld	r24, X+
     ed2:	9c 91       	ld	r25, X
     ed4:	15 97       	sbiw	r26, 0x05	; 5
     ed6:	9a 83       	std	Y+2, r25	; 0x02
     ed8:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     eda:	11 86       	std	Z+9, r1	; 0x09
     edc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ede:	88 81       	ld	r24, Y
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	08 95       	ret

00000eea <LCD>:
			vTaskDelay(300);
		}
	}
}
void LCD(void *pv)
{
     eea:	cf 93       	push	r28
     eec:	df 93       	push	r29
     eee:	0f 92       	push	r0
     ef0:	cd b7       	in	r28, 0x3d	; 61
     ef2:	de b7       	in	r29, 0x3e	; 62
	char y;
	while(1)
	{
		xQueueReceive(my_queue,&y,1000);
     ef4:	80 91 14 04 	lds	r24, 0x0414
     ef8:	90 91 15 04 	lds	r25, 0x0415
     efc:	be 01       	movw	r22, r28
     efe:	6f 5f       	subi	r22, 0xFF	; 255
     f00:	7f 4f       	sbci	r23, 0xFF	; 255
     f02:	48 ee       	ldi	r20, 0xE8	; 232
     f04:	53 e0       	ldi	r21, 0x03	; 3
     f06:	20 e0       	ldi	r18, 0x00	; 0
     f08:	0e 94 ba 0b 	call	0x1774	; 0x1774 <xQueueGenericReceive>
		LCD_vSend_char(y);
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <LCD_vSend_char>
     f12:	f0 cf       	rjmp	.-32     	; 0xef4 <LCD+0xa>

00000f14 <keypad>:
	{
		
	}
}
void keypad(void *pv)
{
     f14:	cf 93       	push	r28
     f16:	df 93       	push	r29
     f18:	0f 92       	push	r0
     f1a:	cd b7       	in	r28, 0x3d	; 61
     f1c:	de b7       	in	r29, 0x3e	; 62
	char x;
	while(1)
	{
		x=keypad_u8check_press();
     f1e:	0e 94 b4 05 	call	0xb68	; 0xb68 <keypad_u8check_press>
     f22:	89 83       	std	Y+1, r24	; 0x01
		if(x!=NOTPRESSED)
     f24:	8f 3f       	cpi	r24, 0xFF	; 255
     f26:	d9 f3       	breq	.-10     	; 0xf1e <keypad+0xa>
		{
			xQueueSend(my_queue,&x,1000);
     f28:	80 91 14 04 	lds	r24, 0x0414
     f2c:	90 91 15 04 	lds	r25, 0x0415
     f30:	be 01       	movw	r22, r28
     f32:	6f 5f       	subi	r22, 0xFF	; 255
     f34:	7f 4f       	sbci	r23, 0xFF	; 255
     f36:	48 ee       	ldi	r20, 0xE8	; 232
     f38:	53 e0       	ldi	r21, 0x03	; 3
     f3a:	20 e0       	ldi	r18, 0x00	; 0
     f3c:	0e 94 97 0a 	call	0x152e	; 0x152e <xQueueGenericSend>
			vTaskDelay(300);
     f40:	8c e2       	ldi	r24, 0x2C	; 44
     f42:	91 e0       	ldi	r25, 0x01	; 1
     f44:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskDelay>
     f48:	ea cf       	rjmp	.-44     	; 0xf1e <keypad+0xa>

00000f4a <main>:
void LCD(void *pv);

QueueHandle_t my_queue ;
int main(void)
{
	keypad_vInit();
     f4a:	0e 94 77 05 	call	0xaee	; 0xaee <keypad_vInit>
	LCD_vInit();
     f4e:	0e 94 34 06 	call	0xc68	; 0xc68 <LCD_vInit>
	xTaskCreate(keypad,"M",100,NULL,2,NULL);
     f52:	8a e8       	ldi	r24, 0x8A	; 138
     f54:	97 e0       	ldi	r25, 0x07	; 7
     f56:	62 e7       	ldi	r22, 0x72	; 114
     f58:	70 e0       	ldi	r23, 0x00	; 0
     f5a:	44 e6       	ldi	r20, 0x64	; 100
     f5c:	50 e0       	ldi	r21, 0x00	; 0
     f5e:	20 e0       	ldi	r18, 0x00	; 0
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	02 e0       	ldi	r16, 0x02	; 2
     f64:	ee 24       	eor	r14, r14
     f66:	ff 24       	eor	r15, r15
     f68:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <xTaskCreate>
	xTaskCreate(LCD,"N",100,NULL,1,NULL);
     f6c:	85 e7       	ldi	r24, 0x75	; 117
     f6e:	97 e0       	ldi	r25, 0x07	; 7
     f70:	64 e7       	ldi	r22, 0x74	; 116
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	44 e6       	ldi	r20, 0x64	; 100
     f76:	50 e0       	ldi	r21, 0x00	; 0
     f78:	20 e0       	ldi	r18, 0x00	; 0
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	01 e0       	ldi	r16, 0x01	; 1
     f7e:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <xTaskCreate>
	my_queue=xQueueCreate(5,sizeof(char));
     f82:	85 e0       	ldi	r24, 0x05	; 5
     f84:	61 e0       	ldi	r22, 0x01	; 1
     f86:	40 e0       	ldi	r20, 0x00	; 0
     f88:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xQueueGenericCreate>
     f8c:	90 93 15 04 	sts	0x0415, r25
     f90:	80 93 14 04 	sts	0x0414, r24
	vTaskStartScheduler();
     f94:	0e 94 ac 10 	call	0x2158	; 0x2158 <vTaskStartScheduler>
     f98:	ff cf       	rjmp	.-2      	; 0xf98 <main+0x4e>

00000f9a <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     f9a:	21 e1       	ldi	r18, 0x11	; 17
     f9c:	fc 01       	movw	r30, r24
     f9e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     fa0:	31 97       	sbiw	r30, 0x01	; 1
     fa2:	32 e2       	ldi	r19, 0x22	; 34
     fa4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     fa6:	fc 01       	movw	r30, r24
     fa8:	32 97       	sbiw	r30, 0x02	; 2
     faa:	a3 e3       	ldi	r26, 0x33	; 51
     fac:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fae:	fc 01       	movw	r30, r24
     fb0:	33 97       	sbiw	r30, 0x03	; 3
     fb2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fb4:	fc 01       	movw	r30, r24
     fb6:	34 97       	sbiw	r30, 0x04	; 4
     fb8:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     fba:	fc 01       	movw	r30, r24
     fbc:	35 97       	sbiw	r30, 0x05	; 5
     fbe:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     fc0:	fc 01       	movw	r30, r24
     fc2:	36 97       	sbiw	r30, 0x06	; 6
     fc4:	60 e8       	ldi	r22, 0x80	; 128
     fc6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     fc8:	fc 01       	movw	r30, r24
     fca:	37 97       	sbiw	r30, 0x07	; 7
     fcc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     fce:	fc 01       	movw	r30, r24
     fd0:	38 97       	sbiw	r30, 0x08	; 8
     fd2:	62 e0       	ldi	r22, 0x02	; 2
     fd4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     fd6:	fc 01       	movw	r30, r24
     fd8:	39 97       	sbiw	r30, 0x09	; 9
     fda:	63 e0       	ldi	r22, 0x03	; 3
     fdc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     fde:	fc 01       	movw	r30, r24
     fe0:	3a 97       	sbiw	r30, 0x0a	; 10
     fe2:	64 e0       	ldi	r22, 0x04	; 4
     fe4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     fe6:	fc 01       	movw	r30, r24
     fe8:	3b 97       	sbiw	r30, 0x0b	; 11
     fea:	65 e0       	ldi	r22, 0x05	; 5
     fec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     fee:	fc 01       	movw	r30, r24
     ff0:	3c 97       	sbiw	r30, 0x0c	; 12
     ff2:	66 e0       	ldi	r22, 0x06	; 6
     ff4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     ff6:	fc 01       	movw	r30, r24
     ff8:	3d 97       	sbiw	r30, 0x0d	; 13
     ffa:	67 e0       	ldi	r22, 0x07	; 7
     ffc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     ffe:	fc 01       	movw	r30, r24
    1000:	3e 97       	sbiw	r30, 0x0e	; 14
    1002:	68 e0       	ldi	r22, 0x08	; 8
    1004:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1006:	fc 01       	movw	r30, r24
    1008:	3f 97       	sbiw	r30, 0x0f	; 15
    100a:	69 e0       	ldi	r22, 0x09	; 9
    100c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    100e:	fc 01       	movw	r30, r24
    1010:	70 97       	sbiw	r30, 0x10	; 16
    1012:	60 e1       	ldi	r22, 0x10	; 16
    1014:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1016:	fc 01       	movw	r30, r24
    1018:	71 97       	sbiw	r30, 0x11	; 17
    101a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    101c:	fc 01       	movw	r30, r24
    101e:	72 97       	sbiw	r30, 0x12	; 18
    1020:	22 e1       	ldi	r18, 0x12	; 18
    1022:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1024:	fc 01       	movw	r30, r24
    1026:	73 97       	sbiw	r30, 0x13	; 19
    1028:	23 e1       	ldi	r18, 0x13	; 19
    102a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    102c:	fc 01       	movw	r30, r24
    102e:	74 97       	sbiw	r30, 0x14	; 20
    1030:	24 e1       	ldi	r18, 0x14	; 20
    1032:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1034:	fc 01       	movw	r30, r24
    1036:	75 97       	sbiw	r30, 0x15	; 21
    1038:	25 e1       	ldi	r18, 0x15	; 21
    103a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    103c:	fc 01       	movw	r30, r24
    103e:	76 97       	sbiw	r30, 0x16	; 22
    1040:	26 e1       	ldi	r18, 0x16	; 22
    1042:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1044:	fc 01       	movw	r30, r24
    1046:	77 97       	sbiw	r30, 0x17	; 23
    1048:	27 e1       	ldi	r18, 0x17	; 23
    104a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    104c:	fc 01       	movw	r30, r24
    104e:	78 97       	sbiw	r30, 0x18	; 24
    1050:	28 e1       	ldi	r18, 0x18	; 24
    1052:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1054:	fc 01       	movw	r30, r24
    1056:	79 97       	sbiw	r30, 0x19	; 25
    1058:	29 e1       	ldi	r18, 0x19	; 25
    105a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    105c:	fc 01       	movw	r30, r24
    105e:	7a 97       	sbiw	r30, 0x1a	; 26
    1060:	20 e2       	ldi	r18, 0x20	; 32
    1062:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1064:	fc 01       	movw	r30, r24
    1066:	7b 97       	sbiw	r30, 0x1b	; 27
    1068:	21 e2       	ldi	r18, 0x21	; 33
    106a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    106c:	fc 01       	movw	r30, r24
    106e:	7c 97       	sbiw	r30, 0x1c	; 28
    1070:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1072:	fc 01       	movw	r30, r24
    1074:	7d 97       	sbiw	r30, 0x1d	; 29
    1076:	23 e2       	ldi	r18, 0x23	; 35
    1078:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    107a:	fc 01       	movw	r30, r24
    107c:	7e 97       	sbiw	r30, 0x1e	; 30
    107e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1080:	fc 01       	movw	r30, r24
    1082:	7f 97       	sbiw	r30, 0x1f	; 31
    1084:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1086:	fc 01       	movw	r30, r24
    1088:	b0 97       	sbiw	r30, 0x20	; 32
    108a:	26 e2       	ldi	r18, 0x26	; 38
    108c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    108e:	fc 01       	movw	r30, r24
    1090:	b1 97       	sbiw	r30, 0x21	; 33
    1092:	27 e2       	ldi	r18, 0x27	; 39
    1094:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1096:	fc 01       	movw	r30, r24
    1098:	b2 97       	sbiw	r30, 0x22	; 34
    109a:	28 e2       	ldi	r18, 0x28	; 40
    109c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    109e:	fc 01       	movw	r30, r24
    10a0:	b3 97       	sbiw	r30, 0x23	; 35
    10a2:	29 e2       	ldi	r18, 0x29	; 41
    10a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    10a6:	fc 01       	movw	r30, r24
    10a8:	b4 97       	sbiw	r30, 0x24	; 36
    10aa:	20 e3       	ldi	r18, 0x30	; 48
    10ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    10ae:	fc 01       	movw	r30, r24
    10b0:	b5 97       	sbiw	r30, 0x25	; 37
    10b2:	21 e3       	ldi	r18, 0x31	; 49
    10b4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    10b6:	86 97       	sbiw	r24, 0x26	; 38
}
    10b8:	08 95       	ret

000010ba <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    10ba:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    10bc:	8c e7       	ldi	r24, 0x7C	; 124
    10be:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    10c0:	8b e0       	ldi	r24, 0x0B	; 11
    10c2:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    10c4:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    10c6:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    10c8:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    10ca:	a0 91 a5 03 	lds	r26, 0x03A5
    10ce:	b0 91 a6 03 	lds	r27, 0x03A6
    10d2:	cd 91       	ld	r28, X+
    10d4:	cd bf       	out	0x3d, r28	; 61
    10d6:	dd 91       	ld	r29, X+
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	ff 91       	pop	r31
    10dc:	ef 91       	pop	r30
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	bf 91       	pop	r27
    10e4:	af 91       	pop	r26
    10e6:	9f 91       	pop	r25
    10e8:	8f 91       	pop	r24
    10ea:	7f 91       	pop	r23
    10ec:	6f 91       	pop	r22
    10ee:	5f 91       	pop	r21
    10f0:	4f 91       	pop	r20
    10f2:	3f 91       	pop	r19
    10f4:	2f 91       	pop	r18
    10f6:	1f 91       	pop	r17
    10f8:	0f 91       	pop	r16
    10fa:	ff 90       	pop	r15
    10fc:	ef 90       	pop	r14
    10fe:	df 90       	pop	r13
    1100:	cf 90       	pop	r12
    1102:	bf 90       	pop	r11
    1104:	af 90       	pop	r10
    1106:	9f 90       	pop	r9
    1108:	8f 90       	pop	r8
    110a:	7f 90       	pop	r7
    110c:	6f 90       	pop	r6
    110e:	5f 90       	pop	r5
    1110:	4f 90       	pop	r4
    1112:	3f 90       	pop	r3
    1114:	2f 90       	pop	r2
    1116:	1f 90       	pop	r1
    1118:	0f 90       	pop	r0
    111a:	0f be       	out	0x3f, r0	; 63
    111c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    111e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	08 95       	ret

00001124 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1124:	08 95       	ret

00001126 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1126:	0f 92       	push	r0
    1128:	0f b6       	in	r0, 0x3f	; 63
    112a:	f8 94       	cli
    112c:	0f 92       	push	r0
    112e:	1f 92       	push	r1
    1130:	11 24       	eor	r1, r1
    1132:	2f 92       	push	r2
    1134:	3f 92       	push	r3
    1136:	4f 92       	push	r4
    1138:	5f 92       	push	r5
    113a:	6f 92       	push	r6
    113c:	7f 92       	push	r7
    113e:	8f 92       	push	r8
    1140:	9f 92       	push	r9
    1142:	af 92       	push	r10
    1144:	bf 92       	push	r11
    1146:	cf 92       	push	r12
    1148:	df 92       	push	r13
    114a:	ef 92       	push	r14
    114c:	ff 92       	push	r15
    114e:	0f 93       	push	r16
    1150:	1f 93       	push	r17
    1152:	2f 93       	push	r18
    1154:	3f 93       	push	r19
    1156:	4f 93       	push	r20
    1158:	5f 93       	push	r21
    115a:	6f 93       	push	r22
    115c:	7f 93       	push	r23
    115e:	8f 93       	push	r24
    1160:	9f 93       	push	r25
    1162:	af 93       	push	r26
    1164:	bf 93       	push	r27
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	ef 93       	push	r30
    116c:	ff 93       	push	r31
    116e:	a0 91 a5 03 	lds	r26, 0x03A5
    1172:	b0 91 a6 03 	lds	r27, 0x03A6
    1176:	0d b6       	in	r0, 0x3d	; 61
    1178:	0d 92       	st	X+, r0
    117a:	0e b6       	in	r0, 0x3e	; 62
    117c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    117e:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1182:	a0 91 a5 03 	lds	r26, 0x03A5
    1186:	b0 91 a6 03 	lds	r27, 0x03A6
    118a:	cd 91       	ld	r28, X+
    118c:	cd bf       	out	0x3d, r28	; 61
    118e:	dd 91       	ld	r29, X+
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	ff 91       	pop	r31
    1194:	ef 91       	pop	r30
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	bf 91       	pop	r27
    119c:	af 91       	pop	r26
    119e:	9f 91       	pop	r25
    11a0:	8f 91       	pop	r24
    11a2:	7f 91       	pop	r23
    11a4:	6f 91       	pop	r22
    11a6:	5f 91       	pop	r21
    11a8:	4f 91       	pop	r20
    11aa:	3f 91       	pop	r19
    11ac:	2f 91       	pop	r18
    11ae:	1f 91       	pop	r17
    11b0:	0f 91       	pop	r16
    11b2:	ff 90       	pop	r15
    11b4:	ef 90       	pop	r14
    11b6:	df 90       	pop	r13
    11b8:	cf 90       	pop	r12
    11ba:	bf 90       	pop	r11
    11bc:	af 90       	pop	r10
    11be:	9f 90       	pop	r9
    11c0:	8f 90       	pop	r8
    11c2:	7f 90       	pop	r7
    11c4:	6f 90       	pop	r6
    11c6:	5f 90       	pop	r5
    11c8:	4f 90       	pop	r4
    11ca:	3f 90       	pop	r3
    11cc:	2f 90       	pop	r2
    11ce:	1f 90       	pop	r1
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11d6:	08 95       	ret

000011d8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    11d8:	0f 92       	push	r0
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	0f 92       	push	r0
    11e0:	1f 92       	push	r1
    11e2:	11 24       	eor	r1, r1
    11e4:	2f 92       	push	r2
    11e6:	3f 92       	push	r3
    11e8:	4f 92       	push	r4
    11ea:	5f 92       	push	r5
    11ec:	6f 92       	push	r6
    11ee:	7f 92       	push	r7
    11f0:	8f 92       	push	r8
    11f2:	9f 92       	push	r9
    11f4:	af 92       	push	r10
    11f6:	bf 92       	push	r11
    11f8:	cf 92       	push	r12
    11fa:	df 92       	push	r13
    11fc:	ef 92       	push	r14
    11fe:	ff 92       	push	r15
    1200:	0f 93       	push	r16
    1202:	1f 93       	push	r17
    1204:	2f 93       	push	r18
    1206:	3f 93       	push	r19
    1208:	4f 93       	push	r20
    120a:	5f 93       	push	r21
    120c:	6f 93       	push	r22
    120e:	7f 93       	push	r23
    1210:	8f 93       	push	r24
    1212:	9f 93       	push	r25
    1214:	af 93       	push	r26
    1216:	bf 93       	push	r27
    1218:	cf 93       	push	r28
    121a:	df 93       	push	r29
    121c:	ef 93       	push	r30
    121e:	ff 93       	push	r31
    1220:	a0 91 a5 03 	lds	r26, 0x03A5
    1224:	b0 91 a6 03 	lds	r27, 0x03A6
    1228:	0d b6       	in	r0, 0x3d	; 61
    122a:	0d 92       	st	X+, r0
    122c:	0e b6       	in	r0, 0x3e	; 62
    122e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1230:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <xTaskIncrementTick>
    1234:	88 23       	and	r24, r24
    1236:	11 f0       	breq	.+4      	; 0x123c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1238:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    123c:	a0 91 a5 03 	lds	r26, 0x03A5
    1240:	b0 91 a6 03 	lds	r27, 0x03A6
    1244:	cd 91       	ld	r28, X+
    1246:	cd bf       	out	0x3d, r28	; 61
    1248:	dd 91       	ld	r29, X+
    124a:	de bf       	out	0x3e, r29	; 62
    124c:	ff 91       	pop	r31
    124e:	ef 91       	pop	r30
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	bf 91       	pop	r27
    1256:	af 91       	pop	r26
    1258:	9f 91       	pop	r25
    125a:	8f 91       	pop	r24
    125c:	7f 91       	pop	r23
    125e:	6f 91       	pop	r22
    1260:	5f 91       	pop	r21
    1262:	4f 91       	pop	r20
    1264:	3f 91       	pop	r19
    1266:	2f 91       	pop	r18
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	ff 90       	pop	r15
    126e:	ef 90       	pop	r14
    1270:	df 90       	pop	r13
    1272:	cf 90       	pop	r12
    1274:	bf 90       	pop	r11
    1276:	af 90       	pop	r10
    1278:	9f 90       	pop	r9
    127a:	8f 90       	pop	r8
    127c:	7f 90       	pop	r7
    127e:	6f 90       	pop	r6
    1280:	5f 90       	pop	r5
    1282:	4f 90       	pop	r4
    1284:	3f 90       	pop	r3
    1286:	2f 90       	pop	r2
    1288:	1f 90       	pop	r1
    128a:	0f 90       	pop	r0
    128c:	0f be       	out	0x3f, r0	; 63
    128e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1290:	08 95       	ret

00001292 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1292:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1296:	18 95       	reti

00001298 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    129e:	fc 01       	movw	r30, r24
    12a0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	91 11       	cpse	r25, r1
    12aa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    12ac:	08 95       	ret

000012ae <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    12ae:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    12b0:	44 8d       	ldd	r20, Z+28	; 0x1c
    12b2:	44 23       	and	r20, r20
    12b4:	c1 f0       	breq	.+48     	; 0x12e6 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    12b6:	26 81       	ldd	r18, Z+6	; 0x06
    12b8:	37 81       	ldd	r19, Z+7	; 0x07
    12ba:	24 0f       	add	r18, r20
    12bc:	31 1d       	adc	r19, r1
    12be:	37 83       	std	Z+7, r19	; 0x07
    12c0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    12c2:	a2 81       	ldd	r26, Z+2	; 0x02
    12c4:	b3 81       	ldd	r27, Z+3	; 0x03
    12c6:	2a 17       	cp	r18, r26
    12c8:	3b 07       	cpc	r19, r27
    12ca:	20 f0       	brcs	.+8      	; 0x12d4 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    12cc:	20 81       	ld	r18, Z
    12ce:	31 81       	ldd	r19, Z+1	; 0x01
    12d0:	37 83       	std	Z+7, r19	; 0x07
    12d2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    12d4:	36 81       	ldd	r19, Z+6	; 0x06
    12d6:	27 81       	ldd	r18, Z+7	; 0x07
    12d8:	86 2f       	mov	r24, r22
    12da:	97 2f       	mov	r25, r23
    12dc:	63 2f       	mov	r22, r19
    12de:	72 2f       	mov	r23, r18
    12e0:	50 e0       	ldi	r21, 0x00	; 0
    12e2:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
    12e6:	08 95       	ret

000012e8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    12e8:	ef 92       	push	r14
    12ea:	ff 92       	push	r15
    12ec:	0f 93       	push	r16
    12ee:	1f 93       	push	r17
    12f0:	cf 93       	push	r28
    12f2:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12fa:	fc 01       	movw	r30, r24
    12fc:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12fe:	1c 16       	cp	r1, r28
    1300:	cc f4       	brge	.+50     	; 0x1334 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1302:	81 89       	ldd	r24, Z+17	; 0x11
    1304:	88 23       	and	r24, r24
    1306:	31 f4       	brne	.+12     	; 0x1314 <prvUnlockQueue+0x2c>
    1308:	15 c0       	rjmp	.+42     	; 0x1334 <prvUnlockQueue+0x4c>
    130a:	f8 01       	movw	r30, r16
    130c:	81 89       	ldd	r24, Z+17	; 0x11
    130e:	88 23       	and	r24, r24
    1310:	41 f4       	brne	.+16     	; 0x1322 <prvUnlockQueue+0x3a>
    1312:	10 c0       	rjmp	.+32     	; 0x1334 <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1314:	0f 2e       	mov	r0, r31
    1316:	f1 e1       	ldi	r31, 0x11	; 17
    1318:	ef 2e       	mov	r14, r31
    131a:	ff 24       	eor	r15, r15
    131c:	f0 2d       	mov	r31, r0
    131e:	e0 0e       	add	r14, r16
    1320:	f1 1e       	adc	r15, r17
    1322:	c7 01       	movw	r24, r14
    1324:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    1328:	88 23       	and	r24, r24
    132a:	11 f0       	breq	.+4      	; 0x1330 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    132c:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1330:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1332:	59 f7       	brne	.-42     	; 0x130a <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1334:	8f ef       	ldi	r24, 0xFF	; 255
    1336:	f8 01       	movw	r30, r16
    1338:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    133a:	0f 90       	pop	r0
    133c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    133e:	0f b6       	in	r0, 0x3f	; 63
    1340:	f8 94       	cli
    1342:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1344:	f8 01       	movw	r30, r16
    1346:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1348:	1c 16       	cp	r1, r28
    134a:	c4 f4       	brge	.+48     	; 0x137c <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    134c:	80 85       	ldd	r24, Z+8	; 0x08
    134e:	88 23       	and	r24, r24
    1350:	31 f4       	brne	.+12     	; 0x135e <prvUnlockQueue+0x76>
    1352:	14 c0       	rjmp	.+40     	; 0x137c <prvUnlockQueue+0x94>
    1354:	f8 01       	movw	r30, r16
    1356:	80 85       	ldd	r24, Z+8	; 0x08
    1358:	88 23       	and	r24, r24
    135a:	39 f4       	brne	.+14     	; 0x136a <prvUnlockQueue+0x82>
    135c:	0f c0       	rjmp	.+30     	; 0x137c <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    135e:	ee 24       	eor	r14, r14
    1360:	ff 24       	eor	r15, r15
    1362:	68 94       	set
    1364:	e3 f8       	bld	r14, 3
    1366:	e0 0e       	add	r14, r16
    1368:	f1 1e       	adc	r15, r17
    136a:	c7 01       	movw	r24, r14
    136c:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    1370:	88 23       	and	r24, r24
    1372:	11 f0       	breq	.+4      	; 0x1378 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    1374:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1378:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    137a:	61 f7       	brne	.-40     	; 0x1354 <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    137c:	8f ef       	ldi	r24, 0xFF	; 255
    137e:	f8 01       	movw	r30, r16
    1380:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1382:	0f 90       	pop	r0
    1384:	0f be       	out	0x3f, r0	; 63
}
    1386:	cf 91       	pop	r28
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	08 95       	ret

00001392 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1392:	0f 93       	push	r16
    1394:	1f 93       	push	r17
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	ec 01       	movw	r28, r24
    139c:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    139e:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    13a0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13a2:	44 23       	and	r20, r20
    13a4:	61 f4       	brne	.+24     	; 0x13be <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13a6:	88 81       	ld	r24, Y
    13a8:	99 81       	ldd	r25, Y+1	; 0x01
    13aa:	00 97       	sbiw	r24, 0x00	; 0
    13ac:	09 f0       	breq	.+2      	; 0x13b0 <prvCopyDataToQueue+0x1e>
    13ae:	42 c0       	rjmp	.+132    	; 0x1434 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    13b0:	8a 81       	ldd	r24, Y+2	; 0x02
    13b2:	9b 81       	ldd	r25, Y+3	; 0x03
    13b4:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    13b8:	1b 82       	std	Y+3, r1	; 0x03
    13ba:	1a 82       	std	Y+2, r1	; 0x02
    13bc:	42 c0       	rjmp	.+132    	; 0x1442 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    13be:	11 23       	and	r17, r17
    13c0:	b9 f4       	brne	.+46     	; 0x13f0 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    13c2:	8c 81       	ldd	r24, Y+4	; 0x04
    13c4:	9d 81       	ldd	r25, Y+5	; 0x05
    13c6:	50 e0       	ldi	r21, 0x00	; 0
    13c8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13cc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13ce:	8c 81       	ldd	r24, Y+4	; 0x04
    13d0:	9d 81       	ldd	r25, Y+5	; 0x05
    13d2:	82 0f       	add	r24, r18
    13d4:	91 1d       	adc	r25, r1
    13d6:	9d 83       	std	Y+5, r25	; 0x05
    13d8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    13da:	2a 81       	ldd	r18, Y+2	; 0x02
    13dc:	3b 81       	ldd	r19, Y+3	; 0x03
    13de:	82 17       	cp	r24, r18
    13e0:	93 07       	cpc	r25, r19
    13e2:	50 f1       	brcs	.+84     	; 0x1438 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    13e4:	88 81       	ld	r24, Y
    13e6:	99 81       	ldd	r25, Y+1	; 0x01
    13e8:	9d 83       	std	Y+5, r25	; 0x05
    13ea:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    13ec:	80 e0       	ldi	r24, 0x00	; 0
    13ee:	29 c0       	rjmp	.+82     	; 0x1442 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13f0:	8e 81       	ldd	r24, Y+6	; 0x06
    13f2:	9f 81       	ldd	r25, Y+7	; 0x07
    13f4:	50 e0       	ldi	r21, 0x00	; 0
    13f6:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    13fa:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13fc:	50 e0       	ldi	r21, 0x00	; 0
    13fe:	50 95       	com	r21
    1400:	41 95       	neg	r20
    1402:	5f 4f       	sbci	r21, 0xFF	; 255
    1404:	8e 81       	ldd	r24, Y+6	; 0x06
    1406:	9f 81       	ldd	r25, Y+7	; 0x07
    1408:	84 0f       	add	r24, r20
    140a:	95 1f       	adc	r25, r21
    140c:	9f 83       	std	Y+7, r25	; 0x07
    140e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1410:	28 81       	ld	r18, Y
    1412:	39 81       	ldd	r19, Y+1	; 0x01
    1414:	82 17       	cp	r24, r18
    1416:	93 07       	cpc	r25, r19
    1418:	30 f4       	brcc	.+12     	; 0x1426 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    141a:	8a 81       	ldd	r24, Y+2	; 0x02
    141c:	9b 81       	ldd	r25, Y+3	; 0x03
    141e:	84 0f       	add	r24, r20
    1420:	95 1f       	adc	r25, r21
    1422:	9f 83       	std	Y+7, r25	; 0x07
    1424:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1426:	12 30       	cpi	r17, 0x02	; 2
    1428:	49 f4       	brne	.+18     	; 0x143c <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    142a:	00 23       	and	r16, r16
    142c:	49 f0       	breq	.+18     	; 0x1440 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    142e:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	07 c0       	rjmp	.+14     	; 0x1442 <prvCopyDataToQueue+0xb0>
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	05 c0       	rjmp	.+10     	; 0x1442 <prvCopyDataToQueue+0xb0>
    1438:	80 e0       	ldi	r24, 0x00	; 0
    143a:	03 c0       	rjmp	.+6      	; 0x1442 <prvCopyDataToQueue+0xb0>
    143c:	80 e0       	ldi	r24, 0x00	; 0
    143e:	01 c0       	rjmp	.+2      	; 0x1442 <prvCopyDataToQueue+0xb0>
    1440:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1442:	0f 5f       	subi	r16, 0xFF	; 255
    1444:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    1446:	df 91       	pop	r29
    1448:	cf 91       	pop	r28
    144a:	1f 91       	pop	r17
    144c:	0f 91       	pop	r16
    144e:	08 95       	ret

00001450 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1450:	cf 93       	push	r28
    1452:	df 93       	push	r29
    1454:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1456:	0f b6       	in	r0, 0x3f	; 63
    1458:	f8 94       	cli
    145a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    145c:	48 81       	ld	r20, Y
    145e:	59 81       	ldd	r21, Y+1	; 0x01
    1460:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1462:	30 e0       	ldi	r19, 0x00	; 0
    1464:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	2e 9f       	mul	r18, r30
    146a:	c0 01       	movw	r24, r0
    146c:	2f 9f       	mul	r18, r31
    146e:	90 0d       	add	r25, r0
    1470:	3e 9f       	mul	r19, r30
    1472:	90 0d       	add	r25, r0
    1474:	11 24       	eor	r1, r1
    1476:	84 0f       	add	r24, r20
    1478:	95 1f       	adc	r25, r21
    147a:	9b 83       	std	Y+3, r25	; 0x03
    147c:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    147e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1480:	5d 83       	std	Y+5, r21	; 0x05
    1482:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1484:	c9 01       	movw	r24, r18
    1486:	01 97       	sbiw	r24, 0x01	; 1
    1488:	e8 9f       	mul	r30, r24
    148a:	90 01       	movw	r18, r0
    148c:	e9 9f       	mul	r30, r25
    148e:	30 0d       	add	r19, r0
    1490:	f8 9f       	mul	r31, r24
    1492:	30 0d       	add	r19, r0
    1494:	11 24       	eor	r1, r1
    1496:	24 0f       	add	r18, r20
    1498:	35 1f       	adc	r19, r21
    149a:	3f 83       	std	Y+7, r19	; 0x07
    149c:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    149e:	8f ef       	ldi	r24, 0xFF	; 255
    14a0:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    14a2:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    14a4:	66 23       	and	r22, r22
    14a6:	61 f4       	brne	.+24     	; 0x14c0 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14a8:	88 85       	ldd	r24, Y+8	; 0x08
    14aa:	88 23       	and	r24, r24
    14ac:	89 f0       	breq	.+34     	; 0x14d0 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14ae:	ce 01       	movw	r24, r28
    14b0:	08 96       	adiw	r24, 0x08	; 8
    14b2:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    14b6:	88 23       	and	r24, r24
    14b8:	59 f0       	breq	.+22     	; 0x14d0 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    14ba:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    14be:	08 c0       	rjmp	.+16     	; 0x14d0 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    14c0:	ce 01       	movw	r24, r28
    14c2:	08 96       	adiw	r24, 0x08	; 8
    14c4:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    14c8:	ce 01       	movw	r24, r28
    14ca:	41 96       	adiw	r24, 0x11	; 17
    14cc:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    14d0:	0f 90       	pop	r0
    14d2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	df 91       	pop	r29
    14d8:	cf 91       	pop	r28
    14da:	08 95       	ret

000014dc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	08 2f       	mov	r16, r24
    14e6:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    14e8:	66 23       	and	r22, r22
    14ea:	21 f0       	breq	.+8      	; 0x14f4 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14ec:	68 9f       	mul	r22, r24
    14ee:	c0 01       	movw	r24, r0
    14f0:	11 24       	eor	r1, r1
    14f2:	02 c0       	rjmp	.+4      	; 0x14f8 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    14f4:	80 e0       	ldi	r24, 0x00	; 0
    14f6:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    14f8:	4f 96       	adiw	r24, 0x1f	; 31
    14fa:	0e 94 9e 04 	call	0x93c	; 0x93c <pvPortMalloc>
    14fe:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1500:	00 97       	sbiw	r24, 0x00	; 0
    1502:	71 f0       	breq	.+28     	; 0x1520 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1504:	11 23       	and	r17, r17
    1506:	19 f4       	brne	.+6      	; 0x150e <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1508:	99 83       	std	Y+1, r25	; 0x01
    150a:	88 83       	st	Y, r24
    150c:	03 c0       	rjmp	.+6      	; 0x1514 <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    150e:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1510:	99 83       	std	Y+1, r25	; 0x01
    1512:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1514:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1516:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1518:	ce 01       	movw	r24, r28
    151a:	61 e0       	ldi	r22, 0x01	; 1
    151c:	0e 94 28 0a 	call	0x1450	; 0x1450 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1520:	8c 2f       	mov	r24, r28
    1522:	9d 2f       	mov	r25, r29
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	1f 91       	pop	r17
    152a:	0f 91       	pop	r16
    152c:	08 95       	ret

0000152e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    152e:	8f 92       	push	r8
    1530:	9f 92       	push	r9
    1532:	bf 92       	push	r11
    1534:	cf 92       	push	r12
    1536:	df 92       	push	r13
    1538:	ef 92       	push	r14
    153a:	ff 92       	push	r15
    153c:	0f 93       	push	r16
    153e:	1f 93       	push	r17
    1540:	cf 93       	push	r28
    1542:	df 93       	push	r29
    1544:	00 d0       	rcall	.+0      	; 0x1546 <xQueueGenericSend+0x18>
    1546:	00 d0       	rcall	.+0      	; 0x1548 <xQueueGenericSend+0x1a>
    1548:	0f 92       	push	r0
    154a:	cd b7       	in	r28, 0x3d	; 61
    154c:	de b7       	in	r29, 0x3e	; 62
    154e:	8c 01       	movw	r16, r24
    1550:	4b 01       	movw	r8, r22
    1552:	5d 83       	std	Y+5, r21	; 0x05
    1554:	4c 83       	std	Y+4, r20	; 0x04
    1556:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1558:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    155a:	bb 24       	eor	r11, r11
    155c:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    155e:	cc 24       	eor	r12, r12
    1560:	dd 24       	eor	r13, r13
    1562:	68 94       	set
    1564:	c3 f8       	bld	r12, 3
    1566:	c8 0e       	add	r12, r24
    1568:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1570:	f8 01       	movw	r30, r16
    1572:	92 8d       	ldd	r25, Z+26	; 0x1a
    1574:	83 8d       	ldd	r24, Z+27	; 0x1b
    1576:	98 17       	cp	r25, r24
    1578:	18 f0       	brcs	.+6      	; 0x1580 <xQueueGenericSend+0x52>
    157a:	f2 e0       	ldi	r31, 0x02	; 2
    157c:	ef 16       	cp	r14, r31
    157e:	d1 f4       	brne	.+52     	; 0x15b4 <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1580:	c8 01       	movw	r24, r16
    1582:	b4 01       	movw	r22, r8
    1584:	4e 2d       	mov	r20, r14
    1586:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    158a:	f8 01       	movw	r30, r16
    158c:	91 89       	ldd	r25, Z+17	; 0x11
    158e:	99 23       	and	r25, r25
    1590:	49 f0       	breq	.+18     	; 0x15a4 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1592:	c8 01       	movw	r24, r16
    1594:	41 96       	adiw	r24, 0x11	; 17
    1596:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    159a:	88 23       	and	r24, r24
    159c:	39 f0       	breq	.+14     	; 0x15ac <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    159e:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    15a2:	04 c0       	rjmp	.+8      	; 0x15ac <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    15a4:	88 23       	and	r24, r24
    15a6:	11 f0       	breq	.+4      	; 0x15ac <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    15a8:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    15ac:	0f 90       	pop	r0
    15ae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	52 c0       	rjmp	.+164    	; 0x1658 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15b4:	8c 81       	ldd	r24, Y+4	; 0x04
    15b6:	9d 81       	ldd	r25, Y+5	; 0x05
    15b8:	00 97       	sbiw	r24, 0x00	; 0
    15ba:	21 f4       	brne	.+8      	; 0x15c4 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15bc:	0f 90       	pop	r0
    15be:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    15c0:	80 e0       	ldi	r24, 0x00	; 0
    15c2:	4a c0       	rjmp	.+148    	; 0x1658 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    15c4:	ff 20       	and	r15, r15
    15c6:	29 f4       	brne	.+10     	; 0x15d2 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15c8:	ce 01       	movw	r24, r28
    15ca:	01 96       	adiw	r24, 0x01	; 1
    15cc:	0e 94 07 14 	call	0x280e	; 0x280e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15d0:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15d6:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	f8 94       	cli
    15de:	0f 92       	push	r0
    15e0:	f8 01       	movw	r30, r16
    15e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    15e4:	8f 3f       	cpi	r24, 0xFF	; 255
    15e6:	09 f4       	brne	.+2      	; 0x15ea <xQueueGenericSend+0xbc>
    15e8:	15 8e       	std	Z+29, r1	; 0x1d
    15ea:	f8 01       	movw	r30, r16
    15ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ee:	8f 3f       	cpi	r24, 0xFF	; 255
    15f0:	09 f4       	brne	.+2      	; 0x15f4 <xQueueGenericSend+0xc6>
    15f2:	16 8e       	std	Z+30, r1	; 0x1e
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15f8:	ce 01       	movw	r24, r28
    15fa:	01 96       	adiw	r24, 0x01	; 1
    15fc:	be 01       	movw	r22, r28
    15fe:	6c 5f       	subi	r22, 0xFC	; 252
    1600:	7f 4f       	sbci	r23, 0xFF	; 255
    1602:	0e 94 12 14 	call	0x2824	; 0x2824 <xTaskCheckForTimeOut>
    1606:	88 23       	and	r24, r24
    1608:	09 f5       	brne	.+66     	; 0x164c <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1610:	f8 01       	movw	r30, r16
    1612:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1614:	0f 90       	pop	r0
    1616:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1618:	f8 01       	movw	r30, r16
    161a:	83 8d       	ldd	r24, Z+27	; 0x1b
    161c:	98 17       	cp	r25, r24
    161e:	81 f4       	brne	.+32     	; 0x1640 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1620:	6c 81       	ldd	r22, Y+4	; 0x04
    1622:	7d 81       	ldd	r23, Y+5	; 0x05
    1624:	c6 01       	movw	r24, r12
    1626:	0e 94 57 13 	call	0x26ae	; 0x26ae <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    162a:	c8 01       	movw	r24, r16
    162c:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1630:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
    1634:	88 23       	and	r24, r24
    1636:	09 f0       	breq	.+2      	; 0x163a <xQueueGenericSend+0x10c>
    1638:	98 cf       	rjmp	.-208    	; 0x156a <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    163a:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    163e:	95 cf       	rjmp	.-214    	; 0x156a <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1640:	c8 01       	movw	r24, r16
    1642:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1646:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
    164a:	8f cf       	rjmp	.-226    	; 0x156a <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    164c:	c8 01       	movw	r24, r16
    164e:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1652:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1656:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1658:	0f 90       	pop	r0
    165a:	0f 90       	pop	r0
    165c:	0f 90       	pop	r0
    165e:	0f 90       	pop	r0
    1660:	0f 90       	pop	r0
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	ff 90       	pop	r15
    166c:	ef 90       	pop	r14
    166e:	df 90       	pop	r13
    1670:	cf 90       	pop	r12
    1672:	bf 90       	pop	r11
    1674:	9f 90       	pop	r9
    1676:	8f 90       	pop	r8
    1678:	08 95       	ret

0000167a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	60 e0       	ldi	r22, 0x00	; 0
    1684:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xQueueGenericCreate>
    1688:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    168a:	00 97       	sbiw	r24, 0x00	; 0
    168c:	61 f0       	breq	.+24     	; 0x16a6 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    168e:	1b 82       	std	Y+3, r1	; 0x03
    1690:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1692:	19 82       	std	Y+1, r1	; 0x01
    1694:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1696:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1698:	60 e0       	ldi	r22, 0x00	; 0
    169a:	70 e0       	ldi	r23, 0x00	; 0
    169c:	40 e0       	ldi	r20, 0x00	; 0
    169e:	50 e0       	ldi	r21, 0x00	; 0
    16a0:	20 e0       	ldi	r18, 0x00	; 0
    16a2:	0e 94 97 0a 	call	0x152e	; 0x152e <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    16a6:	8c 2f       	mov	r24, r28
    16a8:	9d 2f       	mov	r25, r29
    16aa:	df 91       	pop	r29
    16ac:	cf 91       	pop	r28
    16ae:	08 95       	ret

000016b0 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    16b0:	ef 92       	push	r14
    16b2:	ff 92       	push	r15
    16b4:	0f 93       	push	r16
    16b6:	1f 93       	push	r17
    16b8:	cf 93       	push	r28
    16ba:	8c 01       	movw	r16, r24
    16bc:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    16be:	fc 01       	movw	r30, r24
    16c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    16c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    16c4:	98 17       	cp	r25, r24
    16c6:	10 f0       	brcs	.+4      	; 0x16cc <xQueueGenericSendFromISR+0x1c>
    16c8:	22 30       	cpi	r18, 0x02	; 2
    16ca:	f1 f4       	brne	.+60     	; 0x1708 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    16cc:	f8 01       	movw	r30, r16
    16ce:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16d0:	c8 01       	movw	r24, r16
    16d2:	42 2f       	mov	r20, r18
    16d4:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    16d8:	cf 3f       	cpi	r28, 0xFF	; 255
    16da:	89 f4       	brne	.+34     	; 0x16fe <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16dc:	f8 01       	movw	r30, r16
    16de:	81 89       	ldd	r24, Z+17	; 0x11
    16e0:	88 23       	and	r24, r24
    16e2:	a1 f0       	breq	.+40     	; 0x170c <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16e4:	c8 01       	movw	r24, r16
    16e6:	41 96       	adiw	r24, 0x11	; 17
    16e8:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    16ec:	88 23       	and	r24, r24
    16ee:	81 f0       	breq	.+32     	; 0x1710 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16f0:	e1 14       	cp	r14, r1
    16f2:	f1 04       	cpc	r15, r1
    16f4:	79 f0       	breq	.+30     	; 0x1714 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	f7 01       	movw	r30, r14
    16fa:	80 83       	st	Z, r24
    16fc:	0c c0       	rjmp	.+24     	; 0x1716 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    16fe:	cf 5f       	subi	r28, 0xFF	; 255
    1700:	f8 01       	movw	r30, r16
    1702:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	07 c0       	rjmp	.+14     	; 0x1716 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1708:	80 e0       	ldi	r24, 0x00	; 0
    170a:	05 c0       	rjmp	.+10     	; 0x1716 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    170c:	81 e0       	ldi	r24, 0x01	; 1
    170e:	03 c0       	rjmp	.+6      	; 0x1716 <xQueueGenericSendFromISR+0x66>
    1710:	81 e0       	ldi	r24, 0x01	; 1
    1712:	01 c0       	rjmp	.+2      	; 0x1716 <xQueueGenericSendFromISR+0x66>
    1714:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1716:	cf 91       	pop	r28
    1718:	1f 91       	pop	r17
    171a:	0f 91       	pop	r16
    171c:	ff 90       	pop	r15
    171e:	ef 90       	pop	r14
    1720:	08 95       	ret

00001722 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	fc 01       	movw	r30, r24
    1728:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    172a:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    172c:	93 8d       	ldd	r25, Z+27	; 0x1b
    172e:	89 17       	cp	r24, r25
    1730:	b8 f4       	brcc	.+46     	; 0x1760 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1732:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1734:	8f 5f       	subi	r24, 0xFF	; 255
    1736:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1738:	9f 3f       	cpi	r25, 0xFF	; 255
    173a:	71 f4       	brne	.+28     	; 0x1758 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    173c:	81 89       	ldd	r24, Z+17	; 0x11
    173e:	88 23       	and	r24, r24
    1740:	89 f0       	breq	.+34     	; 0x1764 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1742:	cf 01       	movw	r24, r30
    1744:	41 96       	adiw	r24, 0x11	; 17
    1746:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    174a:	88 23       	and	r24, r24
    174c:	69 f0       	breq	.+26     	; 0x1768 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    174e:	20 97       	sbiw	r28, 0x00	; 0
    1750:	69 f0       	breq	.+26     	; 0x176c <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	88 83       	st	Y, r24
    1756:	0b c0       	rjmp	.+22     	; 0x176e <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1758:	9f 5f       	subi	r25, 0xFF	; 255
    175a:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	07 c0       	rjmp	.+14     	; 0x176e <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	05 c0       	rjmp	.+10     	; 0x176e <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	03 c0       	rjmp	.+6      	; 0x176e <xQueueGiveFromISR+0x4c>
    1768:	81 e0       	ldi	r24, 0x01	; 1
    176a:	01 c0       	rjmp	.+2      	; 0x176e <xQueueGiveFromISR+0x4c>
    176c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    176e:	df 91       	pop	r29
    1770:	cf 91       	pop	r28
    1772:	08 95       	ret

00001774 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1774:	8f 92       	push	r8
    1776:	9f 92       	push	r9
    1778:	af 92       	push	r10
    177a:	bf 92       	push	r11
    177c:	cf 92       	push	r12
    177e:	df 92       	push	r13
    1780:	ef 92       	push	r14
    1782:	ff 92       	push	r15
    1784:	0f 93       	push	r16
    1786:	1f 93       	push	r17
    1788:	cf 93       	push	r28
    178a:	df 93       	push	r29
    178c:	00 d0       	rcall	.+0      	; 0x178e <xQueueGenericReceive+0x1a>
    178e:	00 d0       	rcall	.+0      	; 0x1790 <xQueueGenericReceive+0x1c>
    1790:	0f 92       	push	r0
    1792:	cd b7       	in	r28, 0x3d	; 61
    1794:	de b7       	in	r29, 0x3e	; 62
    1796:	7c 01       	movw	r14, r24
    1798:	4b 01       	movw	r8, r22
    179a:	5d 83       	std	Y+5, r21	; 0x05
    179c:	4c 83       	std	Y+4, r20	; 0x04
    179e:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    17a0:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17a2:	dd 24       	eor	r13, r13
    17a4:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17a6:	0f 2e       	mov	r0, r31
    17a8:	f1 e1       	ldi	r31, 0x11	; 17
    17aa:	af 2e       	mov	r10, r31
    17ac:	bb 24       	eor	r11, r11
    17ae:	f0 2d       	mov	r31, r0
    17b0:	a8 0e       	add	r10, r24
    17b2:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17ba:	f7 01       	movw	r30, r14
    17bc:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17be:	11 23       	and	r17, r17
    17c0:	99 f1       	breq	.+102    	; 0x1828 <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    17c2:	a6 80       	ldd	r10, Z+6	; 0x06
    17c4:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17c6:	c7 01       	movw	r24, r14
    17c8:	b4 01       	movw	r22, r8
    17ca:	0e 94 57 09 	call	0x12ae	; 0x12ae <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    17ce:	cc 20       	and	r12, r12
    17d0:	c9 f4       	brne	.+50     	; 0x1804 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    17d2:	11 50       	subi	r17, 0x01	; 1
    17d4:	f7 01       	movw	r30, r14
    17d6:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    17d8:	80 81       	ld	r24, Z
    17da:	91 81       	ldd	r25, Z+1	; 0x01
    17dc:	00 97       	sbiw	r24, 0x00	; 0
    17de:	29 f4       	brne	.+10     	; 0x17ea <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    17e0:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <pvTaskIncrementMutexHeldCount>
    17e4:	f7 01       	movw	r30, r14
    17e6:	93 83       	std	Z+3, r25	; 0x03
    17e8:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17ea:	f7 01       	movw	r30, r14
    17ec:	80 85       	ldd	r24, Z+8	; 0x08
    17ee:	88 23       	and	r24, r24
    17f0:	b9 f0       	breq	.+46     	; 0x1820 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17f2:	c7 01       	movw	r24, r14
    17f4:	08 96       	adiw	r24, 0x08	; 8
    17f6:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    17fa:	88 23       	and	r24, r24
    17fc:	89 f0       	breq	.+34     	; 0x1820 <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    17fe:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    1802:	0e c0       	rjmp	.+28     	; 0x1820 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1804:	f7 01       	movw	r30, r14
    1806:	b7 82       	std	Z+7, r11	; 0x07
    1808:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    180a:	81 89       	ldd	r24, Z+17	; 0x11
    180c:	88 23       	and	r24, r24
    180e:	41 f0       	breq	.+16     	; 0x1820 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1810:	c7 01       	movw	r24, r14
    1812:	41 96       	adiw	r24, 0x11	; 17
    1814:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    1818:	88 23       	and	r24, r24
    181a:	11 f0       	breq	.+4      	; 0x1820 <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    181c:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	61 c0       	rjmp	.+194    	; 0x18ea <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1828:	8c 81       	ldd	r24, Y+4	; 0x04
    182a:	9d 81       	ldd	r25, Y+5	; 0x05
    182c:	00 97       	sbiw	r24, 0x00	; 0
    182e:	21 f4       	brne	.+8      	; 0x1838 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1830:	0f 90       	pop	r0
    1832:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	59 c0       	rjmp	.+178    	; 0x18ea <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    1838:	00 23       	and	r16, r16
    183a:	29 f4       	brne	.+10     	; 0x1846 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    183c:	ce 01       	movw	r24, r28
    183e:	01 96       	adiw	r24, 0x01	; 1
    1840:	0e 94 07 14 	call	0x280e	; 0x280e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1844:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    184a:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	f7 01       	movw	r30, r14
    1856:	85 8d       	ldd	r24, Z+29	; 0x1d
    1858:	8f 3f       	cpi	r24, 0xFF	; 255
    185a:	09 f4       	brne	.+2      	; 0x185e <xQueueGenericReceive+0xea>
    185c:	15 8e       	std	Z+29, r1	; 0x1d
    185e:	f7 01       	movw	r30, r14
    1860:	86 8d       	ldd	r24, Z+30	; 0x1e
    1862:	8f 3f       	cpi	r24, 0xFF	; 255
    1864:	09 f4       	brne	.+2      	; 0x1868 <xQueueGenericReceive+0xf4>
    1866:	16 8e       	std	Z+30, r1	; 0x1e
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    186c:	ce 01       	movw	r24, r28
    186e:	01 96       	adiw	r24, 0x01	; 1
    1870:	be 01       	movw	r22, r28
    1872:	6c 5f       	subi	r22, 0xFC	; 252
    1874:	7f 4f       	sbci	r23, 0xFF	; 255
    1876:	0e 94 12 14 	call	0x2824	; 0x2824 <xTaskCheckForTimeOut>
    187a:	88 23       	and	r24, r24
    187c:	51 f5       	brne	.+84     	; 0x18d2 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    187e:	c7 01       	movw	r24, r14
    1880:	0e 94 4c 09 	call	0x1298	; 0x1298 <prvIsQueueEmpty>
    1884:	88 23       	and	r24, r24
    1886:	f9 f0       	breq	.+62     	; 0x18c6 <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1888:	f7 01       	movw	r30, r14
    188a:	80 81       	ld	r24, Z
    188c:	91 81       	ldd	r25, Z+1	; 0x01
    188e:	00 97       	sbiw	r24, 0x00	; 0
    1890:	51 f4       	brne	.+20     	; 0x18a6 <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1898:	f7 01       	movw	r30, r14
    189a:	82 81       	ldd	r24, Z+2	; 0x02
    189c:	93 81       	ldd	r25, Z+3	; 0x03
    189e:	0e 94 50 14 	call	0x28a0	; 0x28a0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    18a2:	0f 90       	pop	r0
    18a4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18a6:	6c 81       	ldd	r22, Y+4	; 0x04
    18a8:	7d 81       	ldd	r23, Y+5	; 0x05
    18aa:	c5 01       	movw	r24, r10
    18ac:	0e 94 57 13 	call	0x26ae	; 0x26ae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18b0:	c7 01       	movw	r24, r14
    18b2:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18b6:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
    18ba:	88 23       	and	r24, r24
    18bc:	09 f0       	breq	.+2      	; 0x18c0 <xQueueGenericReceive+0x14c>
    18be:	7a cf       	rjmp	.-268    	; 0x17b4 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    18c0:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    18c4:	77 cf       	rjmp	.-274    	; 0x17b4 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18c6:	c7 01       	movw	r24, r14
    18c8:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18cc:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
    18d0:	71 cf       	rjmp	.-286    	; 0x17b4 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    18d2:	c7 01       	movw	r24, r14
    18d4:	0e 94 74 09 	call	0x12e8	; 0x12e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18d8:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18dc:	c7 01       	movw	r24, r14
    18de:	0e 94 4c 09 	call	0x1298	; 0x1298 <prvIsQueueEmpty>
    18e2:	88 23       	and	r24, r24
    18e4:	09 f4       	brne	.+2      	; 0x18e8 <xQueueGenericReceive+0x174>
    18e6:	66 cf       	rjmp	.-308    	; 0x17b4 <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18e8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    18ea:	0f 90       	pop	r0
    18ec:	0f 90       	pop	r0
    18ee:	0f 90       	pop	r0
    18f0:	0f 90       	pop	r0
    18f2:	0f 90       	pop	r0
    18f4:	df 91       	pop	r29
    18f6:	cf 91       	pop	r28
    18f8:	1f 91       	pop	r17
    18fa:	0f 91       	pop	r16
    18fc:	ff 90       	pop	r15
    18fe:	ef 90       	pop	r14
    1900:	df 90       	pop	r13
    1902:	cf 90       	pop	r12
    1904:	bf 90       	pop	r11
    1906:	af 90       	pop	r10
    1908:	9f 90       	pop	r9
    190a:	8f 90       	pop	r8
    190c:	08 95       	ret

0000190e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    190e:	ef 92       	push	r14
    1910:	ff 92       	push	r15
    1912:	0f 93       	push	r16
    1914:	1f 93       	push	r17
    1916:	cf 93       	push	r28
    1918:	df 93       	push	r29
    191a:	8c 01       	movw	r16, r24
    191c:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    191e:	fc 01       	movw	r30, r24
    1920:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1922:	cc 23       	and	r28, r28
    1924:	e9 f0       	breq	.+58     	; 0x1960 <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1926:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1928:	0e 94 57 09 	call	0x12ae	; 0x12ae <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    192c:	c1 50       	subi	r28, 0x01	; 1
    192e:	f8 01       	movw	r30, r16
    1930:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1932:	df 3f       	cpi	r29, 0xFF	; 255
    1934:	81 f4       	brne	.+32     	; 0x1956 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1936:	80 85       	ldd	r24, Z+8	; 0x08
    1938:	88 23       	and	r24, r24
    193a:	a1 f0       	breq	.+40     	; 0x1964 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    193c:	c8 01       	movw	r24, r16
    193e:	08 96       	adiw	r24, 0x08	; 8
    1940:	0e 94 82 13 	call	0x2704	; 0x2704 <xTaskRemoveFromEventList>
    1944:	88 23       	and	r24, r24
    1946:	81 f0       	breq	.+32     	; 0x1968 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1948:	e1 14       	cp	r14, r1
    194a:	f1 04       	cpc	r15, r1
    194c:	79 f0       	breq	.+30     	; 0x196c <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    194e:	81 e0       	ldi	r24, 0x01	; 1
    1950:	f7 01       	movw	r30, r14
    1952:	80 83       	st	Z, r24
    1954:	0c c0       	rjmp	.+24     	; 0x196e <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1956:	df 5f       	subi	r29, 0xFF	; 255
    1958:	f8 01       	movw	r30, r16
    195a:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	07 c0       	rjmp	.+14     	; 0x196e <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	05 c0       	rjmp	.+10     	; 0x196e <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	03 c0       	rjmp	.+6      	; 0x196e <xQueueReceiveFromISR+0x60>
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	01 c0       	rjmp	.+2      	; 0x196e <xQueueReceiveFromISR+0x60>
    196c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	1f 91       	pop	r17
    1974:	0f 91       	pop	r16
    1976:	ff 90       	pop	r15
    1978:	ef 90       	pop	r14
    197a:	08 95       	ret

0000197c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    197c:	0f 93       	push	r16
    197e:	1f 93       	push	r17
    1980:	cf 93       	push	r28
    1982:	df 93       	push	r29
    1984:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1986:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1988:	88 23       	and	r24, r24
    198a:	49 f0       	breq	.+18     	; 0x199e <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    198c:	0e 81       	ldd	r16, Y+6	; 0x06
    198e:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1990:	ce 01       	movw	r24, r28
    1992:	0e 94 57 09 	call	0x12ae	; 0x12ae <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1996:	1f 83       	std	Y+7, r17	; 0x07
    1998:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	01 c0       	rjmp	.+2      	; 0x19a0 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    199e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19a0:	df 91       	pop	r29
    19a2:	cf 91       	pop	r28
    19a4:	1f 91       	pop	r17
    19a6:	0f 91       	pop	r16
    19a8:	08 95       	ret

000019aa <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19b0:	fc 01       	movw	r30, r24
    19b2:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19b4:	0f 90       	pop	r0
    19b6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19b8:	08 95       	ret

000019ba <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    19ba:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19bc:	0f b6       	in	r0, 0x3f	; 63
    19be:	f8 94       	cli
    19c0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19c2:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19c4:	0f 90       	pop	r0
    19c6:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19c8:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19ca:	89 1b       	sub	r24, r25
    19cc:	08 95       	ret

000019ce <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19ce:	fc 01       	movw	r30, r24
    19d0:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19d2:	08 95       	ret

000019d4 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19d4:	fc 01       	movw	r30, r24
    19d6:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	91 11       	cpse	r25, r1
    19dc:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19de:	08 95       	ret

000019e0 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19e0:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    19e2:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	93 8d       	ldd	r25, Z+27	; 0x1b
    19e8:	29 13       	cpse	r18, r25
    19ea:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19ec:	08 95       	ret

000019ee <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    19ee:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    19f0:	80 91 16 04 	lds	r24, 0x0416
    19f4:	90 91 17 04 	lds	r25, 0x0417
    19f8:	00 97       	sbiw	r24, 0x00	; 0
    19fa:	51 f0       	breq	.+20     	; 0x1a10 <vQueueAddToRegistry+0x22>
    19fc:	ea e1       	ldi	r30, 0x1A	; 26
    19fe:	f4 e0       	ldi	r31, 0x04	; 4
    1a00:	21 e0       	ldi	r18, 0x01	; 1
    1a02:	30 e0       	ldi	r19, 0x00	; 0
    1a04:	a9 01       	movw	r20, r18
    1a06:	80 81       	ld	r24, Z
    1a08:	91 81       	ldd	r25, Z+1	; 0x01
    1a0a:	00 97       	sbiw	r24, 0x00	; 0
    1a0c:	79 f4       	brne	.+30     	; 0x1a2c <vQueueAddToRegistry+0x3e>
    1a0e:	02 c0       	rjmp	.+4      	; 0x1a14 <vQueueAddToRegistry+0x26>
    1a10:	40 e0       	ldi	r20, 0x00	; 0
    1a12:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1a14:	fa 01       	movw	r30, r20
    1a16:	ee 0f       	add	r30, r30
    1a18:	ff 1f       	adc	r31, r31
    1a1a:	ee 0f       	add	r30, r30
    1a1c:	ff 1f       	adc	r31, r31
    1a1e:	ea 5e       	subi	r30, 0xEA	; 234
    1a20:	fb 4f       	sbci	r31, 0xFB	; 251
    1a22:	71 83       	std	Z+1, r23	; 0x01
    1a24:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    1a26:	b3 83       	std	Z+3, r27	; 0x03
    1a28:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1a2a:	08 95       	ret
    1a2c:	2f 5f       	subi	r18, 0xFF	; 255
    1a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a30:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1a32:	28 30       	cpi	r18, 0x08	; 8
    1a34:	31 05       	cpc	r19, r1
    1a36:	31 f7       	brne	.-52     	; 0x1a04 <vQueueAddToRegistry+0x16>
    1a38:	08 95       	ret

00001a3a <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1a3a:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1a3c:	80 91 18 04 	lds	r24, 0x0418
    1a40:	90 91 19 04 	lds	r25, 0x0419
    1a44:	84 17       	cp	r24, r20
    1a46:	95 07       	cpc	r25, r21
    1a48:	59 f0       	breq	.+22     	; 0x1a60 <pcQueueGetName+0x26>
    1a4a:	ec e1       	ldi	r30, 0x1C	; 28
    1a4c:	f4 e0       	ldi	r31, 0x04	; 4
    1a4e:	21 e0       	ldi	r18, 0x01	; 1
    1a50:	30 e0       	ldi	r19, 0x00	; 0
    1a52:	b9 01       	movw	r22, r18
    1a54:	80 81       	ld	r24, Z
    1a56:	91 81       	ldd	r25, Z+1	; 0x01
    1a58:	84 17       	cp	r24, r20
    1a5a:	95 07       	cpc	r25, r21
    1a5c:	69 f4       	brne	.+26     	; 0x1a78 <pcQueueGetName+0x3e>
    1a5e:	02 c0       	rjmp	.+4      	; 0x1a64 <pcQueueGetName+0x2a>
    1a60:	60 e0       	ldi	r22, 0x00	; 0
    1a62:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    1a64:	fb 01       	movw	r30, r22
    1a66:	ee 0f       	add	r30, r30
    1a68:	ff 1f       	adc	r31, r31
    1a6a:	ee 0f       	add	r30, r30
    1a6c:	ff 1f       	adc	r31, r31
    1a6e:	ea 5e       	subi	r30, 0xEA	; 234
    1a70:	fb 4f       	sbci	r31, 0xFB	; 251
    1a72:	80 81       	ld	r24, Z
    1a74:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    1a76:	08 95       	ret
    1a78:	2f 5f       	subi	r18, 0xFF	; 255
    1a7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a7c:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1a7e:	28 30       	cpi	r18, 0x08	; 8
    1a80:	31 05       	cpc	r19, r1
    1a82:	39 f7       	brne	.-50     	; 0x1a52 <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1a84:	80 e0       	ldi	r24, 0x00	; 0
    1a86:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    1a88:	08 95       	ret

00001a8a <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    1a8a:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1a8c:	80 91 18 04 	lds	r24, 0x0418
    1a90:	90 91 19 04 	lds	r25, 0x0419
    1a94:	84 17       	cp	r24, r20
    1a96:	95 07       	cpc	r25, r21
    1a98:	59 f0       	breq	.+22     	; 0x1ab0 <vQueueUnregisterQueue+0x26>
    1a9a:	ec e1       	ldi	r30, 0x1C	; 28
    1a9c:	f4 e0       	ldi	r31, 0x04	; 4
    1a9e:	21 e0       	ldi	r18, 0x01	; 1
    1aa0:	30 e0       	ldi	r19, 0x00	; 0
    1aa2:	b9 01       	movw	r22, r18
    1aa4:	80 81       	ld	r24, Z
    1aa6:	91 81       	ldd	r25, Z+1	; 0x01
    1aa8:	84 17       	cp	r24, r20
    1aaa:	95 07       	cpc	r25, r21
    1aac:	79 f4       	brne	.+30     	; 0x1acc <vQueueUnregisterQueue+0x42>
    1aae:	02 c0       	rjmp	.+4      	; 0x1ab4 <vQueueUnregisterQueue+0x2a>
    1ab0:	60 e0       	ldi	r22, 0x00	; 0
    1ab2:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    1ab4:	fb 01       	movw	r30, r22
    1ab6:	ee 0f       	add	r30, r30
    1ab8:	ff 1f       	adc	r31, r31
    1aba:	ee 0f       	add	r30, r30
    1abc:	ff 1f       	adc	r31, r31
    1abe:	ea 5e       	subi	r30, 0xEA	; 234
    1ac0:	fb 4f       	sbci	r31, 0xFB	; 251
    1ac2:	11 82       	std	Z+1, r1	; 0x01
    1ac4:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    1ac6:	13 82       	std	Z+3, r1	; 0x03
    1ac8:	12 82       	std	Z+2, r1	; 0x02
				break;
    1aca:	08 95       	ret
    1acc:	2f 5f       	subi	r18, 0xFF	; 255
    1ace:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad0:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1ad2:	28 30       	cpi	r18, 0x08	; 8
    1ad4:	31 05       	cpc	r19, r1
    1ad6:	29 f7       	brne	.-54     	; 0x1aa2 <vQueueUnregisterQueue+0x18>
    1ad8:	08 95       	ret

00001ada <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1ada:	cf 93       	push	r28
    1adc:	df 93       	push	r29
    1ade:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    1ae0:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ae4:	ce 01       	movw	r24, r28
    1ae6:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1aea:	df 91       	pop	r29
    1aec:	cf 91       	pop	r28
    1aee:	08 95       	ret

00001af0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    1af0:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    1af2:	82 85       	ldd	r24, Z+10	; 0x0a
    1af4:	93 85       	ldd	r25, Z+11	; 0x0b
    1af6:	24 e0       	ldi	r18, 0x04	; 4
    1af8:	89 30       	cpi	r24, 0x09	; 9
    1afa:	92 07       	cpc	r25, r18
    1afc:	61 f4       	brne	.+24     	; 0x1b16 <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1afe:	24 89       	ldd	r18, Z+20	; 0x14
    1b00:	35 89       	ldd	r19, Z+21	; 0x15
    1b02:	83 e0       	ldi	r24, 0x03	; 3
    1b04:	27 3f       	cpi	r18, 0xF7	; 247
    1b06:	38 07       	cpc	r19, r24
    1b08:	41 f0       	breq	.+16     	; 0x1b1a <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	21 15       	cp	r18, r1
    1b0e:	31 05       	cpc	r19, r1
    1b10:	29 f0       	breq	.+10     	; 0x1b1c <prvTaskIsTaskSuspended+0x2c>
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	08 95       	ret
    1b16:	80 e0       	ldi	r24, 0x00	; 0
    1b18:	08 95       	ret
    1b1a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1b1c:	08 95       	ret

00001b1e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1b1e:	e0 91 b5 03 	lds	r30, 0x03B5
    1b22:	f0 91 b6 03 	lds	r31, 0x03B6
    1b26:	80 81       	ld	r24, Z
    1b28:	88 23       	and	r24, r24
    1b2a:	39 f4       	brne	.+14     	; 0x1b3a <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1b2c:	8f ef       	ldi	r24, 0xFF	; 255
    1b2e:	9f ef       	ldi	r25, 0xFF	; 255
    1b30:	90 93 a9 03 	sts	0x03A9, r25
    1b34:	80 93 a8 03 	sts	0x03A8, r24
    1b38:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1b3a:	e0 91 b5 03 	lds	r30, 0x03B5
    1b3e:	f0 91 b6 03 	lds	r31, 0x03B6
    1b42:	05 80       	ldd	r0, Z+5	; 0x05
    1b44:	f6 81       	ldd	r31, Z+6	; 0x06
    1b46:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1b48:	06 80       	ldd	r0, Z+6	; 0x06
    1b4a:	f7 81       	ldd	r31, Z+7	; 0x07
    1b4c:	e0 2d       	mov	r30, r0
    1b4e:	82 81       	ldd	r24, Z+2	; 0x02
    1b50:	93 81       	ldd	r25, Z+3	; 0x03
    1b52:	90 93 a9 03 	sts	0x03A9, r25
    1b56:	80 93 a8 03 	sts	0x03A8, r24
    1b5a:	08 95       	ret

00001b5c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1b5c:	ef 92       	push	r14
    1b5e:	ff 92       	push	r15
    1b60:	1f 93       	push	r17
    1b62:	cf 93       	push	r28
    1b64:	df 93       	push	r29
    1b66:	ec 01       	movw	r28, r24
    1b68:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1b6a:	e0 90 af 03 	lds	r14, 0x03AF
    1b6e:	f0 90 b0 03 	lds	r15, 0x03B0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1b72:	80 91 a5 03 	lds	r24, 0x03A5
    1b76:	90 91 a6 03 	lds	r25, 0x03A6
    1b7a:	02 96       	adiw	r24, 0x02	; 2
    1b7c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1b80:	8f ef       	ldi	r24, 0xFF	; 255
    1b82:	cf 3f       	cpi	r28, 0xFF	; 255
    1b84:	d8 07       	cpc	r29, r24
    1b86:	69 f4       	brne	.+26     	; 0x1ba2 <prvAddCurrentTaskToDelayedList+0x46>
    1b88:	11 23       	and	r17, r17
    1b8a:	59 f0       	breq	.+22     	; 0x1ba2 <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1b8c:	60 91 a5 03 	lds	r22, 0x03A5
    1b90:	70 91 a6 03 	lds	r23, 0x03A6
    1b94:	6e 5f       	subi	r22, 0xFE	; 254
    1b96:	7f 4f       	sbci	r23, 0xFF	; 255
    1b98:	89 e0       	ldi	r24, 0x09	; 9
    1b9a:	94 e0       	ldi	r25, 0x04	; 4
    1b9c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    1ba0:	2f c0       	rjmp	.+94     	; 0x1c00 <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1ba2:	ce 0d       	add	r28, r14
    1ba4:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1ba6:	e0 91 a5 03 	lds	r30, 0x03A5
    1baa:	f0 91 a6 03 	lds	r31, 0x03A6
    1bae:	d3 83       	std	Z+3, r29	; 0x03
    1bb0:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    1bb2:	ce 15       	cp	r28, r14
    1bb4:	df 05       	cpc	r29, r15
    1bb6:	68 f4       	brcc	.+26     	; 0x1bd2 <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1bb8:	80 91 b3 03 	lds	r24, 0x03B3
    1bbc:	90 91 b4 03 	lds	r25, 0x03B4
    1bc0:	60 91 a5 03 	lds	r22, 0x03A5
    1bc4:	70 91 a6 03 	lds	r23, 0x03A6
    1bc8:	6e 5f       	subi	r22, 0xFE	; 254
    1bca:	7f 4f       	sbci	r23, 0xFF	; 255
    1bcc:	0e 94 1b 07 	call	0xe36	; 0xe36 <vListInsert>
    1bd0:	17 c0       	rjmp	.+46     	; 0x1c00 <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1bd2:	80 91 b5 03 	lds	r24, 0x03B5
    1bd6:	90 91 b6 03 	lds	r25, 0x03B6
    1bda:	60 91 a5 03 	lds	r22, 0x03A5
    1bde:	70 91 a6 03 	lds	r23, 0x03A6
    1be2:	6e 5f       	subi	r22, 0xFE	; 254
    1be4:	7f 4f       	sbci	r23, 0xFF	; 255
    1be6:	0e 94 1b 07 	call	0xe36	; 0xe36 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    1bea:	80 91 a8 03 	lds	r24, 0x03A8
    1bee:	90 91 a9 03 	lds	r25, 0x03A9
    1bf2:	c8 17       	cp	r28, r24
    1bf4:	d9 07       	cpc	r29, r25
    1bf6:	20 f4       	brcc	.+8      	; 0x1c00 <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1bf8:	d0 93 a9 03 	sts	0x03A9, r29
    1bfc:	c0 93 a8 03 	sts	0x03A8, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1c00:	df 91       	pop	r29
    1c02:	cf 91       	pop	r28
    1c04:	1f 91       	pop	r17
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	08 95       	ret

00001c0c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1c12:	8f 89       	ldd	r24, Y+23	; 0x17
    1c14:	98 8d       	ldd	r25, Y+24	; 0x18
    1c16:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortFree>
			vPortFree( pxTCB );
    1c1a:	ce 01       	movw	r24, r28
    1c1c:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	08 95       	ret

00001c26 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1c26:	2f 92       	push	r2
    1c28:	3f 92       	push	r3
    1c2a:	4f 92       	push	r4
    1c2c:	5f 92       	push	r5
    1c2e:	6f 92       	push	r6
    1c30:	7f 92       	push	r7
    1c32:	8f 92       	push	r8
    1c34:	9f 92       	push	r9
    1c36:	af 92       	push	r10
    1c38:	bf 92       	push	r11
    1c3a:	df 92       	push	r13
    1c3c:	ef 92       	push	r14
    1c3e:	ff 92       	push	r15
    1c40:	0f 93       	push	r16
    1c42:	1f 93       	push	r17
    1c44:	cf 93       	push	r28
    1c46:	df 93       	push	r29
    1c48:	3c 01       	movw	r6, r24
    1c4a:	5b 01       	movw	r10, r22
    1c4c:	ea 01       	movw	r28, r20
    1c4e:	29 01       	movw	r4, r18
    1c50:	d0 2e       	mov	r13, r16
    1c52:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c54:	ca 01       	movw	r24, r20
    1c56:	0e 94 9e 04 	call	0x93c	; 0x93c <pvPortMalloc>
    1c5a:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1c5c:	00 97       	sbiw	r24, 0x00	; 0
    1c5e:	09 f4       	brne	.+2      	; 0x1c62 <xTaskCreate+0x3c>
    1c60:	ed c0       	rjmp	.+474    	; 0x1e3c <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1c62:	8a e2       	ldi	r24, 0x2A	; 42
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	0e 94 9e 04 	call	0x93c	; 0x93c <pvPortMalloc>
    1c6a:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1c6c:	00 97       	sbiw	r24, 0x00	; 0
    1c6e:	81 f0       	breq	.+32     	; 0x1c90 <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1c70:	fc 01       	movw	r30, r24
    1c72:	f0 8e       	std	Z+24, r15	; 0x18
    1c74:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1c76:	21 97       	sbiw	r28, 0x01	; 1
    1c78:	17 01       	movw	r2, r14
    1c7a:	2c 0e       	add	r2, r28
    1c7c:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1c7e:	f5 01       	movw	r30, r10
    1c80:	80 81       	ld	r24, Z
    1c82:	f8 01       	movw	r30, r16
    1c84:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1c86:	f5 01       	movw	r30, r10
    1c88:	80 81       	ld	r24, Z
    1c8a:	88 23       	and	r24, r24
    1c8c:	31 f4       	brne	.+12     	; 0x1c9a <xTaskCreate+0x74>
    1c8e:	13 c0       	rjmp	.+38     	; 0x1cb6 <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1c90:	c7 01       	movw	r24, r14
    1c92:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1c96:	8f ef       	ldi	r24, 0xFF	; 255
    1c98:	d6 c0       	rjmp	.+428    	; 0x1e46 <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1c9a:	e8 01       	movw	r28, r16
    1c9c:	6a 96       	adiw	r28, 0x1a	; 26
    1c9e:	d5 01       	movw	r26, r10
    1ca0:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1ca4:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1ca6:	9d 91       	ld	r25, X+
    1ca8:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1caa:	90 81       	ld	r25, Z
    1cac:	99 23       	and	r25, r25
    1cae:	19 f0       	breq	.+6      	; 0x1cb6 <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1cb0:	8f 5f       	subi	r24, 0xFF	; 255
    1cb2:	8a 30       	cpi	r24, 0x0A	; 10
    1cb4:	b9 f7       	brne	.-18     	; 0x1ca4 <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1cb6:	f8 01       	movw	r30, r16
    1cb8:	12 a2       	lds	r17, 0x92
    1cba:	cd 2d       	mov	r28, r13
    1cbc:	c5 30       	cpi	r28, 0x05	; 5
    1cbe:	08 f0       	brcs	.+2      	; 0x1cc2 <xTaskCreate+0x9c>
    1cc0:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1cc2:	f8 01       	movw	r30, r16
    1cc4:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    1cc6:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    1cc8:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1cca:	ee 24       	eor	r14, r14
    1ccc:	ff 24       	eor	r15, r15
    1cce:	68 94       	set
    1cd0:	e1 f8       	bld	r14, 1
    1cd2:	e0 0e       	add	r14, r16
    1cd4:	f1 1e       	adc	r15, r17
    1cd6:	c7 01       	movw	r24, r14
    1cd8:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1cdc:	c8 01       	movw	r24, r16
    1cde:	0c 96       	adiw	r24, 0x0c	; 12
    1ce0:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1ce4:	f8 01       	movw	r30, r16
    1ce6:	11 87       	std	Z+9, r17	; 0x09
    1ce8:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1cea:	85 e0       	ldi	r24, 0x05	; 5
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	8c 1b       	sub	r24, r28
    1cf0:	91 09       	sbc	r25, r1
    1cf2:	95 87       	std	Z+13, r25	; 0x0d
    1cf4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1cf6:	13 8b       	std	Z+19, r17	; 0x13
    1cf8:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1cfa:	15 a2       	lds	r17, 0x95
    1cfc:	16 a2       	lds	r17, 0x96
    1cfe:	17 a2       	lds	r17, 0x97
    1d00:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1d02:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1d04:	c1 01       	movw	r24, r2
    1d06:	b3 01       	movw	r22, r6
    1d08:	a2 01       	movw	r20, r4
    1d0a:	0e 94 cd 07 	call	0xf9a	; 0xf9a <pxPortInitialiseStack>
    1d0e:	f8 01       	movw	r30, r16
    1d10:	91 83       	std	Z+1, r25	; 0x01
    1d12:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1d14:	81 14       	cp	r8, r1
    1d16:	91 04       	cpc	r9, r1
    1d18:	19 f0       	breq	.+6      	; 0x1d20 <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1d1a:	f4 01       	movw	r30, r8
    1d1c:	11 83       	std	Z+1, r17	; 0x01
    1d1e:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1d20:	0f b6       	in	r0, 0x3f	; 63
    1d22:	f8 94       	cli
    1d24:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1d26:	80 91 b1 03 	lds	r24, 0x03B1
    1d2a:	8f 5f       	subi	r24, 0xFF	; 255
    1d2c:	80 93 b1 03 	sts	0x03B1, r24
		if( pxCurrentTCB == NULL )
    1d30:	80 91 a5 03 	lds	r24, 0x03A5
    1d34:	90 91 a6 03 	lds	r25, 0x03A6
    1d38:	00 97       	sbiw	r24, 0x00	; 0
    1d3a:	09 f0       	breq	.+2      	; 0x1d3e <xTaskCreate+0x118>
    1d3c:	3f c0       	rjmp	.+126    	; 0x1dbc <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1d3e:	10 93 a6 03 	sts	0x03A6, r17
    1d42:	00 93 a5 03 	sts	0x03A5, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1d46:	80 91 b1 03 	lds	r24, 0x03B1
    1d4a:	81 30       	cpi	r24, 0x01	; 1
    1d4c:	09 f0       	breq	.+2      	; 0x1d50 <xTaskCreate+0x12a>
    1d4e:	47 c0       	rjmp	.+142    	; 0x1dde <xTaskCreate+0x1b8>
    1d50:	c0 e0       	ldi	r28, 0x00	; 0
    1d52:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1d54:	ce 01       	movw	r24, r28
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	88 0f       	add	r24, r24
    1d5c:	99 1f       	adc	r25, r25
    1d5e:	88 0f       	add	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	8c 0f       	add	r24, r28
    1d64:	9d 1f       	adc	r25, r29
    1d66:	88 54       	subi	r24, 0x48	; 72
    1d68:	9c 4f       	sbci	r25, 0xFC	; 252
    1d6a:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
    1d6e:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1d70:	c5 30       	cpi	r28, 0x05	; 5
    1d72:	d1 05       	cpc	r29, r1
    1d74:	79 f7       	brne	.-34     	; 0x1d54 <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1d76:	c5 ee       	ldi	r28, 0xE5	; 229
    1d78:	d3 e0       	ldi	r29, 0x03	; 3
    1d7a:	ce 01       	movw	r24, r28
    1d7c:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1d80:	0f 2e       	mov	r0, r31
    1d82:	fe ee       	ldi	r31, 0xEE	; 238
    1d84:	af 2e       	mov	r10, r31
    1d86:	f3 e0       	ldi	r31, 0x03	; 3
    1d88:	bf 2e       	mov	r11, r31
    1d8a:	f0 2d       	mov	r31, r0
    1d8c:	c5 01       	movw	r24, r10
    1d8e:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1d92:	87 ef       	ldi	r24, 0xF7	; 247
    1d94:	93 e0       	ldi	r25, 0x03	; 3
    1d96:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
    1d9c:	94 e0       	ldi	r25, 0x04	; 4
    1d9e:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1da2:	89 e0       	ldi	r24, 0x09	; 9
    1da4:	94 e0       	ldi	r25, 0x04	; 4
    1da6:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1daa:	d0 93 b6 03 	sts	0x03B6, r29
    1dae:	c0 93 b5 03 	sts	0x03B5, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1db2:	b0 92 b4 03 	sts	0x03B4, r11
    1db6:	a0 92 b3 03 	sts	0x03B3, r10
    1dba:	11 c0       	rjmp	.+34     	; 0x1dde <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1dbc:	80 91 ad 03 	lds	r24, 0x03AD
    1dc0:	88 23       	and	r24, r24
    1dc2:	69 f4       	brne	.+26     	; 0x1dde <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1dc4:	e0 91 a5 03 	lds	r30, 0x03A5
    1dc8:	f0 91 a6 03 	lds	r31, 0x03A6
    1dcc:	96 89       	ldd	r25, Z+22	; 0x16
    1dce:	f8 01       	movw	r30, r16
    1dd0:	86 89       	ldd	r24, Z+22	; 0x16
    1dd2:	89 17       	cp	r24, r25
    1dd4:	20 f0       	brcs	.+8      	; 0x1dde <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    1dd6:	10 93 a6 03 	sts	0x03A6, r17
    1dda:	00 93 a5 03 	sts	0x03A5, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1dde:	80 91 b7 03 	lds	r24, 0x03B7
    1de2:	8f 5f       	subi	r24, 0xFF	; 255
    1de4:	80 93 b7 03 	sts	0x03B7, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1de8:	f8 01       	movw	r30, r16
    1dea:	86 89       	ldd	r24, Z+22	; 0x16
    1dec:	90 91 ae 03 	lds	r25, 0x03AE
    1df0:	98 17       	cp	r25, r24
    1df2:	10 f4       	brcc	.+4      	; 0x1df8 <xTaskCreate+0x1d2>
    1df4:	80 93 ae 03 	sts	0x03AE, r24
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	9c 01       	movw	r18, r24
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	22 0f       	add	r18, r18
    1e02:	33 1f       	adc	r19, r19
    1e04:	22 0f       	add	r18, r18
    1e06:	33 1f       	adc	r19, r19
    1e08:	82 0f       	add	r24, r18
    1e0a:	93 1f       	adc	r25, r19
    1e0c:	88 54       	subi	r24, 0x48	; 72
    1e0e:	9c 4f       	sbci	r25, 0xFC	; 252
    1e10:	b7 01       	movw	r22, r14
    1e12:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1e1a:	80 91 ad 03 	lds	r24, 0x03AD
    1e1e:	88 23       	and	r24, r24
    1e20:	79 f0       	breq	.+30     	; 0x1e40 <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1e22:	e0 91 a5 03 	lds	r30, 0x03A5
    1e26:	f0 91 a6 03 	lds	r31, 0x03A6
    1e2a:	96 89       	ldd	r25, Z+22	; 0x16
    1e2c:	f8 01       	movw	r30, r16
    1e2e:	86 89       	ldd	r24, Z+22	; 0x16
    1e30:	98 17       	cp	r25, r24
    1e32:	40 f4       	brcc	.+16     	; 0x1e44 <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1e34:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	05 c0       	rjmp	.+10     	; 0x1e46 <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e3c:	8f ef       	ldi	r24, 0xFF	; 255
    1e3e:	03 c0       	rjmp	.+6      	; 0x1e46 <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	01 c0       	rjmp	.+2      	; 0x1e46 <xTaskCreate+0x220>
    1e44:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	1f 91       	pop	r17
    1e4c:	0f 91       	pop	r16
    1e4e:	ff 90       	pop	r15
    1e50:	ef 90       	pop	r14
    1e52:	df 90       	pop	r13
    1e54:	bf 90       	pop	r11
    1e56:	af 90       	pop	r10
    1e58:	9f 90       	pop	r9
    1e5a:	8f 90       	pop	r8
    1e5c:	7f 90       	pop	r7
    1e5e:	6f 90       	pop	r6
    1e60:	5f 90       	pop	r5
    1e62:	4f 90       	pop	r4
    1e64:	3f 90       	pop	r3
    1e66:	2f 90       	pop	r2
    1e68:	08 95       	ret

00001e6a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	cf 93       	push	r28
    1e70:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1e78:	00 97       	sbiw	r24, 0x00	; 0
    1e7a:	29 f4       	brne	.+10     	; 0x1e86 <vTaskDelete+0x1c>
    1e7c:	c0 91 a5 03 	lds	r28, 0x03A5
    1e80:	d0 91 a6 03 	lds	r29, 0x03A6
    1e84:	01 c0       	rjmp	.+2      	; 0x1e88 <vTaskDelete+0x1e>
    1e86:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1e88:	8e 01       	movw	r16, r28
    1e8a:	0e 5f       	subi	r16, 0xFE	; 254
    1e8c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8e:	c8 01       	movw	r24, r16
    1e90:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1e94:	8c 89       	ldd	r24, Y+20	; 0x14
    1e96:	9d 89       	ldd	r25, Y+21	; 0x15
    1e98:	00 97       	sbiw	r24, 0x00	; 0
    1e9a:	21 f0       	breq	.+8      	; 0x1ea4 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1e9c:	ce 01       	movw	r24, r28
    1e9e:	0c 96       	adiw	r24, 0x0c	; 12
    1ea0:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1ea4:	80 91 b7 03 	lds	r24, 0x03B7
    1ea8:	8f 5f       	subi	r24, 0xFF	; 255
    1eaa:	80 93 b7 03 	sts	0x03B7, r24

			if( pxTCB == pxCurrentTCB )
    1eae:	80 91 a5 03 	lds	r24, 0x03A5
    1eb2:	90 91 a6 03 	lds	r25, 0x03A6
    1eb6:	c8 17       	cp	r28, r24
    1eb8:	d9 07       	cpc	r29, r25
    1eba:	59 f4       	brne	.+22     	; 0x1ed2 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1ebc:	80 e0       	ldi	r24, 0x00	; 0
    1ebe:	94 e0       	ldi	r25, 0x04	; 4
    1ec0:	b8 01       	movw	r22, r16
    1ec2:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1ec6:	80 91 b2 03 	lds	r24, 0x03B2
    1eca:	8f 5f       	subi	r24, 0xFF	; 255
    1ecc:	80 93 b2 03 	sts	0x03B2, r24
    1ed0:	0a c0       	rjmp	.+20     	; 0x1ee6 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1ed2:	80 91 b1 03 	lds	r24, 0x03B1
    1ed6:	81 50       	subi	r24, 0x01	; 1
    1ed8:	80 93 b1 03 	sts	0x03B1, r24
				prvDeleteTCB( pxTCB );
    1edc:	ce 01       	movw	r24, r28
    1ede:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1ee2:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1eea:	80 91 ad 03 	lds	r24, 0x03AD
    1eee:	88 23       	and	r24, r24
    1ef0:	49 f0       	breq	.+18     	; 0x1f04 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    1ef2:	80 91 a5 03 	lds	r24, 0x03A5
    1ef6:	90 91 a6 03 	lds	r25, 0x03A6
    1efa:	c8 17       	cp	r28, r24
    1efc:	d9 07       	cpc	r29, r25
    1efe:	11 f4       	brne	.+4      	; 0x1f04 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1f00:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1f04:	df 91       	pop	r29
    1f06:	cf 91       	pop	r28
    1f08:	1f 91       	pop	r17
    1f0a:	0f 91       	pop	r16
    1f0c:	08 95       	ret

00001f0e <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1f0e:	0f b6       	in	r0, 0x3f	; 63
    1f10:	f8 94       	cli
    1f12:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1f14:	00 97       	sbiw	r24, 0x00	; 0
    1f16:	29 f4       	brne	.+10     	; 0x1f22 <uxTaskPriorityGet+0x14>
    1f18:	e0 91 a5 03 	lds	r30, 0x03A5
    1f1c:	f0 91 a6 03 	lds	r31, 0x03A6
    1f20:	01 c0       	rjmp	.+2      	; 0x1f24 <uxTaskPriorityGet+0x16>
    1f22:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1f24:	0f 90       	pop	r0
    1f26:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1f28:	86 89       	ldd	r24, Z+22	; 0x16
    1f2a:	08 95       	ret

00001f2c <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1f2c:	00 97       	sbiw	r24, 0x00	; 0
    1f2e:	29 f4       	brne	.+10     	; 0x1f3a <uxTaskPriorityGetFromISR+0xe>
    1f30:	e0 91 a5 03 	lds	r30, 0x03A5
    1f34:	f0 91 a6 03 	lds	r31, 0x03A6
    1f38:	01 c0       	rjmp	.+2      	; 0x1f3c <uxTaskPriorityGetFromISR+0x10>
    1f3a:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1f3c:	86 89       	ldd	r24, Z+22	; 0x16
    1f3e:	08 95       	ret

00001f40 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1f40:	ef 92       	push	r14
    1f42:	ff 92       	push	r15
    1f44:	1f 93       	push	r17
    1f46:	cf 93       	push	r28
    1f48:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1f4a:	65 30       	cpi	r22, 0x05	; 5
    1f4c:	08 f0       	brcs	.+2      	; 0x1f50 <vTaskPrioritySet+0x10>
    1f4e:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	29 f4       	brne	.+10     	; 0x1f64 <vTaskPrioritySet+0x24>
    1f5a:	c0 91 a5 03 	lds	r28, 0x03A5
    1f5e:	d0 91 a6 03 	lds	r29, 0x03A6
    1f62:	01 c0       	rjmp	.+2      	; 0x1f66 <vTaskPrioritySet+0x26>
    1f64:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1f66:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1f68:	26 17       	cp	r18, r22
    1f6a:	09 f4       	brne	.+2      	; 0x1f6e <vTaskPrioritySet+0x2e>
    1f6c:	61 c0       	rjmp	.+194    	; 0x2030 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1f6e:	26 17       	cp	r18, r22
    1f70:	88 f4       	brcc	.+34     	; 0x1f94 <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    1f72:	80 91 a5 03 	lds	r24, 0x03A5
    1f76:	90 91 a6 03 	lds	r25, 0x03A6
    1f7a:	c8 17       	cp	r28, r24
    1f7c:	d9 07       	cpc	r29, r25
    1f7e:	a1 f0       	breq	.+40     	; 0x1fa8 <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1f80:	e0 91 a5 03 	lds	r30, 0x03A5
    1f84:	f0 91 a6 03 	lds	r31, 0x03A6
						{
							xYieldRequired = pdTRUE;
    1f88:	11 e0       	ldi	r17, 0x01	; 1
    1f8a:	86 89       	ldd	r24, Z+22	; 0x16
    1f8c:	68 17       	cp	r22, r24
    1f8e:	68 f4       	brcc	.+26     	; 0x1faa <vTaskPrioritySet+0x6a>
    1f90:	10 e0       	ldi	r17, 0x00	; 0
    1f92:	0b c0       	rjmp	.+22     	; 0x1faa <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1f94:	80 91 a5 03 	lds	r24, 0x03A5
    1f98:	90 91 a6 03 	lds	r25, 0x03A6
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    1f9c:	11 e0       	ldi	r17, 0x01	; 1
    1f9e:	c8 17       	cp	r28, r24
    1fa0:	d9 07       	cpc	r29, r25
    1fa2:	19 f0       	breq	.+6      	; 0x1faa <vTaskPrioritySet+0x6a>
    1fa4:	10 e0       	ldi	r17, 0x00	; 0
    1fa6:	01 c0       	rjmp	.+2      	; 0x1faa <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1fa8:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1faa:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1fac:	28 17       	cp	r18, r24
    1fae:	09 f4       	brne	.+2      	; 0x1fb2 <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    1fb0:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1fb2:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1fb4:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fb6:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fb8:	33 23       	and	r19, r19
    1fba:	34 f0       	brlt	.+12     	; 0x1fc8 <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1fbc:	25 e0       	ldi	r18, 0x05	; 5
    1fbe:	30 e0       	ldi	r19, 0x00	; 0
    1fc0:	26 1b       	sub	r18, r22
    1fc2:	31 09       	sbc	r19, r1
    1fc4:	3d 87       	std	Y+13, r19	; 0x0d
    1fc6:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	9c 01       	movw	r18, r24
    1fcc:	22 0f       	add	r18, r18
    1fce:	33 1f       	adc	r19, r19
    1fd0:	22 0f       	add	r18, r18
    1fd2:	33 1f       	adc	r19, r19
    1fd4:	22 0f       	add	r18, r18
    1fd6:	33 1f       	adc	r19, r19
    1fd8:	82 0f       	add	r24, r18
    1fda:	93 1f       	adc	r25, r19
    1fdc:	88 54       	subi	r24, 0x48	; 72
    1fde:	9c 4f       	sbci	r25, 0xFC	; 252
    1fe0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1fe2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1fe4:	28 17       	cp	r18, r24
    1fe6:	39 07       	cpc	r19, r25
    1fe8:	f9 f4       	brne	.+62     	; 0x2028 <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1fea:	ee 24       	eor	r14, r14
    1fec:	ff 24       	eor	r15, r15
    1fee:	68 94       	set
    1ff0:	e1 f8       	bld	r14, 1
    1ff2:	ec 0e       	add	r14, r28
    1ff4:	fd 1e       	adc	r15, r29
    1ff6:	c7 01       	movw	r24, r14
    1ff8:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1ffc:	8e 89       	ldd	r24, Y+22	; 0x16
    1ffe:	90 91 ae 03 	lds	r25, 0x03AE
    2002:	98 17       	cp	r25, r24
    2004:	10 f4       	brcc	.+4      	; 0x200a <vTaskPrioritySet+0xca>
    2006:	80 93 ae 03 	sts	0x03AE, r24
    200a:	90 e0       	ldi	r25, 0x00	; 0
    200c:	9c 01       	movw	r18, r24
    200e:	22 0f       	add	r18, r18
    2010:	33 1f       	adc	r19, r19
    2012:	22 0f       	add	r18, r18
    2014:	33 1f       	adc	r19, r19
    2016:	22 0f       	add	r18, r18
    2018:	33 1f       	adc	r19, r19
    201a:	82 0f       	add	r24, r18
    201c:	93 1f       	adc	r25, r19
    201e:	88 54       	subi	r24, 0x48	; 72
    2020:	9c 4f       	sbci	r25, 0xFC	; 252
    2022:	b7 01       	movw	r22, r14
    2024:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    2028:	11 23       	and	r17, r17
    202a:	11 f0       	breq	.+4      	; 0x2030 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    202c:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    2030:	0f 90       	pop	r0
    2032:	0f be       	out	0x3f, r0	; 63
	}
    2034:	df 91       	pop	r29
    2036:	cf 91       	pop	r28
    2038:	1f 91       	pop	r17
    203a:	ff 90       	pop	r15
    203c:	ef 90       	pop	r14
    203e:	08 95       	ret

00002040 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    204a:	00 97       	sbiw	r24, 0x00	; 0
    204c:	b9 f1       	breq	.+110    	; 0x20bc <vTaskResume+0x7c>
    204e:	80 91 a5 03 	lds	r24, 0x03A5
    2052:	90 91 a6 03 	lds	r25, 0x03A6
    2056:	c8 17       	cp	r28, r24
    2058:	d9 07       	cpc	r29, r25
    205a:	81 f1       	breq	.+96     	; 0x20bc <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2062:	ce 01       	movw	r24, r28
    2064:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <prvTaskIsTaskSuspended>
    2068:	88 23       	and	r24, r24
    206a:	31 f1       	breq	.+76     	; 0x20b8 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    206c:	8e 01       	movw	r16, r28
    206e:	0e 5f       	subi	r16, 0xFE	; 254
    2070:	1f 4f       	sbci	r17, 0xFF	; 255
    2072:	c8 01       	movw	r24, r16
    2074:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2078:	8e 89       	ldd	r24, Y+22	; 0x16
    207a:	90 91 ae 03 	lds	r25, 0x03AE
    207e:	98 17       	cp	r25, r24
    2080:	10 f4       	brcc	.+4      	; 0x2086 <vTaskResume+0x46>
    2082:	80 93 ae 03 	sts	0x03AE, r24
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	9c 01       	movw	r18, r24
    208a:	22 0f       	add	r18, r18
    208c:	33 1f       	adc	r19, r19
    208e:	22 0f       	add	r18, r18
    2090:	33 1f       	adc	r19, r19
    2092:	22 0f       	add	r18, r18
    2094:	33 1f       	adc	r19, r19
    2096:	82 0f       	add	r24, r18
    2098:	93 1f       	adc	r25, r19
    209a:	88 54       	subi	r24, 0x48	; 72
    209c:	9c 4f       	sbci	r25, 0xFC	; 252
    209e:	b8 01       	movw	r22, r16
    20a0:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20a4:	e0 91 a5 03 	lds	r30, 0x03A5
    20a8:	f0 91 a6 03 	lds	r31, 0x03A6
    20ac:	9e 89       	ldd	r25, Y+22	; 0x16
    20ae:	86 89       	ldd	r24, Z+22	; 0x16
    20b0:	98 17       	cp	r25, r24
    20b2:	10 f0       	brcs	.+4      	; 0x20b8 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    20b4:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    20b8:	0f 90       	pop	r0
    20ba:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    20bc:	df 91       	pop	r29
    20be:	cf 91       	pop	r28
    20c0:	1f 91       	pop	r17
    20c2:	0f 91       	pop	r16
    20c4:	08 95       	ret

000020c6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    20c6:	ef 92       	push	r14
    20c8:	ff 92       	push	r15
    20ca:	1f 93       	push	r17
    20cc:	cf 93       	push	r28
    20ce:	df 93       	push	r29
    20d0:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    20d2:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <prvTaskIsTaskSuspended>
    20d6:	88 23       	and	r24, r24
    20d8:	b9 f1       	breq	.+110    	; 0x2148 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    20da:	80 91 a7 03 	lds	r24, 0x03A7
    20de:	88 23       	and	r24, r24
    20e0:	51 f5       	brne	.+84     	; 0x2136 <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20e2:	e0 91 a5 03 	lds	r30, 0x03A5
    20e6:	f0 91 a6 03 	lds	r31, 0x03A6

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    20ea:	11 e0       	ldi	r17, 0x01	; 1
    20ec:	9e 89       	ldd	r25, Y+22	; 0x16
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	98 17       	cp	r25, r24
    20f2:	08 f4       	brcc	.+2      	; 0x20f6 <xTaskResumeFromISR+0x30>
    20f4:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    20f6:	ee 24       	eor	r14, r14
    20f8:	ff 24       	eor	r15, r15
    20fa:	68 94       	set
    20fc:	e1 f8       	bld	r14, 1
    20fe:	ec 0e       	add	r14, r28
    2100:	fd 1e       	adc	r15, r29
    2102:	c7 01       	movw	r24, r14
    2104:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2108:	8e 89       	ldd	r24, Y+22	; 0x16
    210a:	90 91 ae 03 	lds	r25, 0x03AE
    210e:	98 17       	cp	r25, r24
    2110:	10 f4       	brcc	.+4      	; 0x2116 <xTaskResumeFromISR+0x50>
    2112:	80 93 ae 03 	sts	0x03AE, r24
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	9c 01       	movw	r18, r24
    211a:	22 0f       	add	r18, r18
    211c:	33 1f       	adc	r19, r19
    211e:	22 0f       	add	r18, r18
    2120:	33 1f       	adc	r19, r19
    2122:	22 0f       	add	r18, r18
    2124:	33 1f       	adc	r19, r19
    2126:	82 0f       	add	r24, r18
    2128:	93 1f       	adc	r25, r19
    212a:	88 54       	subi	r24, 0x48	; 72
    212c:	9c 4f       	sbci	r25, 0xFC	; 252
    212e:	b7 01       	movw	r22, r14
    2130:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    2134:	0a c0       	rjmp	.+20     	; 0x214a <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2136:	be 01       	movw	r22, r28
    2138:	64 5f       	subi	r22, 0xF4	; 244
    213a:	7f 4f       	sbci	r23, 0xFF	; 255
    213c:	87 ef       	ldi	r24, 0xF7	; 247
    213e:	93 e0       	ldi	r25, 0x03	; 3
    2140:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    2144:	10 e0       	ldi	r17, 0x00	; 0
    2146:	01 c0       	rjmp	.+2      	; 0x214a <xTaskResumeFromISR+0x84>
    2148:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    214a:	81 2f       	mov	r24, r17
    214c:	df 91       	pop	r29
    214e:	cf 91       	pop	r28
    2150:	1f 91       	pop	r17
    2152:	ff 90       	pop	r15
    2154:	ef 90       	pop	r14
    2156:	08 95       	ret

00002158 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2158:	ef 92       	push	r14
    215a:	ff 92       	push	r15
    215c:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    215e:	81 e2       	ldi	r24, 0x21	; 33
    2160:	92 e1       	ldi	r25, 0x12	; 18
    2162:	66 e7       	ldi	r22, 0x76	; 118
    2164:	70 e0       	ldi	r23, 0x00	; 0
    2166:	48 ec       	ldi	r20, 0xC8	; 200
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	20 e0       	ldi	r18, 0x00	; 0
    216c:	30 e0       	ldi	r19, 0x00	; 0
    216e:	00 e0       	ldi	r16, 0x00	; 0
    2170:	0f 2e       	mov	r0, r31
    2172:	f2 e1       	ldi	r31, 0x12	; 18
    2174:	ef 2e       	mov	r14, r31
    2176:	f4 e0       	ldi	r31, 0x04	; 4
    2178:	ff 2e       	mov	r15, r31
    217a:	f0 2d       	mov	r31, r0
    217c:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2180:	81 30       	cpi	r24, 0x01	; 1
    2182:	81 f4       	brne	.+32     	; 0x21a4 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2184:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2186:	8f ef       	ldi	r24, 0xFF	; 255
    2188:	9f ef       	ldi	r25, 0xFF	; 255
    218a:	90 93 a9 03 	sts	0x03A9, r25
    218e:	80 93 a8 03 	sts	0x03A8, r24
		xSchedulerRunning = pdTRUE;
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	80 93 ad 03 	sts	0x03AD, r24
		xTickCount = ( TickType_t ) 0U;
    2198:	10 92 b0 03 	sts	0x03B0, r1
    219c:	10 92 af 03 	sts	0x03AF, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    21a0:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    21a4:	0f 91       	pop	r16
    21a6:	ff 90       	pop	r15
    21a8:	ef 90       	pop	r14
    21aa:	08 95       	ret

000021ac <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    21ac:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    21ae:	10 92 ad 03 	sts	0x03AD, r1
	vPortEndScheduler();
    21b2:	0e 94 92 08 	call	0x1124	; 0x1124 <vPortEndScheduler>
}
    21b6:	08 95       	ret

000021b8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    21b8:	80 91 a7 03 	lds	r24, 0x03A7
    21bc:	8f 5f       	subi	r24, 0xFF	; 255
    21be:	80 93 a7 03 	sts	0x03A7, r24
}
    21c2:	08 95       	ret

000021c4 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	f8 94       	cli
    21c8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    21ca:	80 91 af 03 	lds	r24, 0x03AF
    21ce:	90 91 b0 03 	lds	r25, 0x03B0
	}
	portTICK_TYPE_EXIT_CRITICAL();
    21d2:	0f 90       	pop	r0
    21d4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    21d6:	08 95       	ret

000021d8 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    21d8:	80 91 af 03 	lds	r24, 0x03AF
    21dc:	90 91 b0 03 	lds	r25, 0x03B0
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    21e0:	08 95       	ret

000021e2 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    21e2:	80 91 b1 03 	lds	r24, 0x03B1
}
    21e6:	08 95       	ret

000021e8 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    21e8:	00 97       	sbiw	r24, 0x00	; 0
    21ea:	21 f4       	brne	.+8      	; 0x21f4 <pcTaskGetName+0xc>
    21ec:	80 91 a5 03 	lds	r24, 0x03A5
    21f0:	90 91 a6 03 	lds	r25, 0x03A6
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    21f4:	49 96       	adiw	r24, 0x19	; 25
}
    21f6:	08 95       	ret

000021f8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    21f8:	cf 92       	push	r12
    21fa:	df 92       	push	r13
    21fc:	ef 92       	push	r14
    21fe:	ff 92       	push	r15
    2200:	0f 93       	push	r16
    2202:	1f 93       	push	r17
    2204:	cf 93       	push	r28
    2206:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2208:	80 91 a7 03 	lds	r24, 0x03A7
    220c:	88 23       	and	r24, r24
    220e:	09 f0       	breq	.+2      	; 0x2212 <xTaskIncrementTick+0x1a>
    2210:	82 c0       	rjmp	.+260    	; 0x2316 <xTaskIncrementTick+0x11e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    2212:	c0 90 af 03 	lds	r12, 0x03AF
    2216:	d0 90 b0 03 	lds	r13, 0x03B0
    221a:	08 94       	sec
    221c:	c1 1c       	adc	r12, r1
    221e:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    2220:	d0 92 b0 03 	sts	0x03B0, r13
    2224:	c0 92 af 03 	sts	0x03AF, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    2228:	c1 14       	cp	r12, r1
    222a:	d1 04       	cpc	r13, r1
    222c:	b9 f4       	brne	.+46     	; 0x225c <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    222e:	80 91 b5 03 	lds	r24, 0x03B5
    2232:	90 91 b6 03 	lds	r25, 0x03B6
    2236:	20 91 b3 03 	lds	r18, 0x03B3
    223a:	30 91 b4 03 	lds	r19, 0x03B4
    223e:	30 93 b6 03 	sts	0x03B6, r19
    2242:	20 93 b5 03 	sts	0x03B5, r18
    2246:	90 93 b4 03 	sts	0x03B4, r25
    224a:	80 93 b3 03 	sts	0x03B3, r24
    224e:	80 91 aa 03 	lds	r24, 0x03AA
    2252:	8f 5f       	subi	r24, 0xFF	; 255
    2254:	80 93 aa 03 	sts	0x03AA, r24
    2258:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    225c:	80 91 a8 03 	lds	r24, 0x03A8
    2260:	90 91 a9 03 	lds	r25, 0x03A9
    2264:	c8 16       	cp	r12, r24
    2266:	d9 06       	cpc	r13, r25
    2268:	20 f4       	brcc	.+8      	; 0x2272 <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    226a:	ff 24       	eor	r15, r15
    226c:	5a c0       	rjmp	.+180    	; 0x2322 <xTaskIncrementTick+0x12a>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    226e:	fe 2c       	mov	r15, r14
    2270:	03 c0       	rjmp	.+6      	; 0x2278 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2272:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    2274:	ee 24       	eor	r14, r14
    2276:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2278:	e0 91 b5 03 	lds	r30, 0x03B5
    227c:	f0 91 b6 03 	lds	r31, 0x03B6
    2280:	80 81       	ld	r24, Z
    2282:	88 23       	and	r24, r24
    2284:	39 f4       	brne	.+14     	; 0x2294 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2286:	8f ef       	ldi	r24, 0xFF	; 255
    2288:	9f ef       	ldi	r25, 0xFF	; 255
    228a:	90 93 a9 03 	sts	0x03A9, r25
    228e:	80 93 a8 03 	sts	0x03A8, r24
					break;
    2292:	47 c0       	rjmp	.+142    	; 0x2322 <xTaskIncrementTick+0x12a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2294:	e0 91 b5 03 	lds	r30, 0x03B5
    2298:	f0 91 b6 03 	lds	r31, 0x03B6
    229c:	05 80       	ldd	r0, Z+5	; 0x05
    229e:	f6 81       	ldd	r31, Z+6	; 0x06
    22a0:	e0 2d       	mov	r30, r0
    22a2:	c6 81       	ldd	r28, Z+6	; 0x06
    22a4:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    22a6:	8a 81       	ldd	r24, Y+2	; 0x02
    22a8:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    22aa:	c8 16       	cp	r12, r24
    22ac:	d9 06       	cpc	r13, r25
    22ae:	28 f4       	brcc	.+10     	; 0x22ba <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    22b0:	90 93 a9 03 	sts	0x03A9, r25
    22b4:	80 93 a8 03 	sts	0x03A8, r24
						break;
    22b8:	34 c0       	rjmp	.+104    	; 0x2322 <xTaskIncrementTick+0x12a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    22ba:	8e 01       	movw	r16, r28
    22bc:	0e 5f       	subi	r16, 0xFE	; 254
    22be:	1f 4f       	sbci	r17, 0xFF	; 255
    22c0:	c8 01       	movw	r24, r16
    22c2:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    22c6:	8c 89       	ldd	r24, Y+20	; 0x14
    22c8:	9d 89       	ldd	r25, Y+21	; 0x15
    22ca:	00 97       	sbiw	r24, 0x00	; 0
    22cc:	21 f0       	breq	.+8      	; 0x22d6 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    22ce:	ce 01       	movw	r24, r28
    22d0:	0c 96       	adiw	r24, 0x0c	; 12
    22d2:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    22d6:	8e 89       	ldd	r24, Y+22	; 0x16
    22d8:	90 91 ae 03 	lds	r25, 0x03AE
    22dc:	98 17       	cp	r25, r24
    22de:	10 f4       	brcc	.+4      	; 0x22e4 <xTaskIncrementTick+0xec>
    22e0:	80 93 ae 03 	sts	0x03AE, r24
    22e4:	90 e0       	ldi	r25, 0x00	; 0
    22e6:	9c 01       	movw	r18, r24
    22e8:	22 0f       	add	r18, r18
    22ea:	33 1f       	adc	r19, r19
    22ec:	22 0f       	add	r18, r18
    22ee:	33 1f       	adc	r19, r19
    22f0:	22 0f       	add	r18, r18
    22f2:	33 1f       	adc	r19, r19
    22f4:	82 0f       	add	r24, r18
    22f6:	93 1f       	adc	r25, r19
    22f8:	88 54       	subi	r24, 0x48	; 72
    22fa:	9c 4f       	sbci	r25, 0xFC	; 252
    22fc:	b8 01       	movw	r22, r16
    22fe:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2302:	e0 91 a5 03 	lds	r30, 0x03A5
    2306:	f0 91 a6 03 	lds	r31, 0x03A6
    230a:	9e 89       	ldd	r25, Y+22	; 0x16
    230c:	86 89       	ldd	r24, Z+22	; 0x16
    230e:	98 17       	cp	r25, r24
    2310:	08 f0       	brcs	.+2      	; 0x2314 <xTaskIncrementTick+0x11c>
    2312:	ad cf       	rjmp	.-166    	; 0x226e <xTaskIncrementTick+0x76>
    2314:	b1 cf       	rjmp	.-158    	; 0x2278 <xTaskIncrementTick+0x80>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2316:	80 91 ac 03 	lds	r24, 0x03AC
    231a:	8f 5f       	subi	r24, 0xFF	; 255
    231c:	80 93 ac 03 	sts	0x03AC, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2320:	ff 24       	eor	r15, r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2322:	80 91 ab 03 	lds	r24, 0x03AB
    2326:	88 23       	and	r24, r24
    2328:	11 f0       	breq	.+4      	; 0x232e <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
    232a:	ff 24       	eor	r15, r15
    232c:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    232e:	8f 2d       	mov	r24, r15
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	df 90       	pop	r13
    233e:	cf 90       	pop	r12
    2340:	08 95       	ret

00002342 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2342:	df 92       	push	r13
    2344:	ef 92       	push	r14
    2346:	ff 92       	push	r15
    2348:	0f 93       	push	r16
    234a:	1f 93       	push	r17
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2350:	0f b6       	in	r0, 0x3f	; 63
    2352:	f8 94       	cli
    2354:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2356:	80 91 a7 03 	lds	r24, 0x03A7
    235a:	81 50       	subi	r24, 0x01	; 1
    235c:	80 93 a7 03 	sts	0x03A7, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2360:	80 91 a7 03 	lds	r24, 0x03A7
    2364:	88 23       	and	r24, r24
    2366:	09 f0       	breq	.+2      	; 0x236a <xTaskResumeAll+0x28>
    2368:	5f c0       	rjmp	.+190    	; 0x2428 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    236a:	80 91 b1 03 	lds	r24, 0x03B1
    236e:	88 23       	and	r24, r24
    2370:	91 f5       	brne	.+100    	; 0x23d6 <xTaskResumeAll+0x94>
    2372:	5d c0       	rjmp	.+186    	; 0x242e <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2374:	e0 91 fc 03 	lds	r30, 0x03FC
    2378:	f0 91 fd 03 	lds	r31, 0x03FD
    237c:	c6 81       	ldd	r28, Z+6	; 0x06
    237e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2380:	ce 01       	movw	r24, r28
    2382:	0c 96       	adiw	r24, 0x0c	; 12
    2384:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2388:	8e 01       	movw	r16, r28
    238a:	0e 5f       	subi	r16, 0xFE	; 254
    238c:	1f 4f       	sbci	r17, 0xFF	; 255
    238e:	c8 01       	movw	r24, r16
    2390:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2394:	8e 89       	ldd	r24, Y+22	; 0x16
    2396:	90 91 ae 03 	lds	r25, 0x03AE
    239a:	98 17       	cp	r25, r24
    239c:	10 f4       	brcc	.+4      	; 0x23a2 <xTaskResumeAll+0x60>
    239e:	80 93 ae 03 	sts	0x03AE, r24
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	9c 01       	movw	r18, r24
    23a6:	22 0f       	add	r18, r18
    23a8:	33 1f       	adc	r19, r19
    23aa:	22 0f       	add	r18, r18
    23ac:	33 1f       	adc	r19, r19
    23ae:	22 0f       	add	r18, r18
    23b0:	33 1f       	adc	r19, r19
    23b2:	82 0f       	add	r24, r18
    23b4:	93 1f       	adc	r25, r19
    23b6:	88 54       	subi	r24, 0x48	; 72
    23b8:	9c 4f       	sbci	r25, 0xFC	; 252
    23ba:	b8 01       	movw	r22, r16
    23bc:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23c0:	e0 91 a5 03 	lds	r30, 0x03A5
    23c4:	f0 91 a6 03 	lds	r31, 0x03A6
    23c8:	9e 89       	ldd	r25, Y+22	; 0x16
    23ca:	86 89       	ldd	r24, Z+22	; 0x16
    23cc:	98 17       	cp	r25, r24
    23ce:	68 f0       	brcs	.+26     	; 0x23ea <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    23d0:	d0 92 ab 03 	sts	0x03AB, r13
    23d4:	0a c0       	rjmp	.+20     	; 0x23ea <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    23d6:	c0 e0       	ldi	r28, 0x00	; 0
    23d8:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    23da:	0f 2e       	mov	r0, r31
    23dc:	f7 ef       	ldi	r31, 0xF7	; 247
    23de:	ef 2e       	mov	r14, r31
    23e0:	f3 e0       	ldi	r31, 0x03	; 3
    23e2:	ff 2e       	mov	r15, r31
    23e4:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    23e6:	dd 24       	eor	r13, r13
    23e8:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    23ea:	f7 01       	movw	r30, r14
    23ec:	80 81       	ld	r24, Z
    23ee:	88 23       	and	r24, r24
    23f0:	09 f6       	brne	.-126    	; 0x2374 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    23f2:	20 97       	sbiw	r28, 0x00	; 0
    23f4:	11 f0       	breq	.+4      	; 0x23fa <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    23f6:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    23fa:	c0 91 ac 03 	lds	r28, 0x03AC

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    23fe:	cc 23       	and	r28, r28
    2400:	59 f0       	breq	.+22     	; 0x2418 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    2402:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2404:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <xTaskIncrementTick>
    2408:	88 23       	and	r24, r24
    240a:	11 f0       	breq	.+4      	; 0x2410 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    240c:	00 93 ab 03 	sts	0x03AB, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2410:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2412:	c1 f7       	brne	.-16     	; 0x2404 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    2414:	10 92 ac 03 	sts	0x03AC, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2418:	80 91 ab 03 	lds	r24, 0x03AB
    241c:	88 23       	and	r24, r24
    241e:	31 f0       	breq	.+12     	; 0x242c <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2420:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	03 c0       	rjmp	.+6      	; 0x242e <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    2428:	80 e0       	ldi	r24, 0x00	; 0
    242a:	01 c0       	rjmp	.+2      	; 0x242e <xTaskResumeAll+0xec>
    242c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    242e:	0f 90       	pop	r0
    2430:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	1f 91       	pop	r17
    2438:	0f 91       	pop	r16
    243a:	ff 90       	pop	r15
    243c:	ef 90       	pop	r14
    243e:	df 90       	pop	r13
    2440:	08 95       	ret

00002442 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2442:	00 e0       	ldi	r16, 0x00	; 0
    2444:	14 e0       	ldi	r17, 0x04	; 4

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2446:	0f 2e       	mov	r0, r31
    2448:	f8 eb       	ldi	r31, 0xB8	; 184
    244a:	ef 2e       	mov	r14, r31
    244c:	f3 e0       	ldi	r31, 0x03	; 3
    244e:	ff 2e       	mov	r15, r31
    2450:	f0 2d       	mov	r31, r0
    2452:	24 c0       	rjmp	.+72     	; 0x249c <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2454:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2458:	f8 01       	movw	r30, r16
    245a:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    245c:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2460:	cc 23       	and	r28, r28
    2462:	e1 f0       	breq	.+56     	; 0x249c <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2464:	0f b6       	in	r0, 0x3f	; 63
    2466:	f8 94       	cli
    2468:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    246a:	e0 91 05 04 	lds	r30, 0x0405
    246e:	f0 91 06 04 	lds	r31, 0x0406
    2472:	c6 81       	ldd	r28, Z+6	; 0x06
    2474:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2476:	ce 01       	movw	r24, r28
    2478:	02 96       	adiw	r24, 0x02	; 2
    247a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					--uxCurrentNumberOfTasks;
    247e:	80 91 b1 03 	lds	r24, 0x03B1
    2482:	81 50       	subi	r24, 0x01	; 1
    2484:	80 93 b1 03 	sts	0x03B1, r24
					--uxDeletedTasksWaitingCleanUp;
    2488:	80 91 b2 03 	lds	r24, 0x03B2
    248c:	81 50       	subi	r24, 0x01	; 1
    248e:	80 93 b2 03 	sts	0x03B2, r24
				}
				taskEXIT_CRITICAL();
    2492:	0f 90       	pop	r0
    2494:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2496:	ce 01       	movw	r24, r28
    2498:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    249c:	80 91 b2 03 	lds	r24, 0x03B2
    24a0:	88 23       	and	r24, r24
    24a2:	c1 f6       	brne	.-80     	; 0x2454 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    24a4:	f7 01       	movw	r30, r14
    24a6:	80 81       	ld	r24, Z
    24a8:	82 30       	cpi	r24, 0x02	; 2
    24aa:	c0 f3       	brcs	.-16     	; 0x249c <prvIdleTask+0x5a>
			{
				taskYIELD();
    24ac:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    24b0:	f5 cf       	rjmp	.-22     	; 0x249c <prvIdleTask+0x5a>

000024b2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    24b2:	cf 93       	push	r28
    24b4:	df 93       	push	r29
    24b6:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    24b8:	00 97       	sbiw	r24, 0x00	; 0
    24ba:	51 f0       	breq	.+20     	; 0x24d0 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    24bc:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    24c0:	ce 01       	movw	r24, r28
    24c2:	60 e0       	ldi	r22, 0x00	; 0
    24c4:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24c8:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24cc:	88 23       	and	r24, r24
    24ce:	11 f4       	brne	.+4      	; 0x24d4 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    24d0:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	08 95       	ret

000024da <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    24da:	0f 93       	push	r16
    24dc:	1f 93       	push	r17
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	8c 01       	movw	r16, r24
    24e4:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    24e6:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    24ea:	80 91 af 03 	lds	r24, 0x03AF
    24ee:	90 91 b0 03 	lds	r25, 0x03B0

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    24f2:	f8 01       	movw	r30, r16
    24f4:	20 81       	ld	r18, Z
    24f6:	31 81       	ldd	r19, Z+1	; 0x01
    24f8:	c2 0f       	add	r28, r18
    24fa:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    24fc:	82 17       	cp	r24, r18
    24fe:	93 07       	cpc	r25, r19
    2500:	48 f4       	brcc	.+18     	; 0x2514 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2502:	c2 17       	cp	r28, r18
    2504:	d3 07       	cpc	r29, r19
    2506:	f8 f4       	brcc	.+62     	; 0x2546 <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2508:	d1 83       	std	Z+1, r29	; 0x01
    250a:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    250c:	8c 17       	cp	r24, r28
    250e:	9d 07       	cpc	r25, r29
    2510:	78 f4       	brcc	.+30     	; 0x2530 <vTaskDelayUntil+0x56>
    2512:	07 c0       	rjmp	.+14     	; 0x2522 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2514:	c2 17       	cp	r28, r18
    2516:	d3 07       	cpc	r29, r19
    2518:	90 f0       	brcs	.+36     	; 0x253e <vTaskDelayUntil+0x64>
    251a:	8c 17       	cp	r24, r28
    251c:	9d 07       	cpc	r25, r29
    251e:	78 f0       	brcs	.+30     	; 0x253e <vTaskDelayUntil+0x64>
    2520:	12 c0       	rjmp	.+36     	; 0x2546 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2522:	9e 01       	movw	r18, r28
    2524:	28 1b       	sub	r18, r24
    2526:	39 0b       	sbc	r19, r25
    2528:	c9 01       	movw	r24, r18
    252a:	60 e0       	ldi	r22, 0x00	; 0
    252c:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2530:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2534:	88 23       	and	r24, r24
    2536:	59 f4       	brne	.+22     	; 0x254e <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    2538:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    253c:	08 c0       	rjmp	.+16     	; 0x254e <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    253e:	f8 01       	movw	r30, r16
    2540:	d1 83       	std	Z+1, r29	; 0x01
    2542:	c0 83       	st	Z, r28
    2544:	ee cf       	rjmp	.-36     	; 0x2522 <vTaskDelayUntil+0x48>
    2546:	f8 01       	movw	r30, r16
    2548:	d1 83       	std	Z+1, r29	; 0x01
    254a:	c0 83       	st	Z, r28
    254c:	f1 cf       	rjmp	.-30     	; 0x2530 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    254e:	df 91       	pop	r29
    2550:	cf 91       	pop	r28
    2552:	1f 91       	pop	r17
    2554:	0f 91       	pop	r16
    2556:	08 95       	ret

00002558 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2558:	80 91 a7 03 	lds	r24, 0x03A7
    255c:	88 23       	and	r24, r24
    255e:	21 f0       	breq	.+8      	; 0x2568 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	80 93 ab 03 	sts	0x03AB, r24
    2566:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2568:	10 92 ab 03 	sts	0x03AB, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    256c:	20 91 ae 03 	lds	r18, 0x03AE
    2570:	82 2f       	mov	r24, r18
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	fc 01       	movw	r30, r24
    2576:	ee 0f       	add	r30, r30
    2578:	ff 1f       	adc	r31, r31
    257a:	ee 0f       	add	r30, r30
    257c:	ff 1f       	adc	r31, r31
    257e:	ee 0f       	add	r30, r30
    2580:	ff 1f       	adc	r31, r31
    2582:	e8 0f       	add	r30, r24
    2584:	f9 1f       	adc	r31, r25
    2586:	e8 54       	subi	r30, 0x48	; 72
    2588:	fc 4f       	sbci	r31, 0xFC	; 252
    258a:	30 81       	ld	r19, Z
    258c:	33 23       	and	r19, r19
    258e:	89 f4       	brne	.+34     	; 0x25b2 <vTaskSwitchContext+0x5a>
    2590:	21 50       	subi	r18, 0x01	; 1
    2592:	82 2f       	mov	r24, r18
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	fc 01       	movw	r30, r24
    2598:	ee 0f       	add	r30, r30
    259a:	ff 1f       	adc	r31, r31
    259c:	ee 0f       	add	r30, r30
    259e:	ff 1f       	adc	r31, r31
    25a0:	ee 0f       	add	r30, r30
    25a2:	ff 1f       	adc	r31, r31
    25a4:	e8 0f       	add	r30, r24
    25a6:	f9 1f       	adc	r31, r25
    25a8:	e8 54       	subi	r30, 0x48	; 72
    25aa:	fc 4f       	sbci	r31, 0xFC	; 252
    25ac:	30 81       	ld	r19, Z
    25ae:	33 23       	and	r19, r19
    25b0:	79 f3       	breq	.-34     	; 0x2590 <vTaskSwitchContext+0x38>
    25b2:	dc 01       	movw	r26, r24
    25b4:	aa 0f       	add	r26, r26
    25b6:	bb 1f       	adc	r27, r27
    25b8:	aa 0f       	add	r26, r26
    25ba:	bb 1f       	adc	r27, r27
    25bc:	aa 0f       	add	r26, r26
    25be:	bb 1f       	adc	r27, r27
    25c0:	8a 0f       	add	r24, r26
    25c2:	9b 1f       	adc	r25, r27
    25c4:	dc 01       	movw	r26, r24
    25c6:	a8 54       	subi	r26, 0x48	; 72
    25c8:	bc 4f       	sbci	r27, 0xFC	; 252
    25ca:	11 96       	adiw	r26, 0x01	; 1
    25cc:	ed 91       	ld	r30, X+
    25ce:	fc 91       	ld	r31, X
    25d0:	12 97       	sbiw	r26, 0x02	; 2
    25d2:	02 80       	ldd	r0, Z+2	; 0x02
    25d4:	f3 81       	ldd	r31, Z+3	; 0x03
    25d6:	e0 2d       	mov	r30, r0
    25d8:	12 96       	adiw	r26, 0x02	; 2
    25da:	fc 93       	st	X, r31
    25dc:	ee 93       	st	-X, r30
    25de:	11 97       	sbiw	r26, 0x01	; 1
    25e0:	cd 01       	movw	r24, r26
    25e2:	03 96       	adiw	r24, 0x03	; 3
    25e4:	e8 17       	cp	r30, r24
    25e6:	f9 07       	cpc	r31, r25
    25e8:	31 f4       	brne	.+12     	; 0x25f6 <vTaskSwitchContext+0x9e>
    25ea:	82 81       	ldd	r24, Z+2	; 0x02
    25ec:	93 81       	ldd	r25, Z+3	; 0x03
    25ee:	12 96       	adiw	r26, 0x02	; 2
    25f0:	9c 93       	st	X, r25
    25f2:	8e 93       	st	-X, r24
    25f4:	11 97       	sbiw	r26, 0x01	; 1
    25f6:	11 96       	adiw	r26, 0x01	; 1
    25f8:	ed 91       	ld	r30, X+
    25fa:	fc 91       	ld	r31, X
    25fc:	12 97       	sbiw	r26, 0x02	; 2
    25fe:	86 81       	ldd	r24, Z+6	; 0x06
    2600:	97 81       	ldd	r25, Z+7	; 0x07
    2602:	90 93 a6 03 	sts	0x03A6, r25
    2606:	80 93 a5 03 	sts	0x03A5, r24
    260a:	20 93 ae 03 	sts	0x03AE, r18
    260e:	08 95       	ret

00002610 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2610:	0f 93       	push	r16
    2612:	1f 93       	push	r17
    2614:	cf 93       	push	r28
    2616:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	f8 94       	cli
    261c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    261e:	00 97       	sbiw	r24, 0x00	; 0
    2620:	29 f4       	brne	.+10     	; 0x262c <vTaskSuspend+0x1c>
    2622:	00 91 a5 03 	lds	r16, 0x03A5
    2626:	10 91 a6 03 	lds	r17, 0x03A6
    262a:	01 c0       	rjmp	.+2      	; 0x262e <vTaskSuspend+0x1e>
    262c:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    262e:	e8 01       	movw	r28, r16
    2630:	22 96       	adiw	r28, 0x02	; 2
    2632:	ce 01       	movw	r24, r28
    2634:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2638:	f8 01       	movw	r30, r16
    263a:	84 89       	ldd	r24, Z+20	; 0x14
    263c:	95 89       	ldd	r25, Z+21	; 0x15
    263e:	00 97       	sbiw	r24, 0x00	; 0
    2640:	21 f0       	breq	.+8      	; 0x264a <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2642:	c8 01       	movw	r24, r16
    2644:	0c 96       	adiw	r24, 0x0c	; 12
    2646:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    264a:	89 e0       	ldi	r24, 0x09	; 9
    264c:	94 e0       	ldi	r25, 0x04	; 4
    264e:	be 01       	movw	r22, r28
    2650:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2654:	0f 90       	pop	r0
    2656:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    2658:	80 91 ad 03 	lds	r24, 0x03AD
    265c:	88 23       	and	r24, r24
    265e:	39 f0       	breq	.+14     	; 0x266e <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	f8 94       	cli
    2664:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    2666:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    266a:	0f 90       	pop	r0
    266c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    266e:	80 91 a5 03 	lds	r24, 0x03A5
    2672:	90 91 a6 03 	lds	r25, 0x03A6
    2676:	08 17       	cp	r16, r24
    2678:	19 07       	cpc	r17, r25
    267a:	a1 f4       	brne	.+40     	; 0x26a4 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    267c:	80 91 ad 03 	lds	r24, 0x03AD
    2680:	88 23       	and	r24, r24
    2682:	19 f0       	breq	.+6      	; 0x268a <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2684:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    2688:	0d c0       	rjmp	.+26     	; 0x26a4 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    268a:	80 91 b1 03 	lds	r24, 0x03B1
    268e:	90 91 09 04 	lds	r25, 0x0409
    2692:	98 17       	cp	r25, r24
    2694:	29 f4       	brne	.+10     	; 0x26a0 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2696:	10 92 a6 03 	sts	0x03A6, r1
    269a:	10 92 a5 03 	sts	0x03A5, r1
    269e:	02 c0       	rjmp	.+4      	; 0x26a4 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    26a0:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    26a4:	df 91       	pop	r29
    26a6:	cf 91       	pop	r28
    26a8:	1f 91       	pop	r17
    26aa:	0f 91       	pop	r16
    26ac:	08 95       	ret

000026ae <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
    26b2:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26b4:	60 91 a5 03 	lds	r22, 0x03A5
    26b8:	70 91 a6 03 	lds	r23, 0x03A6
    26bc:	64 5f       	subi	r22, 0xF4	; 244
    26be:	7f 4f       	sbci	r23, 0xFF	; 255
    26c0:	0e 94 1b 07 	call	0xe36	; 0xe36 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    26c4:	ce 01       	movw	r24, r28
    26c6:	61 e0       	ldi	r22, 0x01	; 1
    26c8:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>
}
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
    26d0:	08 95       	ret

000026d2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    26d8:	e0 91 a5 03 	lds	r30, 0x03A5
    26dc:	f0 91 a6 03 	lds	r31, 0x03A6
    26e0:	70 68       	ori	r23, 0x80	; 128
    26e2:	75 87       	std	Z+13, r23	; 0x0d
    26e4:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26e6:	60 91 a5 03 	lds	r22, 0x03A5
    26ea:	70 91 a6 03 	lds	r23, 0x03A6
    26ee:	64 5f       	subi	r22, 0xF4	; 244
    26f0:	7f 4f       	sbci	r23, 0xFF	; 255
    26f2:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    26f6:	ce 01       	movw	r24, r28
    26f8:	61 e0       	ldi	r22, 0x01	; 1
    26fa:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>
}
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	08 95       	ret

00002704 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2704:	0f 93       	push	r16
    2706:	1f 93       	push	r17
    2708:	cf 93       	push	r28
    270a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    270c:	dc 01       	movw	r26, r24
    270e:	15 96       	adiw	r26, 0x05	; 5
    2710:	ed 91       	ld	r30, X+
    2712:	fc 91       	ld	r31, X
    2714:	16 97       	sbiw	r26, 0x06	; 6
    2716:	06 81       	ldd	r16, Z+6	; 0x06
    2718:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    271a:	e8 01       	movw	r28, r16
    271c:	2c 96       	adiw	r28, 0x0c	; 12
    271e:	ce 01       	movw	r24, r28
    2720:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2724:	80 91 a7 03 	lds	r24, 0x03A7
    2728:	88 23       	and	r24, r24
    272a:	e9 f4       	brne	.+58     	; 0x2766 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    272c:	e8 01       	movw	r28, r16
    272e:	22 96       	adiw	r28, 0x02	; 2
    2730:	ce 01       	movw	r24, r28
    2732:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2736:	f8 01       	movw	r30, r16
    2738:	86 89       	ldd	r24, Z+22	; 0x16
    273a:	90 91 ae 03 	lds	r25, 0x03AE
    273e:	98 17       	cp	r25, r24
    2740:	10 f4       	brcc	.+4      	; 0x2746 <xTaskRemoveFromEventList+0x42>
    2742:	80 93 ae 03 	sts	0x03AE, r24
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	9c 01       	movw	r18, r24
    274a:	22 0f       	add	r18, r18
    274c:	33 1f       	adc	r19, r19
    274e:	22 0f       	add	r18, r18
    2750:	33 1f       	adc	r19, r19
    2752:	22 0f       	add	r18, r18
    2754:	33 1f       	adc	r19, r19
    2756:	82 0f       	add	r24, r18
    2758:	93 1f       	adc	r25, r19
    275a:	88 54       	subi	r24, 0x48	; 72
    275c:	9c 4f       	sbci	r25, 0xFC	; 252
    275e:	be 01       	movw	r22, r28
    2760:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    2764:	05 c0       	rjmp	.+10     	; 0x2770 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2766:	87 ef       	ldi	r24, 0xF7	; 247
    2768:	93 e0       	ldi	r25, 0x03	; 3
    276a:	be 01       	movw	r22, r28
    276c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2770:	e0 91 a5 03 	lds	r30, 0x03A5
    2774:	f0 91 a6 03 	lds	r31, 0x03A6
    2778:	d8 01       	movw	r26, r16
    277a:	56 96       	adiw	r26, 0x16	; 22
    277c:	9c 91       	ld	r25, X
    277e:	56 97       	sbiw	r26, 0x16	; 22
    2780:	86 89       	ldd	r24, Z+22	; 0x16
    2782:	89 17       	cp	r24, r25
    2784:	20 f4       	brcc	.+8      	; 0x278e <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	80 93 ab 03 	sts	0x03AB, r24
    278c:	01 c0       	rjmp	.+2      	; 0x2790 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    278e:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    2790:	df 91       	pop	r29
    2792:	cf 91       	pop	r28
    2794:	1f 91       	pop	r17
    2796:	0f 91       	pop	r16
    2798:	08 95       	ret

0000279a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    279a:	0f 93       	push	r16
    279c:	1f 93       	push	r17
    279e:	cf 93       	push	r28
    27a0:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    27a2:	70 68       	ori	r23, 0x80	; 128
    27a4:	fc 01       	movw	r30, r24
    27a6:	71 83       	std	Z+1, r23	; 0x01
    27a8:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    27aa:	c6 81       	ldd	r28, Z+6	; 0x06
    27ac:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    27ae:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    27b2:	8e 01       	movw	r16, r28
    27b4:	0e 5f       	subi	r16, 0xFE	; 254
    27b6:	1f 4f       	sbci	r17, 0xFF	; 255
    27b8:	c8 01       	movw	r24, r16
    27ba:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    27be:	8e 89       	ldd	r24, Y+22	; 0x16
    27c0:	90 91 ae 03 	lds	r25, 0x03AE
    27c4:	98 17       	cp	r25, r24
    27c6:	10 f4       	brcc	.+4      	; 0x27cc <xTaskRemoveFromUnorderedEventList+0x32>
    27c8:	80 93 ae 03 	sts	0x03AE, r24
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	9c 01       	movw	r18, r24
    27d0:	22 0f       	add	r18, r18
    27d2:	33 1f       	adc	r19, r19
    27d4:	22 0f       	add	r18, r18
    27d6:	33 1f       	adc	r19, r19
    27d8:	22 0f       	add	r18, r18
    27da:	33 1f       	adc	r19, r19
    27dc:	82 0f       	add	r24, r18
    27de:	93 1f       	adc	r25, r19
    27e0:	88 54       	subi	r24, 0x48	; 72
    27e2:	9c 4f       	sbci	r25, 0xFC	; 252
    27e4:	b8 01       	movw	r22, r16
    27e6:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    27ea:	e0 91 a5 03 	lds	r30, 0x03A5
    27ee:	f0 91 a6 03 	lds	r31, 0x03A6
    27f2:	9e 89       	ldd	r25, Y+22	; 0x16
    27f4:	86 89       	ldd	r24, Z+22	; 0x16
    27f6:	89 17       	cp	r24, r25
    27f8:	20 f4       	brcc	.+8      	; 0x2802 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	80 93 ab 03 	sts	0x03AB, r24
    2800:	01 c0       	rjmp	.+2      	; 0x2804 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    2802:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	1f 91       	pop	r17
    280a:	0f 91       	pop	r16
    280c:	08 95       	ret

0000280e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    280e:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2810:	80 91 aa 03 	lds	r24, 0x03AA
    2814:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2816:	80 91 af 03 	lds	r24, 0x03AF
    281a:	90 91 b0 03 	lds	r25, 0x03B0
    281e:	92 83       	std	Z+2, r25	; 0x02
    2820:	81 83       	std	Z+1, r24	; 0x01
}
    2822:	08 95       	ret

00002824 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2824:	fc 01       	movw	r30, r24
    2826:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2828:	0f b6       	in	r0, 0x3f	; 63
    282a:	f8 94       	cli
    282c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    282e:	60 91 af 03 	lds	r22, 0x03AF
    2832:	70 91 b0 03 	lds	r23, 0x03B0
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    2836:	4d 91       	ld	r20, X+
    2838:	5c 91       	ld	r21, X
    283a:	11 97       	sbiw	r26, 0x01	; 1
    283c:	8f ef       	ldi	r24, 0xFF	; 255
    283e:	4f 3f       	cpi	r20, 0xFF	; 255
    2840:	58 07       	cpc	r21, r24
    2842:	e9 f0       	breq	.+58     	; 0x287e <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2844:	80 91 aa 03 	lds	r24, 0x03AA
    2848:	90 81       	ld	r25, Z
    284a:	98 17       	cp	r25, r24
    284c:	29 f0       	breq	.+10     	; 0x2858 <xTaskCheckForTimeOut+0x34>
    284e:	81 81       	ldd	r24, Z+1	; 0x01
    2850:	92 81       	ldd	r25, Z+2	; 0x02
    2852:	68 17       	cp	r22, r24
    2854:	79 07       	cpc	r23, r25
    2856:	a8 f4       	brcc	.+42     	; 0x2882 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2858:	81 81       	ldd	r24, Z+1	; 0x01
    285a:	92 81       	ldd	r25, Z+2	; 0x02
    285c:	9b 01       	movw	r18, r22
    285e:	28 1b       	sub	r18, r24
    2860:	39 0b       	sbc	r19, r25
    2862:	24 17       	cp	r18, r20
    2864:	35 07       	cpc	r19, r21
    2866:	78 f4       	brcc	.+30     	; 0x2886 <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    2868:	86 1b       	sub	r24, r22
    286a:	97 0b       	sbc	r25, r23
    286c:	84 0f       	add	r24, r20
    286e:	95 1f       	adc	r25, r21
    2870:	8d 93       	st	X+, r24
    2872:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2874:	cf 01       	movw	r24, r30
    2876:	0e 94 07 14 	call	0x280e	; 0x280e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    287a:	80 e0       	ldi	r24, 0x00	; 0
    287c:	05 c0       	rjmp	.+10     	; 0x2888 <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    287e:	80 e0       	ldi	r24, 0x00	; 0
    2880:	03 c0       	rjmp	.+6      	; 0x2888 <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	01 c0       	rjmp	.+2      	; 0x2888 <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2886:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2888:	0f 90       	pop	r0
    288a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    288c:	08 95       	ret

0000288e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    288e:	81 e0       	ldi	r24, 0x01	; 1
    2890:	80 93 ab 03 	sts	0x03AB, r24
}
    2894:	08 95       	ret

00002896 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2896:	80 91 a5 03 	lds	r24, 0x03A5
    289a:	90 91 a6 03 	lds	r25, 0x03A6

		return xReturn;
	}
    289e:	08 95       	ret

000028a0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    28a0:	0f 93       	push	r16
    28a2:	1f 93       	push	r17
    28a4:	cf 93       	push	r28
    28a6:	df 93       	push	r29
    28a8:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    28aa:	00 97       	sbiw	r24, 0x00	; 0
    28ac:	09 f4       	brne	.+2      	; 0x28b0 <vTaskPriorityInherit+0x10>
    28ae:	51 c0       	rjmp	.+162    	; 0x2952 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    28b0:	8e 89       	ldd	r24, Y+22	; 0x16
    28b2:	e0 91 a5 03 	lds	r30, 0x03A5
    28b6:	f0 91 a6 03 	lds	r31, 0x03A6
    28ba:	96 89       	ldd	r25, Z+22	; 0x16
    28bc:	89 17       	cp	r24, r25
    28be:	08 f0       	brcs	.+2      	; 0x28c2 <vTaskPriorityInherit+0x22>
    28c0:	48 c0       	rjmp	.+144    	; 0x2952 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    28c2:	2c 85       	ldd	r18, Y+12	; 0x0c
    28c4:	3d 85       	ldd	r19, Y+13	; 0x0d
    28c6:	33 23       	and	r19, r19
    28c8:	5c f0       	brlt	.+22     	; 0x28e0 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    28ca:	e0 91 a5 03 	lds	r30, 0x03A5
    28ce:	f0 91 a6 03 	lds	r31, 0x03A6
    28d2:	96 89       	ldd	r25, Z+22	; 0x16
    28d4:	25 e0       	ldi	r18, 0x05	; 5
    28d6:	30 e0       	ldi	r19, 0x00	; 0
    28d8:	29 1b       	sub	r18, r25
    28da:	31 09       	sbc	r19, r1
    28dc:	3d 87       	std	Y+13, r19	; 0x0d
    28de:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	9c 01       	movw	r18, r24
    28e4:	22 0f       	add	r18, r18
    28e6:	33 1f       	adc	r19, r19
    28e8:	22 0f       	add	r18, r18
    28ea:	33 1f       	adc	r19, r19
    28ec:	22 0f       	add	r18, r18
    28ee:	33 1f       	adc	r19, r19
    28f0:	82 0f       	add	r24, r18
    28f2:	93 1f       	adc	r25, r19
    28f4:	88 54       	subi	r24, 0x48	; 72
    28f6:	9c 4f       	sbci	r25, 0xFC	; 252
    28f8:	2a 85       	ldd	r18, Y+10	; 0x0a
    28fa:	3b 85       	ldd	r19, Y+11	; 0x0b
    28fc:	28 17       	cp	r18, r24
    28fe:	39 07       	cpc	r19, r25
    2900:	11 f5       	brne	.+68     	; 0x2946 <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2902:	8e 01       	movw	r16, r28
    2904:	0e 5f       	subi	r16, 0xFE	; 254
    2906:	1f 4f       	sbci	r17, 0xFF	; 255
    2908:	c8 01       	movw	r24, r16
    290a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    290e:	e0 91 a5 03 	lds	r30, 0x03A5
    2912:	f0 91 a6 03 	lds	r31, 0x03A6
    2916:	86 89       	ldd	r24, Z+22	; 0x16
    2918:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    291a:	90 91 ae 03 	lds	r25, 0x03AE
    291e:	98 17       	cp	r25, r24
    2920:	10 f4       	brcc	.+4      	; 0x2926 <vTaskPriorityInherit+0x86>
    2922:	80 93 ae 03 	sts	0x03AE, r24
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	9c 01       	movw	r18, r24
    292a:	22 0f       	add	r18, r18
    292c:	33 1f       	adc	r19, r19
    292e:	22 0f       	add	r18, r18
    2930:	33 1f       	adc	r19, r19
    2932:	22 0f       	add	r18, r18
    2934:	33 1f       	adc	r19, r19
    2936:	82 0f       	add	r24, r18
    2938:	93 1f       	adc	r25, r19
    293a:	88 54       	subi	r24, 0x48	; 72
    293c:	9c 4f       	sbci	r25, 0xFC	; 252
    293e:	b8 01       	movw	r22, r16
    2940:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    2944:	06 c0       	rjmp	.+12     	; 0x2952 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2946:	e0 91 a5 03 	lds	r30, 0x03A5
    294a:	f0 91 a6 03 	lds	r31, 0x03A6
    294e:	86 89       	ldd	r24, Z+22	; 0x16
    2950:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2952:	df 91       	pop	r29
    2954:	cf 91       	pop	r28
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	08 95       	ret

0000295c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    295c:	0f 93       	push	r16
    295e:	1f 93       	push	r17
    2960:	cf 93       	push	r28
    2962:	df 93       	push	r29
    2964:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2966:	00 97       	sbiw	r24, 0x00	; 0
    2968:	81 f1       	breq	.+96     	; 0x29ca <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    296a:	8c a1       	lds	r24, 0x4c
    296c:	81 50       	subi	r24, 0x01	; 1
    296e:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2970:	2e 89       	ldd	r18, Y+22	; 0x16
    2972:	9b a1       	lds	r25, 0x4b
    2974:	29 17       	cp	r18, r25
    2976:	59 f1       	breq	.+86     	; 0x29ce <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2978:	88 23       	and	r24, r24
    297a:	59 f5       	brne	.+86     	; 0x29d2 <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    297c:	8e 01       	movw	r16, r28
    297e:	0e 5f       	subi	r16, 0xFE	; 254
    2980:	1f 4f       	sbci	r17, 0xFF	; 255
    2982:	c8 01       	movw	r24, r16
    2984:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2988:	4b a1       	lds	r20, 0x4b
    298a:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    298c:	24 2f       	mov	r18, r20
    298e:	30 e0       	ldi	r19, 0x00	; 0
    2990:	85 e0       	ldi	r24, 0x05	; 5
    2992:	90 e0       	ldi	r25, 0x00	; 0
    2994:	82 1b       	sub	r24, r18
    2996:	93 0b       	sbc	r25, r19
    2998:	9d 87       	std	Y+13, r25	; 0x0d
    299a:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    299c:	80 91 ae 03 	lds	r24, 0x03AE
    29a0:	84 17       	cp	r24, r20
    29a2:	10 f4       	brcc	.+4      	; 0x29a8 <xTaskPriorityDisinherit+0x4c>
    29a4:	40 93 ae 03 	sts	0x03AE, r20
    29a8:	c9 01       	movw	r24, r18
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	88 0f       	add	r24, r24
    29b4:	99 1f       	adc	r25, r25
    29b6:	28 0f       	add	r18, r24
    29b8:	39 1f       	adc	r19, r25
    29ba:	c9 01       	movw	r24, r18
    29bc:	88 54       	subi	r24, 0x48	; 72
    29be:	9c 4f       	sbci	r25, 0xFC	; 252
    29c0:	b8 01       	movw	r22, r16
    29c2:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	05 c0       	rjmp	.+10     	; 0x29d4 <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    29ca:	80 e0       	ldi	r24, 0x00	; 0
    29cc:	03 c0       	rjmp	.+6      	; 0x29d4 <xTaskPriorityDisinherit+0x78>
    29ce:	80 e0       	ldi	r24, 0x00	; 0
    29d0:	01 c0       	rjmp	.+2      	; 0x29d4 <xTaskPriorityDisinherit+0x78>
    29d2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    29d4:	df 91       	pop	r29
    29d6:	cf 91       	pop	r28
    29d8:	1f 91       	pop	r17
    29da:	0f 91       	pop	r16
    29dc:	08 95       	ret

000029de <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    29de:	e0 91 a5 03 	lds	r30, 0x03A5
    29e2:	f0 91 a6 03 	lds	r31, 0x03A6
    29e6:	84 85       	ldd	r24, Z+12	; 0x0c
    29e8:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    29ea:	e0 91 a5 03 	lds	r30, 0x03A5
    29ee:	f0 91 a6 03 	lds	r31, 0x03A6
    29f2:	a0 91 a5 03 	lds	r26, 0x03A5
    29f6:	b0 91 a6 03 	lds	r27, 0x03A6
    29fa:	56 96       	adiw	r26, 0x16	; 22
    29fc:	4c 91       	ld	r20, X
    29fe:	56 97       	sbiw	r26, 0x16	; 22
    2a00:	25 e0       	ldi	r18, 0x05	; 5
    2a02:	30 e0       	ldi	r19, 0x00	; 0
    2a04:	24 1b       	sub	r18, r20
    2a06:	31 09       	sbc	r19, r1
    2a08:	35 87       	std	Z+13, r19	; 0x0d
    2a0a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2a0c:	08 95       	ret

00002a0e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2a0e:	80 91 a5 03 	lds	r24, 0x03A5
    2a12:	90 91 a6 03 	lds	r25, 0x03A6
    2a16:	00 97       	sbiw	r24, 0x00	; 0
    2a18:	39 f0       	breq	.+14     	; 0x2a28 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2a1a:	e0 91 a5 03 	lds	r30, 0x03A5
    2a1e:	f0 91 a6 03 	lds	r31, 0x03A6
    2a22:	84 a1       	lds	r24, 0x44
    2a24:	8f 5f       	subi	r24, 0xFF	; 255
    2a26:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    2a28:	80 91 a5 03 	lds	r24, 0x03A5
    2a2c:	90 91 a6 03 	lds	r25, 0x03A6
	}
    2a30:	08 95       	ret

00002a32 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2a32:	0f 93       	push	r16
    2a34:	1f 93       	push	r17
    2a36:	cf 93       	push	r28
    2a38:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2a3a:	0f b6       	in	r0, 0x3f	; 63
    2a3c:	f8 94       	cli
    2a3e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2a40:	e0 91 a5 03 	lds	r30, 0x03A5
    2a44:	f0 91 a6 03 	lds	r31, 0x03A6
    2a48:	85 a1       	lds	r24, 0x45
    2a4a:	96 a1       	lds	r25, 0x46
    2a4c:	a7 a1       	lds	r26, 0x47
    2a4e:	b0 a5       	lds	r27, 0x60
    2a50:	00 97       	sbiw	r24, 0x00	; 0
    2a52:	a1 05       	cpc	r26, r1
    2a54:	b1 05       	cpc	r27, r1
    2a56:	79 f4       	brne	.+30     	; 0x2a76 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2a58:	e0 91 a5 03 	lds	r30, 0x03A5
    2a5c:	f0 91 a6 03 	lds	r31, 0x03A6
    2a60:	81 e0       	ldi	r24, 0x01	; 1
    2a62:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2a64:	61 15       	cp	r22, r1
    2a66:	71 05       	cpc	r23, r1
    2a68:	31 f0       	breq	.+12     	; 0x2a76 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2a6a:	cb 01       	movw	r24, r22
    2a6c:	61 e0       	ldi	r22, 0x01	; 1
    2a6e:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2a72:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2a76:	0f 90       	pop	r0
    2a78:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2a7a:	0f b6       	in	r0, 0x3f	; 63
    2a7c:	f8 94       	cli
    2a7e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2a80:	e0 91 a5 03 	lds	r30, 0x03A5
    2a84:	f0 91 a6 03 	lds	r31, 0x03A6
    2a88:	05 a1       	lds	r16, 0x45
    2a8a:	16 a1       	lds	r17, 0x46
    2a8c:	27 a1       	lds	r18, 0x47
    2a8e:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    2a90:	01 15       	cp	r16, r1
    2a92:	11 05       	cpc	r17, r1
    2a94:	21 05       	cpc	r18, r1
    2a96:	31 05       	cpc	r19, r1
    2a98:	c1 f0       	breq	.+48     	; 0x2aca <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    2a9a:	cc 23       	and	r28, r28
    2a9c:	49 f0       	breq	.+18     	; 0x2ab0 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2a9e:	e0 91 a5 03 	lds	r30, 0x03A5
    2aa2:	f0 91 a6 03 	lds	r31, 0x03A6
    2aa6:	15 a2       	lds	r17, 0x95
    2aa8:	16 a2       	lds	r17, 0x96
    2aaa:	17 a2       	lds	r17, 0x97
    2aac:	10 a6       	lds	r17, 0xb0
    2aae:	0d c0       	rjmp	.+26     	; 0x2aca <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2ab0:	e0 91 a5 03 	lds	r30, 0x03A5
    2ab4:	f0 91 a6 03 	lds	r31, 0x03A6
    2ab8:	d9 01       	movw	r26, r18
    2aba:	c8 01       	movw	r24, r16
    2abc:	01 97       	sbiw	r24, 0x01	; 1
    2abe:	a1 09       	sbc	r26, r1
    2ac0:	b1 09       	sbc	r27, r1
    2ac2:	85 a3       	lds	r24, 0x55
    2ac4:	96 a3       	lds	r25, 0x56
    2ac6:	a7 a3       	lds	r26, 0x57
    2ac8:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2aca:	e0 91 a5 03 	lds	r30, 0x03A5
    2ace:	f0 91 a6 03 	lds	r31, 0x03A6
    2ad2:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2ad4:	0f 90       	pop	r0
    2ad6:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    2ad8:	60 2f       	mov	r22, r16
    2ada:	71 2f       	mov	r23, r17
    2adc:	82 2f       	mov	r24, r18
    2ade:	93 2f       	mov	r25, r19
    2ae0:	cf 91       	pop	r28
    2ae2:	1f 91       	pop	r17
    2ae4:	0f 91       	pop	r16
    2ae6:	08 95       	ret

00002ae8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2ae8:	8f 92       	push	r8
    2aea:	9f 92       	push	r9
    2aec:	af 92       	push	r10
    2aee:	bf 92       	push	r11
    2af0:	ef 92       	push	r14
    2af2:	ff 92       	push	r15
    2af4:	0f 93       	push	r16
    2af6:	1f 93       	push	r17
    2af8:	dc 01       	movw	r26, r24
    2afa:	cb 01       	movw	r24, r22
    2afc:	49 01       	movw	r8, r18
    2afe:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2b00:	0f b6       	in	r0, 0x3f	; 63
    2b02:	f8 94       	cli
    2b04:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2b06:	e0 91 a5 03 	lds	r30, 0x03A5
    2b0a:	f0 91 a6 03 	lds	r31, 0x03A6
    2b0e:	21 a5       	lds	r18, 0x61
    2b10:	22 30       	cpi	r18, 0x02	; 2
    2b12:	19 f1       	breq	.+70     	; 0x2b5a <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2b14:	e0 91 a5 03 	lds	r30, 0x03A5
    2b18:	f0 91 a6 03 	lds	r31, 0x03A6
    2b1c:	45 a1       	lds	r20, 0x45
    2b1e:	56 a1       	lds	r21, 0x46
    2b20:	67 a1       	lds	r22, 0x47
    2b22:	70 a5       	lds	r23, 0x60
    2b24:	80 95       	com	r24
    2b26:	90 95       	com	r25
    2b28:	a0 95       	com	r26
    2b2a:	b0 95       	com	r27
    2b2c:	84 23       	and	r24, r20
    2b2e:	95 23       	and	r25, r21
    2b30:	a6 23       	and	r26, r22
    2b32:	b7 23       	and	r27, r23
    2b34:	85 a3       	lds	r24, 0x55
    2b36:	96 a3       	lds	r25, 0x56
    2b38:	a7 a3       	lds	r26, 0x57
    2b3a:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2b3c:	e0 91 a5 03 	lds	r30, 0x03A5
    2b40:	f0 91 a6 03 	lds	r31, 0x03A6
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2b48:	e1 14       	cp	r14, r1
    2b4a:	f1 04       	cpc	r15, r1
    2b4c:	31 f0       	breq	.+12     	; 0x2b5a <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2b4e:	c7 01       	movw	r24, r14
    2b50:	61 e0       	ldi	r22, 0x01	; 1
    2b52:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2b56:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2b5a:	0f 90       	pop	r0
    2b5c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2b5e:	0f b6       	in	r0, 0x3f	; 63
    2b60:	f8 94       	cli
    2b62:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2b64:	01 15       	cp	r16, r1
    2b66:	11 05       	cpc	r17, r1
    2b68:	69 f0       	breq	.+26     	; 0x2b84 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2b6a:	e0 91 a5 03 	lds	r30, 0x03A5
    2b6e:	f0 91 a6 03 	lds	r31, 0x03A6
    2b72:	85 a1       	lds	r24, 0x45
    2b74:	96 a1       	lds	r25, 0x46
    2b76:	a7 a1       	lds	r26, 0x47
    2b78:	b0 a5       	lds	r27, 0x60
    2b7a:	f8 01       	movw	r30, r16
    2b7c:	80 83       	st	Z, r24
    2b7e:	91 83       	std	Z+1, r25	; 0x01
    2b80:	a2 83       	std	Z+2, r26	; 0x02
    2b82:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2b84:	e0 91 a5 03 	lds	r30, 0x03A5
    2b88:	f0 91 a6 03 	lds	r31, 0x03A6
    2b8c:	81 a5       	lds	r24, 0x61
    2b8e:	81 30       	cpi	r24, 0x01	; 1
    2b90:	b1 f0       	breq	.+44     	; 0x2bbe <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2b92:	e0 91 a5 03 	lds	r30, 0x03A5
    2b96:	f0 91 a6 03 	lds	r31, 0x03A6
    2b9a:	85 a1       	lds	r24, 0x45
    2b9c:	96 a1       	lds	r25, 0x46
    2b9e:	a7 a1       	lds	r26, 0x47
    2ba0:	b0 a5       	lds	r27, 0x60
    2ba2:	80 94       	com	r8
    2ba4:	90 94       	com	r9
    2ba6:	a0 94       	com	r10
    2ba8:	b0 94       	com	r11
    2baa:	88 22       	and	r8, r24
    2bac:	99 22       	and	r9, r25
    2bae:	aa 22       	and	r10, r26
    2bb0:	bb 22       	and	r11, r27
    2bb2:	85 a2       	lds	r24, 0x95
    2bb4:	96 a2       	lds	r25, 0x96
    2bb6:	a7 a2       	lds	r26, 0x97
    2bb8:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    2bba:	81 e0       	ldi	r24, 0x01	; 1
    2bbc:	01 c0       	rjmp	.+2      	; 0x2bc0 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2bbe:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2bc0:	e0 91 a5 03 	lds	r30, 0x03A5
    2bc4:	f0 91 a6 03 	lds	r31, 0x03A6
    2bc8:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2bca:	0f 90       	pop	r0
    2bcc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2bce:	1f 91       	pop	r17
    2bd0:	0f 91       	pop	r16
    2bd2:	ff 90       	pop	r15
    2bd4:	ef 90       	pop	r14
    2bd6:	bf 90       	pop	r11
    2bd8:	af 90       	pop	r10
    2bda:	9f 90       	pop	r9
    2bdc:	8f 90       	pop	r8
    2bde:	08 95       	ret

00002be0 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2be0:	0f 93       	push	r16
    2be2:	1f 93       	push	r17
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2bea:	0f b6       	in	r0, 0x3f	; 63
    2bec:	f8 94       	cli
    2bee:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2bf0:	01 15       	cp	r16, r1
    2bf2:	11 05       	cpc	r17, r1
    2bf4:	49 f0       	breq	.+18     	; 0x2c08 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2bf6:	8d a1       	lds	r24, 0x4d
    2bf8:	9e a1       	lds	r25, 0x4e
    2bfa:	af a1       	lds	r26, 0x4f
    2bfc:	b8 a5       	lds	r27, 0x68
    2bfe:	f8 01       	movw	r30, r16
    2c00:	80 83       	st	Z, r24
    2c02:	91 83       	std	Z+1, r25	; 0x01
    2c04:	a2 83       	std	Z+2, r26	; 0x02
    2c06:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2c08:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2c0a:	82 e0       	ldi	r24, 0x02	; 2
    2c0c:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2c0e:	22 30       	cpi	r18, 0x02	; 2
    2c10:	b9 f0       	breq	.+46     	; 0x2c40 <xTaskGenericNotify+0x60>
    2c12:	23 30       	cpi	r18, 0x03	; 3
    2c14:	18 f4       	brcc	.+6      	; 0x2c1c <xTaskGenericNotify+0x3c>
    2c16:	21 30       	cpi	r18, 0x01	; 1
    2c18:	51 f5       	brne	.+84     	; 0x2c6e <xTaskGenericNotify+0x8e>
    2c1a:	05 c0       	rjmp	.+10     	; 0x2c26 <xTaskGenericNotify+0x46>
    2c1c:	23 30       	cpi	r18, 0x03	; 3
    2c1e:	e1 f0       	breq	.+56     	; 0x2c58 <xTaskGenericNotify+0x78>
    2c20:	24 30       	cpi	r18, 0x04	; 4
    2c22:	29 f5       	brne	.+74     	; 0x2c6e <xTaskGenericNotify+0x8e>
    2c24:	1e c0       	rjmp	.+60     	; 0x2c62 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2c26:	8d a1       	lds	r24, 0x4d
    2c28:	9e a1       	lds	r25, 0x4e
    2c2a:	af a1       	lds	r26, 0x4f
    2c2c:	b8 a5       	lds	r27, 0x68
    2c2e:	48 2b       	or	r20, r24
    2c30:	59 2b       	or	r21, r25
    2c32:	6a 2b       	or	r22, r26
    2c34:	7b 2b       	or	r23, r27
    2c36:	4d a3       	lds	r20, 0x5d
    2c38:	5e a3       	lds	r21, 0x5e
    2c3a:	6f a3       	lds	r22, 0x5f
    2c3c:	78 a7       	lds	r23, 0x78
					break;
    2c3e:	17 c0       	rjmp	.+46     	; 0x2c6e <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2c40:	8d a1       	lds	r24, 0x4d
    2c42:	9e a1       	lds	r25, 0x4e
    2c44:	af a1       	lds	r26, 0x4f
    2c46:	b8 a5       	lds	r27, 0x68
    2c48:	01 96       	adiw	r24, 0x01	; 1
    2c4a:	a1 1d       	adc	r26, r1
    2c4c:	b1 1d       	adc	r27, r1
    2c4e:	8d a3       	lds	r24, 0x5d
    2c50:	9e a3       	lds	r25, 0x5e
    2c52:	af a3       	lds	r26, 0x5f
    2c54:	b8 a7       	lds	r27, 0x78
					break;
    2c56:	0b c0       	rjmp	.+22     	; 0x2c6e <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2c58:	4d a3       	lds	r20, 0x5d
    2c5a:	5e a3       	lds	r21, 0x5e
    2c5c:	6f a3       	lds	r22, 0x5f
    2c5e:	78 a7       	lds	r23, 0x78
					break;
    2c60:	06 c0       	rjmp	.+12     	; 0x2c6e <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2c62:	32 30       	cpi	r19, 0x02	; 2
    2c64:	71 f1       	breq	.+92     	; 0x2cc2 <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2c66:	4d a3       	lds	r20, 0x5d
    2c68:	5e a3       	lds	r21, 0x5e
    2c6a:	6f a3       	lds	r22, 0x5f
    2c6c:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2c6e:	31 30       	cpi	r19, 0x01	; 1
    2c70:	51 f5       	brne	.+84     	; 0x2cc6 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c72:	8e 01       	movw	r16, r28
    2c74:	0e 5f       	subi	r16, 0xFE	; 254
    2c76:	1f 4f       	sbci	r17, 0xFF	; 255
    2c78:	c8 01       	movw	r24, r16
    2c7a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2c7e:	8e 89       	ldd	r24, Y+22	; 0x16
    2c80:	90 91 ae 03 	lds	r25, 0x03AE
    2c84:	98 17       	cp	r25, r24
    2c86:	10 f4       	brcc	.+4      	; 0x2c8c <xTaskGenericNotify+0xac>
    2c88:	80 93 ae 03 	sts	0x03AE, r24
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	9c 01       	movw	r18, r24
    2c90:	22 0f       	add	r18, r18
    2c92:	33 1f       	adc	r19, r19
    2c94:	22 0f       	add	r18, r18
    2c96:	33 1f       	adc	r19, r19
    2c98:	22 0f       	add	r18, r18
    2c9a:	33 1f       	adc	r19, r19
    2c9c:	82 0f       	add	r24, r18
    2c9e:	93 1f       	adc	r25, r19
    2ca0:	88 54       	subi	r24, 0x48	; 72
    2ca2:	9c 4f       	sbci	r25, 0xFC	; 252
    2ca4:	b8 01       	movw	r22, r16
    2ca6:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2caa:	e0 91 a5 03 	lds	r30, 0x03A5
    2cae:	f0 91 a6 03 	lds	r31, 0x03A6
    2cb2:	9e 89       	ldd	r25, Y+22	; 0x16
    2cb4:	86 89       	ldd	r24, Z+22	; 0x16
    2cb6:	89 17       	cp	r24, r25
    2cb8:	40 f4       	brcc	.+16     	; 0x2cca <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2cba:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	05 c0       	rjmp	.+10     	; 0x2ccc <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2cc2:	80 e0       	ldi	r24, 0x00	; 0
    2cc4:	03 c0       	rjmp	.+6      	; 0x2ccc <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2cc6:	81 e0       	ldi	r24, 0x01	; 1
    2cc8:	01 c0       	rjmp	.+2      	; 0x2ccc <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2cca:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2ccc:	0f 90       	pop	r0
    2cce:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2cd0:	df 91       	pop	r29
    2cd2:	cf 91       	pop	r28
    2cd4:	1f 91       	pop	r17
    2cd6:	0f 91       	pop	r16
    2cd8:	08 95       	ret

00002cda <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2cda:	ef 92       	push	r14
    2cdc:	ff 92       	push	r15
    2cde:	0f 93       	push	r16
    2ce0:	1f 93       	push	r17
    2ce2:	cf 93       	push	r28
    2ce4:	df 93       	push	r29
    2ce6:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2ce8:	01 15       	cp	r16, r1
    2cea:	11 05       	cpc	r17, r1
    2cec:	49 f0       	breq	.+18     	; 0x2d00 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2cee:	8d a1       	lds	r24, 0x4d
    2cf0:	9e a1       	lds	r25, 0x4e
    2cf2:	af a1       	lds	r26, 0x4f
    2cf4:	b8 a5       	lds	r27, 0x68
    2cf6:	f8 01       	movw	r30, r16
    2cf8:	80 83       	st	Z, r24
    2cfa:	91 83       	std	Z+1, r25	; 0x01
    2cfc:	a2 83       	std	Z+2, r26	; 0x02
    2cfe:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2d00:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2d02:	82 e0       	ldi	r24, 0x02	; 2
    2d04:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2d06:	22 30       	cpi	r18, 0x02	; 2
    2d08:	b9 f0       	breq	.+46     	; 0x2d38 <xTaskGenericNotifyFromISR+0x5e>
    2d0a:	23 30       	cpi	r18, 0x03	; 3
    2d0c:	18 f4       	brcc	.+6      	; 0x2d14 <xTaskGenericNotifyFromISR+0x3a>
    2d0e:	21 30       	cpi	r18, 0x01	; 1
    2d10:	59 f5       	brne	.+86     	; 0x2d68 <xTaskGenericNotifyFromISR+0x8e>
    2d12:	05 c0       	rjmp	.+10     	; 0x2d1e <xTaskGenericNotifyFromISR+0x44>
    2d14:	23 30       	cpi	r18, 0x03	; 3
    2d16:	e1 f0       	breq	.+56     	; 0x2d50 <xTaskGenericNotifyFromISR+0x76>
    2d18:	24 30       	cpi	r18, 0x04	; 4
    2d1a:	31 f5       	brne	.+76     	; 0x2d68 <xTaskGenericNotifyFromISR+0x8e>
    2d1c:	1e c0       	rjmp	.+60     	; 0x2d5a <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2d1e:	8d a1       	lds	r24, 0x4d
    2d20:	9e a1       	lds	r25, 0x4e
    2d22:	af a1       	lds	r26, 0x4f
    2d24:	b8 a5       	lds	r27, 0x68
    2d26:	84 2b       	or	r24, r20
    2d28:	95 2b       	or	r25, r21
    2d2a:	a6 2b       	or	r26, r22
    2d2c:	b7 2b       	or	r27, r23
    2d2e:	8d a3       	lds	r24, 0x5d
    2d30:	9e a3       	lds	r25, 0x5e
    2d32:	af a3       	lds	r26, 0x5f
    2d34:	b8 a7       	lds	r27, 0x78
					break;
    2d36:	18 c0       	rjmp	.+48     	; 0x2d68 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2d38:	8d a1       	lds	r24, 0x4d
    2d3a:	9e a1       	lds	r25, 0x4e
    2d3c:	af a1       	lds	r26, 0x4f
    2d3e:	b8 a5       	lds	r27, 0x68
    2d40:	01 96       	adiw	r24, 0x01	; 1
    2d42:	a1 1d       	adc	r26, r1
    2d44:	b1 1d       	adc	r27, r1
    2d46:	8d a3       	lds	r24, 0x5d
    2d48:	9e a3       	lds	r25, 0x5e
    2d4a:	af a3       	lds	r26, 0x5f
    2d4c:	b8 a7       	lds	r27, 0x78
					break;
    2d4e:	0c c0       	rjmp	.+24     	; 0x2d68 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2d50:	4d a3       	lds	r20, 0x5d
    2d52:	5e a3       	lds	r21, 0x5e
    2d54:	6f a3       	lds	r22, 0x5f
    2d56:	78 a7       	lds	r23, 0x78
					break;
    2d58:	07 c0       	rjmp	.+14     	; 0x2d68 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2d5a:	32 30       	cpi	r19, 0x02	; 2
    2d5c:	09 f4       	brne	.+2      	; 0x2d60 <xTaskGenericNotifyFromISR+0x86>
    2d5e:	41 c0       	rjmp	.+130    	; 0x2de2 <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2d60:	4d a3       	lds	r20, 0x5d
    2d62:	5e a3       	lds	r21, 0x5e
    2d64:	6f a3       	lds	r22, 0x5f
    2d66:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2d68:	31 30       	cpi	r19, 0x01	; 1
    2d6a:	e9 f5       	brne	.+122    	; 0x2de6 <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d6c:	80 91 a7 03 	lds	r24, 0x03A7
    2d70:	88 23       	and	r24, r24
    2d72:	e9 f4       	brne	.+58     	; 0x2dae <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2d74:	8e 01       	movw	r16, r28
    2d76:	0e 5f       	subi	r16, 0xFE	; 254
    2d78:	1f 4f       	sbci	r17, 0xFF	; 255
    2d7a:	c8 01       	movw	r24, r16
    2d7c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2d80:	8e 89       	ldd	r24, Y+22	; 0x16
    2d82:	90 91 ae 03 	lds	r25, 0x03AE
    2d86:	98 17       	cp	r25, r24
    2d88:	10 f4       	brcc	.+4      	; 0x2d8e <xTaskGenericNotifyFromISR+0xb4>
    2d8a:	80 93 ae 03 	sts	0x03AE, r24
    2d8e:	90 e0       	ldi	r25, 0x00	; 0
    2d90:	9c 01       	movw	r18, r24
    2d92:	22 0f       	add	r18, r18
    2d94:	33 1f       	adc	r19, r19
    2d96:	22 0f       	add	r18, r18
    2d98:	33 1f       	adc	r19, r19
    2d9a:	22 0f       	add	r18, r18
    2d9c:	33 1f       	adc	r19, r19
    2d9e:	82 0f       	add	r24, r18
    2da0:	93 1f       	adc	r25, r19
    2da2:	88 54       	subi	r24, 0x48	; 72
    2da4:	9c 4f       	sbci	r25, 0xFC	; 252
    2da6:	b8 01       	movw	r22, r16
    2da8:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    2dac:	07 c0       	rjmp	.+14     	; 0x2dbc <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2dae:	be 01       	movw	r22, r28
    2db0:	64 5f       	subi	r22, 0xF4	; 244
    2db2:	7f 4f       	sbci	r23, 0xFF	; 255
    2db4:	87 ef       	ldi	r24, 0xF7	; 247
    2db6:	93 e0       	ldi	r25, 0x03	; 3
    2db8:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2dbc:	e0 91 a5 03 	lds	r30, 0x03A5
    2dc0:	f0 91 a6 03 	lds	r31, 0x03A6
    2dc4:	9e 89       	ldd	r25, Y+22	; 0x16
    2dc6:	86 89       	ldd	r24, Z+22	; 0x16
    2dc8:	89 17       	cp	r24, r25
    2dca:	78 f4       	brcc	.+30     	; 0x2dea <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2dcc:	e1 14       	cp	r14, r1
    2dce:	f1 04       	cpc	r15, r1
    2dd0:	21 f0       	breq	.+8      	; 0x2dda <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	f7 01       	movw	r30, r14
    2dd6:	80 83       	st	Z, r24
    2dd8:	09 c0       	rjmp	.+18     	; 0x2dec <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2dda:	81 e0       	ldi	r24, 0x01	; 1
    2ddc:	80 93 ab 03 	sts	0x03AB, r24
    2de0:	05 c0       	rjmp	.+10     	; 0x2dec <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2de2:	80 e0       	ldi	r24, 0x00	; 0
    2de4:	03 c0       	rjmp	.+6      	; 0x2dec <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2de6:	81 e0       	ldi	r24, 0x01	; 1
    2de8:	01 c0       	rjmp	.+2      	; 0x2dec <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2dea:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2dec:	df 91       	pop	r29
    2dee:	cf 91       	pop	r28
    2df0:	1f 91       	pop	r17
    2df2:	0f 91       	pop	r16
    2df4:	ff 90       	pop	r15
    2df6:	ef 90       	pop	r14
    2df8:	08 95       	ret

00002dfa <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2dfa:	ef 92       	push	r14
    2dfc:	ff 92       	push	r15
    2dfe:	0f 93       	push	r16
    2e00:	1f 93       	push	r17
    2e02:	cf 93       	push	r28
    2e04:	df 93       	push	r29
    2e06:	ec 01       	movw	r28, r24
    2e08:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2e0a:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2e0c:	82 e0       	ldi	r24, 0x02	; 2
    2e0e:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    2e10:	8d a1       	lds	r24, 0x4d
    2e12:	9e a1       	lds	r25, 0x4e
    2e14:	af a1       	lds	r26, 0x4f
    2e16:	b8 a5       	lds	r27, 0x68
    2e18:	01 96       	adiw	r24, 0x01	; 1
    2e1a:	a1 1d       	adc	r26, r1
    2e1c:	b1 1d       	adc	r27, r1
    2e1e:	8d a3       	lds	r24, 0x5d
    2e20:	9e a3       	lds	r25, 0x5e
    2e22:	af a3       	lds	r26, 0x5f
    2e24:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2e26:	21 30       	cpi	r18, 0x01	; 1
    2e28:	e9 f5       	brne	.+122    	; 0x2ea4 <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2e2a:	80 91 a7 03 	lds	r24, 0x03A7
    2e2e:	88 23       	and	r24, r24
    2e30:	01 f5       	brne	.+64     	; 0x2e72 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e32:	ee 24       	eor	r14, r14
    2e34:	ff 24       	eor	r15, r15
    2e36:	68 94       	set
    2e38:	e1 f8       	bld	r14, 1
    2e3a:	ec 0e       	add	r14, r28
    2e3c:	fd 1e       	adc	r15, r29
    2e3e:	c7 01       	movw	r24, r14
    2e40:	0e 94 4d 07 	call	0xe9a	; 0xe9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2e44:	8e 89       	ldd	r24, Y+22	; 0x16
    2e46:	90 91 ae 03 	lds	r25, 0x03AE
    2e4a:	98 17       	cp	r25, r24
    2e4c:	10 f4       	brcc	.+4      	; 0x2e52 <vTaskNotifyGiveFromISR+0x58>
    2e4e:	80 93 ae 03 	sts	0x03AE, r24
    2e52:	90 e0       	ldi	r25, 0x00	; 0
    2e54:	9c 01       	movw	r18, r24
    2e56:	22 0f       	add	r18, r18
    2e58:	33 1f       	adc	r19, r19
    2e5a:	22 0f       	add	r18, r18
    2e5c:	33 1f       	adc	r19, r19
    2e5e:	22 0f       	add	r18, r18
    2e60:	33 1f       	adc	r19, r19
    2e62:	82 0f       	add	r24, r18
    2e64:	93 1f       	adc	r25, r19
    2e66:	88 54       	subi	r24, 0x48	; 72
    2e68:	9c 4f       	sbci	r25, 0xFC	; 252
    2e6a:	b7 01       	movw	r22, r14
    2e6c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
    2e70:	07 c0       	rjmp	.+14     	; 0x2e80 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2e72:	be 01       	movw	r22, r28
    2e74:	64 5f       	subi	r22, 0xF4	; 244
    2e76:	7f 4f       	sbci	r23, 0xFF	; 255
    2e78:	87 ef       	ldi	r24, 0xF7	; 247
    2e7a:	93 e0       	ldi	r25, 0x03	; 3
    2e7c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2e80:	e0 91 a5 03 	lds	r30, 0x03A5
    2e84:	f0 91 a6 03 	lds	r31, 0x03A6
    2e88:	9e 89       	ldd	r25, Y+22	; 0x16
    2e8a:	86 89       	ldd	r24, Z+22	; 0x16
    2e8c:	89 17       	cp	r24, r25
    2e8e:	50 f4       	brcc	.+20     	; 0x2ea4 <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2e90:	01 15       	cp	r16, r1
    2e92:	11 05       	cpc	r17, r1
    2e94:	21 f0       	breq	.+8      	; 0x2e9e <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2e96:	81 e0       	ldi	r24, 0x01	; 1
    2e98:	f8 01       	movw	r30, r16
    2e9a:	80 83       	st	Z, r24
    2e9c:	03 c0       	rjmp	.+6      	; 0x2ea4 <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2e9e:	81 e0       	ldi	r24, 0x01	; 1
    2ea0:	80 93 ab 03 	sts	0x03AB, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2ea4:	df 91       	pop	r29
    2ea6:	cf 91       	pop	r28
    2ea8:	1f 91       	pop	r17
    2eaa:	0f 91       	pop	r16
    2eac:	ff 90       	pop	r15
    2eae:	ef 90       	pop	r14
    2eb0:	08 95       	ret

00002eb2 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2eb2:	00 97       	sbiw	r24, 0x00	; 0
    2eb4:	29 f4       	brne	.+10     	; 0x2ec0 <xTaskNotifyStateClear+0xe>
    2eb6:	e0 91 a5 03 	lds	r30, 0x03A5
    2eba:	f0 91 a6 03 	lds	r31, 0x03A6
    2ebe:	01 c0       	rjmp	.+2      	; 0x2ec2 <xTaskNotifyStateClear+0x10>
    2ec0:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    2ec2:	0f b6       	in	r0, 0x3f	; 63
    2ec4:	f8 94       	cli
    2ec6:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2ec8:	81 a5       	lds	r24, 0x61
    2eca:	82 30       	cpi	r24, 0x02	; 2
    2ecc:	19 f4       	brne	.+6      	; 0x2ed4 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2ece:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    2ed0:	81 e0       	ldi	r24, 0x01	; 1
    2ed2:	01 c0       	rjmp	.+2      	; 0x2ed6 <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    2ed4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2ed6:	0f 90       	pop	r0
    2ed8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2eda:	08 95       	ret

00002edc <memcpy>:
    2edc:	fb 01       	movw	r30, r22
    2ede:	dc 01       	movw	r26, r24
    2ee0:	02 c0       	rjmp	.+4      	; 0x2ee6 <memcpy+0xa>
    2ee2:	01 90       	ld	r0, Z+
    2ee4:	0d 92       	st	X+, r0
    2ee6:	41 50       	subi	r20, 0x01	; 1
    2ee8:	50 40       	sbci	r21, 0x00	; 0
    2eea:	d8 f7       	brcc	.-10     	; 0x2ee2 <memcpy+0x6>
    2eec:	08 95       	ret

00002eee <_exit>:
    2eee:	f8 94       	cli

00002ef0 <__stop_program>:
    2ef0:	ff cf       	rjmp	.-2      	; 0x2ef0 <__stop_program>
