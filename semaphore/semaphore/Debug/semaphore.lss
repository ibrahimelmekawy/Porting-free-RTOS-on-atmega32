
semaphore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002ac6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00002ac6  00002b5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ba  0080006a  0080006a  00002b64  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00002b64  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  000032b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  000033a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000035bc  00000000  00000000  00003500  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c4d  00000000  00000000  00006abc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000143d  00000000  00000000  00007709  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bd4  00000000  00000000  00008b48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000154f  00000000  00000000  0000971c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000041b1  00000000  00000000  0000ac6b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  0000ee1c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 38 0b 	jmp	0x1670	; 0x1670 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c3 06 	jmp	0xd86	; 0xd86 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ec       	ldi	r30, 0xC6	; 198
      68:	fa e2       	ldi	r31, 0x2A	; 42
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 32       	cpi	r26, 0x24	; 36
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 18 0b 	call	0x1630	; 0x1630 <main>
      8a:	0c 94 61 15 	jmp	0x2ac2	; 0x2ac2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_vsetPINDir>:



void DIO_vsetPINDir(char portname,char pinnumber,char direction)
{
	switch(portname)
      92:	82 34       	cpi	r24, 0x42	; 66
      94:	51 f1       	breq	.+84     	; 0xea <DIO_vsetPINDir+0x58>
      96:	83 34       	cpi	r24, 0x43	; 67
      98:	20 f4       	brcc	.+8      	; 0xa2 <DIO_vsetPINDir+0x10>
      9a:	81 34       	cpi	r24, 0x41	; 65
      9c:	09 f0       	breq	.+2      	; 0xa0 <DIO_vsetPINDir+0xe>
      9e:	7b c0       	rjmp	.+246    	; 0x196 <DIO_vsetPINDir+0x104>
      a0:	07 c0       	rjmp	.+14     	; 0xb0 <DIO_vsetPINDir+0x1e>
      a2:	83 34       	cpi	r24, 0x43	; 67
      a4:	09 f4       	brne	.+2      	; 0xa8 <DIO_vsetPINDir+0x16>
      a6:	3e c0       	rjmp	.+124    	; 0x124 <DIO_vsetPINDir+0x92>
      a8:	84 34       	cpi	r24, 0x44	; 68
      aa:	09 f0       	breq	.+2      	; 0xae <DIO_vsetPINDir+0x1c>
      ac:	74 c0       	rjmp	.+232    	; 0x196 <DIO_vsetPINDir+0x104>
      ae:	57 c0       	rjmp	.+174    	; 0x15e <DIO_vsetPINDir+0xcc>
	{
		
	
	case 'A':
	if(direction==1)
      b0:	41 30       	cpi	r20, 0x01	; 1
      b2:	69 f4       	brne	.+26     	; 0xce <DIO_vsetPINDir+0x3c>
	{
		DDRA|=(1<<pinnumber);
      b4:	2a b3       	in	r18, 0x1a	; 26
      b6:	81 e0       	ldi	r24, 0x01	; 1
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	ac 01       	movw	r20, r24
      bc:	02 c0       	rjmp	.+4      	; 0xc2 <DIO_vsetPINDir+0x30>
      be:	44 0f       	add	r20, r20
      c0:	55 1f       	adc	r21, r21
      c2:	6a 95       	dec	r22
      c4:	e2 f7       	brpl	.-8      	; 0xbe <DIO_vsetPINDir+0x2c>
      c6:	ba 01       	movw	r22, r20
      c8:	62 2b       	or	r22, r18
      ca:	6a bb       	out	0x1a, r22	; 26
      cc:	08 95       	ret
	}
	else
	{
		DDRA&=(~(1<<pinnumber));
      ce:	2a b3       	in	r18, 0x1a	; 26
      d0:	81 e0       	ldi	r24, 0x01	; 1
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	ac 01       	movw	r20, r24
      d6:	02 c0       	rjmp	.+4      	; 0xdc <DIO_vsetPINDir+0x4a>
      d8:	44 0f       	add	r20, r20
      da:	55 1f       	adc	r21, r21
      dc:	6a 95       	dec	r22
      de:	e2 f7       	brpl	.-8      	; 0xd8 <DIO_vsetPINDir+0x46>
      e0:	ba 01       	movw	r22, r20
      e2:	60 95       	com	r22
      e4:	62 23       	and	r22, r18
      e6:	6a bb       	out	0x1a, r22	; 26
      e8:	08 95       	ret
	}
	break;
	case 'B':
	if(direction==1)
      ea:	41 30       	cpi	r20, 0x01	; 1
      ec:	69 f4       	brne	.+26     	; 0x108 <DIO_vsetPINDir+0x76>
	{
		DDRB|=(1<<pinnumber);
      ee:	27 b3       	in	r18, 0x17	; 23
      f0:	81 e0       	ldi	r24, 0x01	; 1
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	ac 01       	movw	r20, r24
      f6:	02 c0       	rjmp	.+4      	; 0xfc <DIO_vsetPINDir+0x6a>
      f8:	44 0f       	add	r20, r20
      fa:	55 1f       	adc	r21, r21
      fc:	6a 95       	dec	r22
      fe:	e2 f7       	brpl	.-8      	; 0xf8 <DIO_vsetPINDir+0x66>
     100:	ba 01       	movw	r22, r20
     102:	62 2b       	or	r22, r18
     104:	67 bb       	out	0x17, r22	; 23
     106:	08 95       	ret
	}
	else
	{
		DDRB&=(~(1<<pinnumber));
     108:	27 b3       	in	r18, 0x17	; 23
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	90 e0       	ldi	r25, 0x00	; 0
     10e:	ac 01       	movw	r20, r24
     110:	02 c0       	rjmp	.+4      	; 0x116 <DIO_vsetPINDir+0x84>
     112:	44 0f       	add	r20, r20
     114:	55 1f       	adc	r21, r21
     116:	6a 95       	dec	r22
     118:	e2 f7       	brpl	.-8      	; 0x112 <DIO_vsetPINDir+0x80>
     11a:	ba 01       	movw	r22, r20
     11c:	60 95       	com	r22
     11e:	62 23       	and	r22, r18
     120:	67 bb       	out	0x17, r22	; 23
     122:	08 95       	ret
	}
	break;
	case 'C':
	if(direction==1)
     124:	41 30       	cpi	r20, 0x01	; 1
     126:	69 f4       	brne	.+26     	; 0x142 <DIO_vsetPINDir+0xb0>
	{
		DDRC|=(1<<pinnumber);
     128:	24 b3       	in	r18, 0x14	; 20
     12a:	81 e0       	ldi	r24, 0x01	; 1
     12c:	90 e0       	ldi	r25, 0x00	; 0
     12e:	ac 01       	movw	r20, r24
     130:	02 c0       	rjmp	.+4      	; 0x136 <DIO_vsetPINDir+0xa4>
     132:	44 0f       	add	r20, r20
     134:	55 1f       	adc	r21, r21
     136:	6a 95       	dec	r22
     138:	e2 f7       	brpl	.-8      	; 0x132 <DIO_vsetPINDir+0xa0>
     13a:	ba 01       	movw	r22, r20
     13c:	62 2b       	or	r22, r18
     13e:	64 bb       	out	0x14, r22	; 20
     140:	08 95       	ret
	}
	else
	{
		DDRC&=(~(1<<pinnumber));
     142:	24 b3       	in	r18, 0x14	; 20
     144:	81 e0       	ldi	r24, 0x01	; 1
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	ac 01       	movw	r20, r24
     14a:	02 c0       	rjmp	.+4      	; 0x150 <DIO_vsetPINDir+0xbe>
     14c:	44 0f       	add	r20, r20
     14e:	55 1f       	adc	r21, r21
     150:	6a 95       	dec	r22
     152:	e2 f7       	brpl	.-8      	; 0x14c <DIO_vsetPINDir+0xba>
     154:	ba 01       	movw	r22, r20
     156:	60 95       	com	r22
     158:	62 23       	and	r22, r18
     15a:	64 bb       	out	0x14, r22	; 20
     15c:	08 95       	ret
	}
	break;
	case 'D':
	if(direction==1)
     15e:	41 30       	cpi	r20, 0x01	; 1
     160:	69 f4       	brne	.+26     	; 0x17c <DIO_vsetPINDir+0xea>
	{
		DDRD|=(1<<pinnumber);
     162:	21 b3       	in	r18, 0x11	; 17
     164:	81 e0       	ldi	r24, 0x01	; 1
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	ac 01       	movw	r20, r24
     16a:	02 c0       	rjmp	.+4      	; 0x170 <DIO_vsetPINDir+0xde>
     16c:	44 0f       	add	r20, r20
     16e:	55 1f       	adc	r21, r21
     170:	6a 95       	dec	r22
     172:	e2 f7       	brpl	.-8      	; 0x16c <DIO_vsetPINDir+0xda>
     174:	ba 01       	movw	r22, r20
     176:	62 2b       	or	r22, r18
     178:	61 bb       	out	0x11, r22	; 17
     17a:	08 95       	ret
	}
	else
	{
		DDRD&=(~(1<<pinnumber));
     17c:	21 b3       	in	r18, 0x11	; 17
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	ac 01       	movw	r20, r24
     184:	02 c0       	rjmp	.+4      	; 0x18a <DIO_vsetPINDir+0xf8>
     186:	44 0f       	add	r20, r20
     188:	55 1f       	adc	r21, r21
     18a:	6a 95       	dec	r22
     18c:	e2 f7       	brpl	.-8      	; 0x186 <DIO_vsetPINDir+0xf4>
     18e:	ba 01       	movw	r22, r20
     190:	60 95       	com	r22
     192:	62 23       	and	r22, r18
     194:	61 bb       	out	0x11, r22	; 17
     196:	08 95       	ret

00000198 <DIO_write>:
}


void DIO_write(char portname,char pinnumber,char outputvalue)
{
	switch(portname)
     198:	82 34       	cpi	r24, 0x42	; 66
     19a:	51 f1       	breq	.+84     	; 0x1f0 <DIO_write+0x58>
     19c:	83 34       	cpi	r24, 0x43	; 67
     19e:	20 f4       	brcc	.+8      	; 0x1a8 <DIO_write+0x10>
     1a0:	81 34       	cpi	r24, 0x41	; 65
     1a2:	09 f0       	breq	.+2      	; 0x1a6 <DIO_write+0xe>
     1a4:	7b c0       	rjmp	.+246    	; 0x29c <DIO_write+0x104>
     1a6:	07 c0       	rjmp	.+14     	; 0x1b6 <DIO_write+0x1e>
     1a8:	83 34       	cpi	r24, 0x43	; 67
     1aa:	09 f4       	brne	.+2      	; 0x1ae <DIO_write+0x16>
     1ac:	3e c0       	rjmp	.+124    	; 0x22a <DIO_write+0x92>
     1ae:	84 34       	cpi	r24, 0x44	; 68
     1b0:	09 f0       	breq	.+2      	; 0x1b4 <DIO_write+0x1c>
     1b2:	74 c0       	rjmp	.+232    	; 0x29c <DIO_write+0x104>
     1b4:	57 c0       	rjmp	.+174    	; 0x264 <DIO_write+0xcc>
	{
		case 'A' :
		
			if(outputvalue==1)
     1b6:	41 30       	cpi	r20, 0x01	; 1
     1b8:	69 f4       	brne	.+26     	; 0x1d4 <DIO_write+0x3c>
			{
				PORTA|=(1<<pinnumber);
     1ba:	2b b3       	in	r18, 0x1b	; 27
     1bc:	81 e0       	ldi	r24, 0x01	; 1
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	ac 01       	movw	r20, r24
     1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <DIO_write+0x30>
     1c4:	44 0f       	add	r20, r20
     1c6:	55 1f       	adc	r21, r21
     1c8:	6a 95       	dec	r22
     1ca:	e2 f7       	brpl	.-8      	; 0x1c4 <DIO_write+0x2c>
     1cc:	ba 01       	movw	r22, r20
     1ce:	62 2b       	or	r22, r18
     1d0:	6b bb       	out	0x1b, r22	; 27
     1d2:	08 95       	ret
			}
			else
			{
				PORTA&=(~(1<<pinnumber));
     1d4:	2b b3       	in	r18, 0x1b	; 27
     1d6:	81 e0       	ldi	r24, 0x01	; 1
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	ac 01       	movw	r20, r24
     1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <DIO_write+0x4a>
     1de:	44 0f       	add	r20, r20
     1e0:	55 1f       	adc	r21, r21
     1e2:	6a 95       	dec	r22
     1e4:	e2 f7       	brpl	.-8      	; 0x1de <DIO_write+0x46>
     1e6:	ba 01       	movw	r22, r20
     1e8:	60 95       	com	r22
     1ea:	62 23       	and	r22, r18
     1ec:	6b bb       	out	0x1b, r22	; 27
     1ee:	08 95       	ret
			}
			break ;
			case 'B':
			
			if(outputvalue==1)
     1f0:	41 30       	cpi	r20, 0x01	; 1
     1f2:	69 f4       	brne	.+26     	; 0x20e <DIO_write+0x76>
			{
				PORTB|=(1<<pinnumber);
     1f4:	28 b3       	in	r18, 0x18	; 24
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	ac 01       	movw	r20, r24
     1fc:	02 c0       	rjmp	.+4      	; 0x202 <DIO_write+0x6a>
     1fe:	44 0f       	add	r20, r20
     200:	55 1f       	adc	r21, r21
     202:	6a 95       	dec	r22
     204:	e2 f7       	brpl	.-8      	; 0x1fe <DIO_write+0x66>
     206:	ba 01       	movw	r22, r20
     208:	62 2b       	or	r22, r18
     20a:	68 bb       	out	0x18, r22	; 24
     20c:	08 95       	ret
			}
			else
			{
				PORTB&=(~(1<<pinnumber));
     20e:	28 b3       	in	r18, 0x18	; 24
     210:	81 e0       	ldi	r24, 0x01	; 1
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	ac 01       	movw	r20, r24
     216:	02 c0       	rjmp	.+4      	; 0x21c <DIO_write+0x84>
     218:	44 0f       	add	r20, r20
     21a:	55 1f       	adc	r21, r21
     21c:	6a 95       	dec	r22
     21e:	e2 f7       	brpl	.-8      	; 0x218 <DIO_write+0x80>
     220:	ba 01       	movw	r22, r20
     222:	60 95       	com	r22
     224:	62 23       	and	r22, r18
     226:	68 bb       	out	0x18, r22	; 24
     228:	08 95       	ret
			}
			break ;
			case 'C' :
			
			if(outputvalue==1)
     22a:	41 30       	cpi	r20, 0x01	; 1
     22c:	69 f4       	brne	.+26     	; 0x248 <DIO_write+0xb0>
			{
				PORTC|=(1<<pinnumber);
     22e:	25 b3       	in	r18, 0x15	; 21
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	ac 01       	movw	r20, r24
     236:	02 c0       	rjmp	.+4      	; 0x23c <DIO_write+0xa4>
     238:	44 0f       	add	r20, r20
     23a:	55 1f       	adc	r21, r21
     23c:	6a 95       	dec	r22
     23e:	e2 f7       	brpl	.-8      	; 0x238 <DIO_write+0xa0>
     240:	ba 01       	movw	r22, r20
     242:	62 2b       	or	r22, r18
     244:	65 bb       	out	0x15, r22	; 21
     246:	08 95       	ret
			}
			else
			{
				PORTC&=(~(1<<pinnumber));
     248:	25 b3       	in	r18, 0x15	; 21
     24a:	81 e0       	ldi	r24, 0x01	; 1
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	ac 01       	movw	r20, r24
     250:	02 c0       	rjmp	.+4      	; 0x256 <DIO_write+0xbe>
     252:	44 0f       	add	r20, r20
     254:	55 1f       	adc	r21, r21
     256:	6a 95       	dec	r22
     258:	e2 f7       	brpl	.-8      	; 0x252 <DIO_write+0xba>
     25a:	ba 01       	movw	r22, r20
     25c:	60 95       	com	r22
     25e:	62 23       	and	r22, r18
     260:	65 bb       	out	0x15, r22	; 21
     262:	08 95       	ret
			}
			break ;
		case 'D':
		
		if(outputvalue==1)
     264:	41 30       	cpi	r20, 0x01	; 1
     266:	69 f4       	brne	.+26     	; 0x282 <DIO_write+0xea>
		{
			PORTD|=(1<<pinnumber);
     268:	22 b3       	in	r18, 0x12	; 18
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	ac 01       	movw	r20, r24
     270:	02 c0       	rjmp	.+4      	; 0x276 <DIO_write+0xde>
     272:	44 0f       	add	r20, r20
     274:	55 1f       	adc	r21, r21
     276:	6a 95       	dec	r22
     278:	e2 f7       	brpl	.-8      	; 0x272 <DIO_write+0xda>
     27a:	ba 01       	movw	r22, r20
     27c:	62 2b       	or	r22, r18
     27e:	62 bb       	out	0x12, r22	; 18
     280:	08 95       	ret
		}
		else
	{
			PORTD&=(~(1<<pinnumber));
     282:	22 b3       	in	r18, 0x12	; 18
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	ac 01       	movw	r20, r24
     28a:	02 c0       	rjmp	.+4      	; 0x290 <DIO_write+0xf8>
     28c:	44 0f       	add	r20, r20
     28e:	55 1f       	adc	r21, r21
     290:	6a 95       	dec	r22
     292:	e2 f7       	brpl	.-8      	; 0x28c <DIO_write+0xf4>
     294:	ba 01       	movw	r22, r20
     296:	60 95       	com	r22
     298:	62 23       	and	r22, r18
     29a:	62 bb       	out	0x12, r22	; 18
     29c:	08 95       	ret

0000029e <DIO_u8read>:


char DIO_u8read(char portname,char pinnumber)
{
	char x ;
	switch(portname)
     29e:	82 34       	cpi	r24, 0x42	; 66
     2a0:	f9 f0       	breq	.+62     	; 0x2e0 <DIO_u8read+0x42>
     2a2:	83 34       	cpi	r24, 0x43	; 67
     2a4:	20 f4       	brcc	.+8      	; 0x2ae <DIO_u8read+0x10>
     2a6:	81 34       	cpi	r24, 0x41	; 65
     2a8:	09 f0       	breq	.+2      	; 0x2ac <DIO_u8read+0xe>
     2aa:	52 c0       	rjmp	.+164    	; 0x350 <DIO_u8read+0xb2>
     2ac:	06 c0       	rjmp	.+12     	; 0x2ba <DIO_u8read+0x1c>
     2ae:	83 34       	cpi	r24, 0x43	; 67
     2b0:	51 f1       	breq	.+84     	; 0x306 <DIO_u8read+0x68>
     2b2:	84 34       	cpi	r24, 0x44	; 68
     2b4:	09 f0       	breq	.+2      	; 0x2b8 <DIO_u8read+0x1a>
     2b6:	4c c0       	rjmp	.+152    	; 0x350 <DIO_u8read+0xb2>
     2b8:	39 c0       	rjmp	.+114    	; 0x32c <DIO_u8read+0x8e>
	{
		case 'A' :
		x=((PINA&(1<<pinnumber))>>pinnumber);
     2ba:	29 b3       	in	r18, 0x19	; 25
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	06 2e       	mov	r0, r22
     2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_u8read+0x2a>
     2c4:	88 0f       	add	r24, r24
     2c6:	99 1f       	adc	r25, r25
     2c8:	0a 94       	dec	r0
     2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_u8read+0x26>
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	82 23       	and	r24, r18
     2d0:	93 23       	and	r25, r19
     2d2:	02 c0       	rjmp	.+4      	; 0x2d8 <DIO_u8read+0x3a>
     2d4:	95 95       	asr	r25
     2d6:	87 95       	ror	r24
     2d8:	6a 95       	dec	r22
     2da:	e2 f7       	brpl	.-8      	; 0x2d4 <DIO_u8read+0x36>
     2dc:	98 2f       	mov	r25, r24
		break;
     2de:	38 c0       	rjmp	.+112    	; 0x350 <DIO_u8read+0xb2>
		
	case 'B' :
	x=((PINB&(1<<pinnumber))>>pinnumber) ;
     2e0:	26 b3       	in	r18, 0x16	; 22
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	06 2e       	mov	r0, r22
     2e8:	02 c0       	rjmp	.+4      	; 0x2ee <DIO_u8read+0x50>
     2ea:	88 0f       	add	r24, r24
     2ec:	99 1f       	adc	r25, r25
     2ee:	0a 94       	dec	r0
     2f0:	e2 f7       	brpl	.-8      	; 0x2ea <DIO_u8read+0x4c>
     2f2:	30 e0       	ldi	r19, 0x00	; 0
     2f4:	82 23       	and	r24, r18
     2f6:	93 23       	and	r25, r19
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <DIO_u8read+0x60>
     2fa:	95 95       	asr	r25
     2fc:	87 95       	ror	r24
     2fe:	6a 95       	dec	r22
     300:	e2 f7       	brpl	.-8      	; 0x2fa <DIO_u8read+0x5c>
     302:	98 2f       	mov	r25, r24
	break;
     304:	25 c0       	rjmp	.+74     	; 0x350 <DIO_u8read+0xb2>
	
	case 'C' :
	x=((PINC&(1<<pinnumber))>>pinnumber) ;
     306:	23 b3       	in	r18, 0x13	; 19
     308:	81 e0       	ldi	r24, 0x01	; 1
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	06 2e       	mov	r0, r22
     30e:	02 c0       	rjmp	.+4      	; 0x314 <DIO_u8read+0x76>
     310:	88 0f       	add	r24, r24
     312:	99 1f       	adc	r25, r25
     314:	0a 94       	dec	r0
     316:	e2 f7       	brpl	.-8      	; 0x310 <DIO_u8read+0x72>
     318:	30 e0       	ldi	r19, 0x00	; 0
     31a:	82 23       	and	r24, r18
     31c:	93 23       	and	r25, r19
     31e:	02 c0       	rjmp	.+4      	; 0x324 <DIO_u8read+0x86>
     320:	95 95       	asr	r25
     322:	87 95       	ror	r24
     324:	6a 95       	dec	r22
     326:	e2 f7       	brpl	.-8      	; 0x320 <DIO_u8read+0x82>
     328:	98 2f       	mov	r25, r24
	break;
     32a:	12 c0       	rjmp	.+36     	; 0x350 <DIO_u8read+0xb2>
	
	case 'D' :
	x=((PIND&(1<<pinnumber))>>pinnumber) ;
     32c:	20 b3       	in	r18, 0x10	; 16
     32e:	81 e0       	ldi	r24, 0x01	; 1
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	06 2e       	mov	r0, r22
     334:	02 c0       	rjmp	.+4      	; 0x33a <DIO_u8read+0x9c>
     336:	88 0f       	add	r24, r24
     338:	99 1f       	adc	r25, r25
     33a:	0a 94       	dec	r0
     33c:	e2 f7       	brpl	.-8      	; 0x336 <DIO_u8read+0x98>
     33e:	30 e0       	ldi	r19, 0x00	; 0
     340:	82 23       	and	r24, r18
     342:	93 23       	and	r25, r19
     344:	02 c0       	rjmp	.+4      	; 0x34a <DIO_u8read+0xac>
     346:	95 95       	asr	r25
     348:	87 95       	ror	r24
     34a:	6a 95       	dec	r22
     34c:	e2 f7       	brpl	.-8      	; 0x346 <DIO_u8read+0xa8>
     34e:	98 2f       	mov	r25, r24
	break;
	default: break;
}
return x ;
}
     350:	89 2f       	mov	r24, r25
     352:	08 95       	ret

00000354 <DIO_toggle>:
void DIO_toggle(char portname,char pinnumber)
{
	switch(portname)
     354:	82 34       	cpi	r24, 0x42	; 66
     356:	b9 f0       	breq	.+46     	; 0x386 <DIO_toggle+0x32>
     358:	83 34       	cpi	r24, 0x43	; 67
     35a:	18 f4       	brcc	.+6      	; 0x362 <DIO_toggle+0xe>
     35c:	81 34       	cpi	r24, 0x41	; 65
     35e:	c9 f5       	brne	.+114    	; 0x3d2 <DIO_toggle+0x7e>
     360:	05 c0       	rjmp	.+10     	; 0x36c <DIO_toggle+0x18>
     362:	83 34       	cpi	r24, 0x43	; 67
     364:	e9 f0       	breq	.+58     	; 0x3a0 <DIO_toggle+0x4c>
     366:	84 34       	cpi	r24, 0x44	; 68
     368:	a1 f5       	brne	.+104    	; 0x3d2 <DIO_toggle+0x7e>
     36a:	27 c0       	rjmp	.+78     	; 0x3ba <DIO_toggle+0x66>
	{
		case 'A':
		PORTA^=(1<<pinnumber);
     36c:	2b b3       	in	r18, 0x1b	; 27
     36e:	81 e0       	ldi	r24, 0x01	; 1
     370:	90 e0       	ldi	r25, 0x00	; 0
     372:	ac 01       	movw	r20, r24
     374:	02 c0       	rjmp	.+4      	; 0x37a <DIO_toggle+0x26>
     376:	44 0f       	add	r20, r20
     378:	55 1f       	adc	r21, r21
     37a:	6a 95       	dec	r22
     37c:	e2 f7       	brpl	.-8      	; 0x376 <DIO_toggle+0x22>
     37e:	ba 01       	movw	r22, r20
     380:	62 27       	eor	r22, r18
     382:	6b bb       	out	0x1b, r22	; 27
		break;
     384:	08 95       	ret
		case 'B':
		PORTB^=(1<<pinnumber);
     386:	28 b3       	in	r18, 0x18	; 24
     388:	81 e0       	ldi	r24, 0x01	; 1
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	ac 01       	movw	r20, r24
     38e:	02 c0       	rjmp	.+4      	; 0x394 <DIO_toggle+0x40>
     390:	44 0f       	add	r20, r20
     392:	55 1f       	adc	r21, r21
     394:	6a 95       	dec	r22
     396:	e2 f7       	brpl	.-8      	; 0x390 <DIO_toggle+0x3c>
     398:	ba 01       	movw	r22, r20
     39a:	62 27       	eor	r22, r18
     39c:	68 bb       	out	0x18, r22	; 24
		break;
     39e:	08 95       	ret
		case 'C':
		PORTC^=(1<<pinnumber);
     3a0:	25 b3       	in	r18, 0x15	; 21
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	ac 01       	movw	r20, r24
     3a8:	02 c0       	rjmp	.+4      	; 0x3ae <DIO_toggle+0x5a>
     3aa:	44 0f       	add	r20, r20
     3ac:	55 1f       	adc	r21, r21
     3ae:	6a 95       	dec	r22
     3b0:	e2 f7       	brpl	.-8      	; 0x3aa <DIO_toggle+0x56>
     3b2:	ba 01       	movw	r22, r20
     3b4:	62 27       	eor	r22, r18
     3b6:	65 bb       	out	0x15, r22	; 21
		break;
     3b8:	08 95       	ret
		case 'D':
		PORTD^=(1<<pinnumber);
     3ba:	22 b3       	in	r18, 0x12	; 18
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	ac 01       	movw	r20, r24
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_toggle+0x74>
     3c4:	44 0f       	add	r20, r20
     3c6:	55 1f       	adc	r21, r21
     3c8:	6a 95       	dec	r22
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_toggle+0x70>
     3cc:	ba 01       	movw	r22, r20
     3ce:	62 27       	eor	r22, r18
     3d0:	62 bb       	out	0x12, r22	; 18
     3d2:	08 95       	ret

000003d4 <DIO_write_port>:
		default: break;
	}
}
void DIO_write_port(char portname,char portvalue)
{
	switch(portname)
     3d4:	82 34       	cpi	r24, 0x42	; 66
     3d6:	61 f0       	breq	.+24     	; 0x3f0 <DIO_write_port+0x1c>
     3d8:	83 34       	cpi	r24, 0x43	; 67
     3da:	18 f4       	brcc	.+6      	; 0x3e2 <DIO_write_port+0xe>
     3dc:	81 34       	cpi	r24, 0x41	; 65
     3de:	69 f4       	brne	.+26     	; 0x3fa <DIO_write_port+0x26>
     3e0:	05 c0       	rjmp	.+10     	; 0x3ec <DIO_write_port+0x18>
     3e2:	83 34       	cpi	r24, 0x43	; 67
     3e4:	39 f0       	breq	.+14     	; 0x3f4 <DIO_write_port+0x20>
     3e6:	84 34       	cpi	r24, 0x44	; 68
     3e8:	41 f4       	brne	.+16     	; 0x3fa <DIO_write_port+0x26>
     3ea:	06 c0       	rjmp	.+12     	; 0x3f8 <DIO_write_port+0x24>
	{
		case 'A' :
		PORTA=portvalue;
     3ec:	6b bb       	out	0x1b, r22	; 27
		break ;
     3ee:	08 95       	ret
		case 'B':
		PORTB=portvalue;
     3f0:	68 bb       	out	0x18, r22	; 24
		break ;
     3f2:	08 95       	ret
		case 'C' :
		PORTC=portvalue;
     3f4:	65 bb       	out	0x15, r22	; 21
		break ;
     3f6:	08 95       	ret
		case 'D':
		PORTD=portvalue;
     3f8:	62 bb       	out	0x12, r22	; 18
     3fa:	08 95       	ret

000003fc <dio_write_highnibble>:
		default: break ;
	}
}
void dio_write_highnibble(char portname,char value)
{
		switch(portname)
     3fc:	82 34       	cpi	r24, 0x42	; 66
     3fe:	79 f0       	breq	.+30     	; 0x41e <dio_write_highnibble+0x22>
     400:	83 34       	cpi	r24, 0x43	; 67
     402:	18 f4       	brcc	.+6      	; 0x40a <dio_write_highnibble+0xe>
     404:	81 34       	cpi	r24, 0x41	; 65
     406:	c9 f4       	brne	.+50     	; 0x43a <dio_write_highnibble+0x3e>
     408:	05 c0       	rjmp	.+10     	; 0x414 <dio_write_highnibble+0x18>
     40a:	83 34       	cpi	r24, 0x43	; 67
     40c:	69 f0       	breq	.+26     	; 0x428 <dio_write_highnibble+0x2c>
     40e:	84 34       	cpi	r24, 0x44	; 68
     410:	a1 f4       	brne	.+40     	; 0x43a <dio_write_highnibble+0x3e>
     412:	0f c0       	rjmp	.+30     	; 0x432 <dio_write_highnibble+0x36>
		{
			case 'A' :
			PORTA|=(value&0xf0);
     414:	8b b3       	in	r24, 0x1b	; 27
     416:	60 7f       	andi	r22, 0xF0	; 240
     418:	68 2b       	or	r22, r24
     41a:	6b bb       	out	0x1b, r22	; 27
			break ;
     41c:	08 95       	ret
			case 'B':
			PORTB|=(value&0xf0);
     41e:	88 b3       	in	r24, 0x18	; 24
     420:	60 7f       	andi	r22, 0xF0	; 240
     422:	68 2b       	or	r22, r24
     424:	68 bb       	out	0x18, r22	; 24
			break ;
     426:	08 95       	ret
			case 'C' :
			PORTC|=(value&0xf0);
     428:	85 b3       	in	r24, 0x15	; 21
     42a:	60 7f       	andi	r22, 0xF0	; 240
     42c:	68 2b       	or	r22, r24
     42e:	65 bb       	out	0x15, r22	; 21
			break ;
     430:	08 95       	ret
			case 'D':
			PORTD|=(value&0xf0);
     432:	82 b3       	in	r24, 0x12	; 18
     434:	60 7f       	andi	r22, 0xF0	; 240
     436:	68 2b       	or	r22, r24
     438:	62 bb       	out	0x12, r22	; 18
     43a:	08 95       	ret

0000043c <clear_high_nibble>:
	
}
}
void clear_high_nibble(char portname)
{
	switch(portname)
     43c:	82 34       	cpi	r24, 0x42	; 66
     43e:	71 f0       	breq	.+28     	; 0x45c <clear_high_nibble+0x20>
     440:	83 34       	cpi	r24, 0x43	; 67
     442:	18 f4       	brcc	.+6      	; 0x44a <clear_high_nibble+0xe>
     444:	81 34       	cpi	r24, 0x41	; 65
     446:	a9 f4       	brne	.+42     	; 0x472 <clear_high_nibble+0x36>
     448:	05 c0       	rjmp	.+10     	; 0x454 <clear_high_nibble+0x18>
     44a:	83 34       	cpi	r24, 0x43	; 67
     44c:	59 f0       	breq	.+22     	; 0x464 <clear_high_nibble+0x28>
     44e:	84 34       	cpi	r24, 0x44	; 68
     450:	81 f4       	brne	.+32     	; 0x472 <clear_high_nibble+0x36>
     452:	0c c0       	rjmp	.+24     	; 0x46c <clear_high_nibble+0x30>
	{
		case 'A' :
		PORTA&=0x0f;
     454:	8b b3       	in	r24, 0x1b	; 27
     456:	8f 70       	andi	r24, 0x0F	; 15
     458:	8b bb       	out	0x1b, r24	; 27
		break ;
     45a:	08 95       	ret
		case 'B':
		PORTB&=0x0f;
     45c:	88 b3       	in	r24, 0x18	; 24
     45e:	8f 70       	andi	r24, 0x0F	; 15
     460:	88 bb       	out	0x18, r24	; 24
		break ;
     462:	08 95       	ret
		case 'C' :
		PORTC&=0x0f;
     464:	85 b3       	in	r24, 0x15	; 21
     466:	8f 70       	andi	r24, 0x0F	; 15
     468:	85 bb       	out	0x15, r24	; 21
		break ;
     46a:	08 95       	ret
		case 'D':
		PORTD&=0x0f;
     46c:	82 b3       	in	r24, 0x12	; 18
     46e:	8f 70       	andi	r24, 0x0F	; 15
     470:	82 bb       	out	0x12, r24	; 18
     472:	08 95       	ret

00000474 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     474:	44 23       	and	r20, r20
     476:	41 f4       	brne	.+16     	; 0x488 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     478:	68 23       	and	r22, r24
     47a:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	61 15       	cp	r22, r1
     480:	71 05       	cpc	r23, r1
     482:	51 f4       	brne	.+20     	; 0x498 <prvTestWaitCondition+0x24>
     484:	80 e0       	ldi	r24, 0x00	; 0
     486:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     488:	9b 01       	movw	r18, r22
     48a:	28 23       	and	r18, r24
     48c:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	62 17       	cp	r22, r18
     492:	73 07       	cpc	r23, r19
     494:	09 f0       	breq	.+2      	; 0x498 <prvTestWaitCondition+0x24>
     496:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     498:	08 95       	ret

0000049a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     49e:	8b e0       	ldi	r24, 0x0B	; 11
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <pvPortMalloc>
     4a6:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     4a8:	00 97       	sbiw	r24, 0x00	; 0
     4aa:	31 f0       	breq	.+12     	; 0x4b8 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     4ac:	fc 01       	movw	r30, r24
     4ae:	11 92       	st	Z+, r1
     4b0:	11 92       	st	Z+, r1
     4b2:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     4b4:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     4b8:	8c 2f       	mov	r24, r28
     4ba:	9d 2f       	mov	r25, r29
     4bc:	df 91       	pop	r29
     4be:	cf 91       	pop	r28
     4c0:	08 95       	ret

000004c2 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     4c2:	af 92       	push	r10
     4c4:	bf 92       	push	r11
     4c6:	cf 92       	push	r12
     4c8:	df 92       	push	r13
     4ca:	ef 92       	push	r14
     4cc:	ff 92       	push	r15
     4ce:	0f 93       	push	r16
     4d0:	1f 93       	push	r17
     4d2:	cf 93       	push	r28
     4d4:	df 93       	push	r29
     4d6:	5c 01       	movw	r10, r24
     4d8:	6b 01       	movw	r12, r22
     4da:	e4 2e       	mov	r14, r20
     4dc:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     4de:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     4e2:	f5 01       	movw	r30, r10
     4e4:	c0 81       	ld	r28, Z
     4e6:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     4e8:	ce 01       	movw	r24, r28
     4ea:	b6 01       	movw	r22, r12
     4ec:	4f 2d       	mov	r20, r15
     4ee:	0e 94 3a 02 	call	0x474	; 0x474 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     4f2:	88 23       	and	r24, r24
     4f4:	51 f0       	breq	.+20     	; 0x50a <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     4f6:	ee 20       	and	r14, r14
     4f8:	01 f1       	breq	.+64     	; 0x53a <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     4fa:	c0 94       	com	r12
     4fc:	d0 94       	com	r13
     4fe:	cc 22       	and	r12, r28
     500:	dd 22       	and	r13, r29
     502:	f5 01       	movw	r30, r10
     504:	d1 82       	std	Z+1, r13	; 0x01
     506:	c0 82       	st	Z, r12
     508:	18 c0       	rjmp	.+48     	; 0x53a <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     50a:	01 15       	cp	r16, r1
     50c:	11 05       	cpc	r17, r1
     50e:	a9 f0       	breq	.+42     	; 0x53a <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     510:	ee 20       	and	r14, r14
     512:	19 f4       	brne	.+6      	; 0x51a <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     514:	60 e0       	ldi	r22, 0x00	; 0
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	02 c0       	rjmp	.+4      	; 0x51e <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     51a:	60 e0       	ldi	r22, 0x00	; 0
     51c:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     51e:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     520:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     522:	6c 29       	or	r22, r12
     524:	7d 29       	or	r23, r13
     526:	c5 01       	movw	r24, r10
     528:	02 96       	adiw	r24, 0x02	; 2
     52a:	a8 01       	movw	r20, r16
     52c:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     530:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     534:	88 23       	and	r24, r24
     536:	39 f4       	brne	.+14     	; 0x546 <xEventGroupWaitBits+0x84>
     538:	04 c0       	rjmp	.+8      	; 0x542 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     53a:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
     53e:	ce 01       	movw	r24, r28
     540:	21 c0       	rjmp	.+66     	; 0x584 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     542:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     546:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <uxTaskResetEventItemValue>
     54a:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     54c:	91 fd       	sbrc	r25, 1
     54e:	18 c0       	rjmp	.+48     	; 0x580 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     550:	0f b6       	in	r0, 0x3f	; 63
     552:	f8 94       	cli
     554:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     556:	f5 01       	movw	r30, r10
     558:	c0 81       	ld	r28, Z
     55a:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     55c:	ce 01       	movw	r24, r28
     55e:	b6 01       	movw	r22, r12
     560:	4f 2d       	mov	r20, r15
     562:	0e 94 3a 02 	call	0x474	; 0x474 <prvTestWaitCondition>
     566:	88 23       	and	r24, r24
     568:	49 f0       	breq	.+18     	; 0x57c <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     56a:	ee 20       	and	r14, r14
     56c:	39 f0       	breq	.+14     	; 0x57c <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     56e:	c0 94       	com	r12
     570:	d0 94       	com	r13
     572:	cc 22       	and	r12, r28
     574:	dd 22       	and	r13, r29
     576:	f5 01       	movw	r30, r10
     578:	d1 82       	std	Z+1, r13	; 0x01
     57a:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     57c:	0f 90       	pop	r0
     57e:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     580:	ce 01       	movw	r24, r28
     582:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	1f 91       	pop	r17
     58a:	0f 91       	pop	r16
     58c:	ff 90       	pop	r15
     58e:	ef 90       	pop	r14
     590:	df 90       	pop	r13
     592:	cf 90       	pop	r12
     594:	bf 90       	pop	r11
     596:	af 90       	pop	r10
     598:	08 95       	ret

0000059a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     59a:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     59c:	0f b6       	in	r0, 0x3f	; 63
     59e:	f8 94       	cli
     5a0:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     5a2:	80 81       	ld	r24, Z
     5a4:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     5a6:	60 95       	com	r22
     5a8:	70 95       	com	r23
     5aa:	68 23       	and	r22, r24
     5ac:	79 23       	and	r23, r25
     5ae:	71 83       	std	Z+1, r23	; 0x01
     5b0:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     5b2:	0f 90       	pop	r0
     5b4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     5b6:	08 95       	ret

000005b8 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     5b8:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     5ba:	80 81       	ld	r24, Z
     5bc:	91 81       	ldd	r25, Z+1	; 0x01
     5be:	08 95       	ret

000005c0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     5c0:	af 92       	push	r10
     5c2:	bf 92       	push	r11
     5c4:	cf 92       	push	r12
     5c6:	df 92       	push	r13
     5c8:	ef 92       	push	r14
     5ca:	ff 92       	push	r15
     5cc:	0f 93       	push	r16
     5ce:	1f 93       	push	r17
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	8c 01       	movw	r16, r24
     5d6:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	0f 2e       	mov	r0, r31
     5da:	f5 e0       	ldi	r31, 0x05	; 5
     5dc:	cf 2e       	mov	r12, r31
     5de:	dd 24       	eor	r13, r13
     5e0:	f0 2d       	mov	r31, r0
     5e2:	c8 0e       	add	r12, r24
     5e4:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     5e6:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     5ea:	d8 01       	movw	r26, r16
     5ec:	17 96       	adiw	r26, 0x07	; 7
     5ee:	ed 91       	ld	r30, X+
     5f0:	fc 91       	ld	r31, X
     5f2:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     5f4:	8d 91       	ld	r24, X+
     5f6:	9c 91       	ld	r25, X
     5f8:	11 97       	sbiw	r26, 0x01	; 1
     5fa:	8c 2b       	or	r24, r28
     5fc:	9d 2b       	or	r25, r29
     5fe:	11 96       	adiw	r26, 0x01	; 1
     600:	9c 93       	st	X, r25
     602:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     604:	ce 16       	cp	r12, r30
     606:	df 06       	cpc	r13, r31
     608:	c1 f1       	breq	.+112    	; 0x67a <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     60a:	aa 24       	eor	r10, r10
     60c:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     60e:	ff 24       	eor	r15, r15
     610:	f3 94       	inc	r15
     612:	ee 24       	eor	r14, r14
     614:	01 c0       	rjmp	.+2      	; 0x618 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     616:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     618:	c2 81       	ldd	r28, Z+2	; 0x02
     61a:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     620:	bc 01       	movw	r22, r24
     622:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     624:	9c 01       	movw	r18, r24
     626:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     628:	92 fd       	sbrc	r25, 2
     62a:	0b c0       	rjmp	.+22     	; 0x642 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     62c:	d8 01       	movw	r26, r16
     62e:	8d 91       	ld	r24, X+
     630:	9c 91       	ld	r25, X
     632:	11 97       	sbiw	r26, 0x01	; 1
     634:	82 23       	and	r24, r18
     636:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     638:	4f 2d       	mov	r20, r15
     63a:	00 97       	sbiw	r24, 0x00	; 0
     63c:	69 f4       	brne	.+26     	; 0x658 <xEventGroupSetBits+0x98>
     63e:	4e 2d       	mov	r20, r14
     640:	0b c0       	rjmp	.+22     	; 0x658 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     642:	d8 01       	movw	r26, r16
     644:	8d 91       	ld	r24, X+
     646:	9c 91       	ld	r25, X
     648:	11 97       	sbiw	r26, 0x01	; 1
     64a:	82 23       	and	r24, r18
     64c:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     64e:	4f 2d       	mov	r20, r15
     650:	28 17       	cp	r18, r24
     652:	39 07       	cpc	r19, r25
     654:	09 f0       	breq	.+2      	; 0x658 <xEventGroupSetBits+0x98>
     656:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     658:	44 23       	and	r20, r20
     65a:	59 f0       	breq	.+22     	; 0x672 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     65c:	70 ff       	sbrs	r23, 0
     65e:	02 c0       	rjmp	.+4      	; 0x664 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     660:	a2 2a       	or	r10, r18
     662:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     664:	d8 01       	movw	r26, r16
     666:	6d 91       	ld	r22, X+
     668:	7c 91       	ld	r23, X
     66a:	72 60       	ori	r23, 0x02	; 2
     66c:	cf 01       	movw	r24, r30
     66e:	0e 94 b7 11 	call	0x236e	; 0x236e <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     672:	cc 16       	cp	r12, r28
     674:	dd 06       	cpc	r13, r29
     676:	79 f6       	brne	.-98     	; 0x616 <xEventGroupSetBits+0x56>
     678:	02 c0       	rjmp	.+4      	; 0x67e <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     67a:	aa 24       	eor	r10, r10
     67c:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     67e:	c5 01       	movw	r24, r10
     680:	80 95       	com	r24
     682:	90 95       	com	r25
     684:	f8 01       	movw	r30, r16
     686:	a0 80       	ld	r10, Z
     688:	b1 80       	ldd	r11, Z+1	; 0x01
     68a:	a8 22       	and	r10, r24
     68c:	b9 22       	and	r11, r25
     68e:	b1 82       	std	Z+1, r11	; 0x01
     690:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     692:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     696:	d8 01       	movw	r26, r16
     698:	8c 91       	ld	r24, X
     69a:	11 96       	adiw	r26, 0x01	; 1
     69c:	9c 91       	ld	r25, X
     69e:	11 97       	sbiw	r26, 0x01	; 1
     6a0:	df 91       	pop	r29
     6a2:	cf 91       	pop	r28
     6a4:	1f 91       	pop	r17
     6a6:	0f 91       	pop	r16
     6a8:	ff 90       	pop	r15
     6aa:	ef 90       	pop	r14
     6ac:	df 90       	pop	r13
     6ae:	cf 90       	pop	r12
     6b0:	bf 90       	pop	r11
     6b2:	af 90       	pop	r10
     6b4:	08 95       	ret

000006b6 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     6b6:	af 92       	push	r10
     6b8:	bf 92       	push	r11
     6ba:	cf 92       	push	r12
     6bc:	df 92       	push	r13
     6be:	ef 92       	push	r14
     6c0:	ff 92       	push	r15
     6c2:	0f 93       	push	r16
     6c4:	1f 93       	push	r17
     6c6:	cf 93       	push	r28
     6c8:	df 93       	push	r29
     6ca:	6c 01       	movw	r12, r24
     6cc:	eb 01       	movw	r28, r22
     6ce:	7a 01       	movw	r14, r20
     6d0:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     6d2:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     6d6:	f6 01       	movw	r30, r12
     6d8:	00 81       	ld	r16, Z
     6da:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     6dc:	c6 01       	movw	r24, r12
     6de:	be 01       	movw	r22, r28
     6e0:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6e4:	c0 2b       	or	r28, r16
     6e6:	d1 2b       	or	r29, r17
     6e8:	c7 01       	movw	r24, r14
     6ea:	8c 23       	and	r24, r28
     6ec:	9d 23       	and	r25, r29
     6ee:	8e 15       	cp	r24, r14
     6f0:	9f 05       	cpc	r25, r15
     6f2:	51 f4       	brne	.+20     	; 0x708 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     6f4:	80 95       	com	r24
     6f6:	90 95       	com	r25
     6f8:	f6 01       	movw	r30, r12
     6fa:	20 81       	ld	r18, Z
     6fc:	31 81       	ldd	r19, Z+1	; 0x01
     6fe:	82 23       	and	r24, r18
     700:	93 23       	and	r25, r19
     702:	91 83       	std	Z+1, r25	; 0x01
     704:	80 83       	st	Z, r24
     706:	12 c0       	rjmp	.+36     	; 0x72c <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     708:	a1 14       	cp	r10, r1
     70a:	b1 04       	cpc	r11, r1
     70c:	61 f0       	breq	.+24     	; 0x726 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     70e:	b7 01       	movw	r22, r14
     710:	75 60       	ori	r23, 0x05	; 5
     712:	c6 01       	movw	r24, r12
     714:	02 96       	adiw	r24, 0x02	; 2
     716:	a5 01       	movw	r20, r10
     718:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     71c:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     720:	88 23       	and	r24, r24
     722:	49 f4       	brne	.+18     	; 0x736 <xEventGroupSync+0x80>
     724:	06 c0       	rjmp	.+12     	; 0x732 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     726:	f6 01       	movw	r30, r12
     728:	c0 81       	ld	r28, Z
     72a:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     72c:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
     730:	1c c0       	rjmp	.+56     	; 0x76a <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     732:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     736:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     73a:	91 fd       	sbrc	r25, 1
     73c:	14 c0       	rjmp	.+40     	; 0x766 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     73e:	0f b6       	in	r0, 0x3f	; 63
     740:	f8 94       	cli
     742:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     744:	f6 01       	movw	r30, r12
     746:	80 81       	ld	r24, Z
     748:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     74a:	97 01       	movw	r18, r14
     74c:	28 23       	and	r18, r24
     74e:	39 23       	and	r19, r25
     750:	2e 15       	cp	r18, r14
     752:	3f 05       	cpc	r19, r15
     754:	31 f4       	brne	.+12     	; 0x762 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     756:	20 95       	com	r18
     758:	30 95       	com	r19
     75a:	28 23       	and	r18, r24
     75c:	39 23       	and	r19, r25
     75e:	31 83       	std	Z+1, r19	; 0x01
     760:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     762:	0f 90       	pop	r0
     764:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     766:	ec 01       	movw	r28, r24
     768:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     76a:	8c 2f       	mov	r24, r28
     76c:	9d 2f       	mov	r25, r29
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	df 90       	pop	r13
     77c:	cf 90       	pop	r12
     77e:	bf 90       	pop	r11
     780:	af 90       	pop	r10
     782:	08 95       	ret

00000784 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     784:	cf 93       	push	r28
     786:	df 93       	push	r29
     788:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     78a:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     78e:	8a 81       	ldd	r24, Y+2	; 0x02
     790:	88 23       	and	r24, r24
     792:	49 f0       	breq	.+18     	; 0x7a6 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     794:	8f 81       	ldd	r24, Y+7	; 0x07
     796:	98 85       	ldd	r25, Y+8	; 0x08
     798:	60 e0       	ldi	r22, 0x00	; 0
     79a:	72 e0       	ldi	r23, 0x02	; 2
     79c:	0e 94 b7 11 	call	0x236e	; 0x236e <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7a0:	8a 81       	ldd	r24, Y+2	; 0x02
     7a2:	88 23       	and	r24, r24
     7a4:	b9 f7       	brne	.-18     	; 0x794 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     7a6:	ce 01       	movw	r24, r28
     7a8:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     7ac:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
}
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	08 95       	ret

000007b6 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     7b6:	ba 01       	movw	r22, r20
     7b8:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <xEventGroupSetBits>
}
     7bc:	08 95       	ret

000007be <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     7be:	ba 01       	movw	r22, r20
     7c0:	0e 94 cd 02 	call	0x59a	; 0x59a <xEventGroupClearBits>
}
     7c4:	08 95       	ret

000007c6 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7c6:	0f 93       	push	r16
     7c8:	1f 93       	push	r17
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     7d0:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     7d4:	80 91 6a 00 	lds	r24, 0x006A
     7d8:	88 23       	and	r24, r24
     7da:	f9 f4       	brne	.+62     	; 0x81a <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     7dc:	84 e7       	ldi	r24, 0x74	; 116
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	90 93 6c 00 	sts	0x006C, r25
     7e4:	80 93 6b 00 	sts	0x006B, r24
	xStart.xBlockSize = ( size_t ) 0;
     7e8:	10 92 6e 00 	sts	0x006E, r1
     7ec:	10 92 6d 00 	sts	0x006D, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     7f0:	8f e1       	ldi	r24, 0x1F	; 31
     7f2:	93 e0       	ldi	r25, 0x03	; 3
     7f4:	90 93 72 00 	sts	0x0072, r25
     7f8:	80 93 71 00 	sts	0x0071, r24
	xEnd.pxNextFreeBlock = NULL;
     7fc:	e1 e7       	ldi	r30, 0x71	; 113
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	12 92       	st	-Z, r1
     802:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     804:	90 93 77 00 	sts	0x0077, r25
     808:	80 93 76 00 	sts	0x0076, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     80c:	f0 93 75 00 	sts	0x0075, r31
     810:	e0 93 74 00 	sts	0x0074, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	80 93 6a 00 	sts	0x006A, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     81a:	20 97       	sbiw	r28, 0x00	; 0
     81c:	09 f4       	brne	.+2      	; 0x820 <pvPortMalloc+0x5a>
     81e:	62 c0       	rjmp	.+196    	; 0x8e4 <__stack+0x85>
		{
			xWantedSize += heapSTRUCT_SIZE;
     820:	9e 01       	movw	r18, r28
     822:	2c 5f       	subi	r18, 0xFC	; 252
     824:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     826:	23 96       	adiw	r28, 0x03	; 3
     828:	83 e0       	ldi	r24, 0x03	; 3
     82a:	ce 31       	cpi	r28, 0x1E	; 30
     82c:	d8 07       	cpc	r29, r24
     82e:	08 f0       	brcs	.+2      	; 0x832 <pvPortMalloc+0x6c>
     830:	5c c0       	rjmp	.+184    	; 0x8ea <__stack+0x8b>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     832:	e0 91 6b 00 	lds	r30, 0x006B
     836:	f0 91 6c 00 	lds	r31, 0x006C

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     83a:	ab e6       	ldi	r26, 0x6B	; 107
     83c:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     83e:	02 c0       	rjmp	.+4      	; 0x844 <pvPortMalloc+0x7e>
     840:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     842:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     844:	82 81       	ldd	r24, Z+2	; 0x02
     846:	93 81       	ldd	r25, Z+3	; 0x03
     848:	82 17       	cp	r24, r18
     84a:	93 07       	cpc	r25, r19
     84c:	20 f4       	brcc	.+8      	; 0x856 <pvPortMalloc+0x90>
     84e:	80 81       	ld	r24, Z
     850:	91 81       	ldd	r25, Z+1	; 0x01
     852:	00 97       	sbiw	r24, 0x00	; 0
     854:	a9 f7       	brne	.-22     	; 0x840 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	ef 36       	cpi	r30, 0x6F	; 111
     85a:	fc 07       	cpc	r31, r28
     85c:	09 f4       	brne	.+2      	; 0x860 <__stack+0x1>
     85e:	48 c0       	rjmp	.+144    	; 0x8f0 <__stack+0x91>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     860:	8d 91       	ld	r24, X+
     862:	9c 91       	ld	r25, X
     864:	11 97       	sbiw	r26, 0x01	; 1
     866:	8c 01       	movw	r16, r24
     868:	0c 5f       	subi	r16, 0xFC	; 252
     86a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     86c:	80 81       	ld	r24, Z
     86e:	91 81       	ldd	r25, Z+1	; 0x01
     870:	11 96       	adiw	r26, 0x01	; 1
     872:	9c 93       	st	X, r25
     874:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     876:	82 81       	ldd	r24, Z+2	; 0x02
     878:	93 81       	ldd	r25, Z+3	; 0x03
     87a:	82 1b       	sub	r24, r18
     87c:	93 0b       	sbc	r25, r19
     87e:	89 30       	cpi	r24, 0x09	; 9
     880:	91 05       	cpc	r25, r1
     882:	18 f1       	brcs	.+70     	; 0x8ca <__stack+0x6b>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     884:	af 01       	movw	r20, r30
     886:	42 0f       	add	r20, r18
     888:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     88a:	da 01       	movw	r26, r20
     88c:	13 96       	adiw	r26, 0x03	; 3
     88e:	9c 93       	st	X, r25
     890:	8e 93       	st	-X, r24
     892:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     894:	33 83       	std	Z+3, r19	; 0x03
     896:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     898:	12 96       	adiw	r26, 0x02	; 2
     89a:	2d 91       	ld	r18, X+
     89c:	3c 91       	ld	r19, X
     89e:	13 97       	sbiw	r26, 0x03	; 3
     8a0:	6b e6       	ldi	r22, 0x6B	; 107
     8a2:	70 e0       	ldi	r23, 0x00	; 0
     8a4:	01 c0       	rjmp	.+2      	; 0x8a8 <__stack+0x49>
     8a6:	bd 01       	movw	r22, r26
     8a8:	eb 01       	movw	r28, r22
     8aa:	a8 81       	ld	r26, Y
     8ac:	b9 81       	ldd	r27, Y+1	; 0x01
     8ae:	12 96       	adiw	r26, 0x02	; 2
     8b0:	8d 91       	ld	r24, X+
     8b2:	9c 91       	ld	r25, X
     8b4:	13 97       	sbiw	r26, 0x03	; 3
     8b6:	82 17       	cp	r24, r18
     8b8:	93 07       	cpc	r25, r19
     8ba:	a8 f3       	brcs	.-22     	; 0x8a6 <__stack+0x47>
     8bc:	ea 01       	movw	r28, r20
     8be:	b9 83       	std	Y+1, r27	; 0x01
     8c0:	a8 83       	st	Y, r26
     8c2:	db 01       	movw	r26, r22
     8c4:	11 96       	adiw	r26, 0x01	; 1
     8c6:	5c 93       	st	X, r21
     8c8:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     8ca:	80 91 60 00 	lds	r24, 0x0060
     8ce:	90 91 61 00 	lds	r25, 0x0061
     8d2:	22 81       	ldd	r18, Z+2	; 0x02
     8d4:	33 81       	ldd	r19, Z+3	; 0x03
     8d6:	82 1b       	sub	r24, r18
     8d8:	93 0b       	sbc	r25, r19
     8da:	90 93 61 00 	sts	0x0061, r25
     8de:	80 93 60 00 	sts	0x0060, r24
     8e2:	08 c0       	rjmp	.+16     	; 0x8f4 <__stack+0x95>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     8e4:	00 e0       	ldi	r16, 0x00	; 0
     8e6:	10 e0       	ldi	r17, 0x00	; 0
     8e8:	05 c0       	rjmp	.+10     	; 0x8f4 <__stack+0x95>
     8ea:	00 e0       	ldi	r16, 0x00	; 0
     8ec:	10 e0       	ldi	r17, 0x00	; 0
     8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <__stack+0x95>
     8f0:	00 e0       	ldi	r16, 0x00	; 0
     8f2:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     8f4:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     8f8:	80 2f       	mov	r24, r16
     8fa:	91 2f       	mov	r25, r17
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	1f 91       	pop	r17
     902:	0f 91       	pop	r16
     904:	08 95       	ret

00000906 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     906:	0f 93       	push	r16
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     910:	00 97       	sbiw	r24, 0x00	; 0
     912:	39 f1       	breq	.+78     	; 0x962 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     914:	8c 01       	movw	r16, r24
     916:	04 50       	subi	r16, 0x04	; 4
     918:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     91a:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     91e:	f8 01       	movw	r30, r16
     920:	22 81       	ldd	r18, Z+2	; 0x02
     922:	33 81       	ldd	r19, Z+3	; 0x03
     924:	ab e6       	ldi	r26, 0x6B	; 107
     926:	b0 e0       	ldi	r27, 0x00	; 0
     928:	01 c0       	rjmp	.+2      	; 0x92c <vPortFree+0x26>
     92a:	df 01       	movw	r26, r30
     92c:	ed 91       	ld	r30, X+
     92e:	fc 91       	ld	r31, X
     930:	11 97       	sbiw	r26, 0x01	; 1
     932:	82 81       	ldd	r24, Z+2	; 0x02
     934:	93 81       	ldd	r25, Z+3	; 0x03
     936:	82 17       	cp	r24, r18
     938:	93 07       	cpc	r25, r19
     93a:	b8 f3       	brcs	.-18     	; 0x92a <vPortFree+0x24>
     93c:	24 97       	sbiw	r28, 0x04	; 4
     93e:	f9 83       	std	Y+1, r31	; 0x01
     940:	e8 83       	st	Y, r30
     942:	0d 93       	st	X+, r16
     944:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     946:	80 91 60 00 	lds	r24, 0x0060
     94a:	90 91 61 00 	lds	r25, 0x0061
     94e:	2a 81       	ldd	r18, Y+2	; 0x02
     950:	3b 81       	ldd	r19, Y+3	; 0x03
     952:	82 0f       	add	r24, r18
     954:	93 1f       	adc	r25, r19
     956:	90 93 61 00 	sts	0x0061, r25
     95a:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     95e:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
	}
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	08 95       	ret

0000096c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     96c:	80 91 60 00 	lds	r24, 0x0060
     970:	90 91 61 00 	lds	r25, 0x0061
     974:	08 95       	ret

00000976 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     976:	08 95       	ret

00000978 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     978:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     97a:	03 96       	adiw	r24, 0x03	; 3
     97c:	92 83       	std	Z+2, r25	; 0x02
     97e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     980:	2f ef       	ldi	r18, 0xFF	; 255
     982:	3f ef       	ldi	r19, 0xFF	; 255
     984:	34 83       	std	Z+4, r19	; 0x04
     986:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     988:	96 83       	std	Z+6, r25	; 0x06
     98a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     98c:	90 87       	std	Z+8, r25	; 0x08
     98e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     990:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     992:	08 95       	ret

00000994 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     994:	fc 01       	movw	r30, r24
     996:	11 86       	std	Z+9, r1	; 0x09
     998:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     99a:	08 95       	ret

0000099c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
     9a0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9a2:	dc 01       	movw	r26, r24
     9a4:	11 96       	adiw	r26, 0x01	; 1
     9a6:	cd 91       	ld	r28, X+
     9a8:	dc 91       	ld	r29, X
     9aa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9ac:	d3 83       	std	Z+3, r29	; 0x03
     9ae:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9b0:	2c 81       	ldd	r18, Y+4	; 0x04
     9b2:	3d 81       	ldd	r19, Y+5	; 0x05
     9b4:	35 83       	std	Z+5, r19	; 0x05
     9b6:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9b8:	ac 81       	ldd	r26, Y+4	; 0x04
     9ba:	bd 81       	ldd	r27, Y+5	; 0x05
     9bc:	13 96       	adiw	r26, 0x03	; 3
     9be:	7c 93       	st	X, r23
     9c0:	6e 93       	st	-X, r22
     9c2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9c4:	7d 83       	std	Y+5, r23	; 0x05
     9c6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9c8:	91 87       	std	Z+9, r25	; 0x09
     9ca:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9cc:	fc 01       	movw	r30, r24
     9ce:	20 81       	ld	r18, Z
     9d0:	2f 5f       	subi	r18, 0xFF	; 255
     9d2:	20 83       	st	Z, r18
}
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	08 95       	ret

000009da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
     9de:	ac 01       	movw	r20, r24
     9e0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9e2:	28 81       	ld	r18, Y
     9e4:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
     9e8:	2f 3f       	cpi	r18, 0xFF	; 255
     9ea:	38 07       	cpc	r19, r24
     9ec:	21 f4       	brne	.+8      	; 0x9f6 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9ee:	fa 01       	movw	r30, r20
     9f0:	a7 81       	ldd	r26, Z+7	; 0x07
     9f2:	b0 85       	ldd	r27, Z+8	; 0x08
     9f4:	0d c0       	rjmp	.+26     	; 0xa10 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9f6:	da 01       	movw	r26, r20
     9f8:	13 96       	adiw	r26, 0x03	; 3
     9fa:	01 c0       	rjmp	.+2      	; 0x9fe <vListInsert+0x24>
     9fc:	df 01       	movw	r26, r30
     9fe:	12 96       	adiw	r26, 0x02	; 2
     a00:	ed 91       	ld	r30, X+
     a02:	fc 91       	ld	r31, X
     a04:	13 97       	sbiw	r26, 0x03	; 3
     a06:	80 81       	ld	r24, Z
     a08:	91 81       	ldd	r25, Z+1	; 0x01
     a0a:	28 17       	cp	r18, r24
     a0c:	39 07       	cpc	r19, r25
     a0e:	b0 f7       	brcc	.-20     	; 0x9fc <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a10:	12 96       	adiw	r26, 0x02	; 2
     a12:	ed 91       	ld	r30, X+
     a14:	fc 91       	ld	r31, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	fb 83       	std	Y+3, r31	; 0x03
     a1a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a1c:	d5 83       	std	Z+5, r29	; 0x05
     a1e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a20:	bd 83       	std	Y+5, r27	; 0x05
     a22:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a24:	13 96       	adiw	r26, 0x03	; 3
     a26:	dc 93       	st	X, r29
     a28:	ce 93       	st	-X, r28
     a2a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a2c:	59 87       	std	Y+9, r21	; 0x09
     a2e:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     a30:	fa 01       	movw	r30, r20
     a32:	80 81       	ld	r24, Z
     a34:	8f 5f       	subi	r24, 0xFF	; 255
     a36:	80 83       	st	Z, r24
}
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a44:	c0 85       	ldd	r28, Z+8	; 0x08
     a46:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a48:	a2 81       	ldd	r26, Z+2	; 0x02
     a4a:	b3 81       	ldd	r27, Z+3	; 0x03
     a4c:	84 81       	ldd	r24, Z+4	; 0x04
     a4e:	95 81       	ldd	r25, Z+5	; 0x05
     a50:	15 96       	adiw	r26, 0x05	; 5
     a52:	9c 93       	st	X, r25
     a54:	8e 93       	st	-X, r24
     a56:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a58:	a4 81       	ldd	r26, Z+4	; 0x04
     a5a:	b5 81       	ldd	r27, Z+5	; 0x05
     a5c:	82 81       	ldd	r24, Z+2	; 0x02
     a5e:	93 81       	ldd	r25, Z+3	; 0x03
     a60:	13 96       	adiw	r26, 0x03	; 3
     a62:	9c 93       	st	X, r25
     a64:	8e 93       	st	-X, r24
     a66:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a68:	a9 81       	ldd	r26, Y+1	; 0x01
     a6a:	ba 81       	ldd	r27, Y+2	; 0x02
     a6c:	ae 17       	cp	r26, r30
     a6e:	bf 07       	cpc	r27, r31
     a70:	31 f4       	brne	.+12     	; 0xa7e <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a72:	14 96       	adiw	r26, 0x04	; 4
     a74:	8d 91       	ld	r24, X+
     a76:	9c 91       	ld	r25, X
     a78:	15 97       	sbiw	r26, 0x05	; 5
     a7a:	9a 83       	std	Y+2, r25	; 0x02
     a7c:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     a7e:	11 86       	std	Z+9, r1	; 0x09
     a80:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a82:	88 81       	ld	r24, Y
     a84:	81 50       	subi	r24, 0x01	; 1
     a86:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     a88:	df 91       	pop	r29
     a8a:	cf 91       	pop	r28
     a8c:	08 95       	ret

00000a8e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a8e:	21 e1       	ldi	r18, 0x11	; 17
     a90:	fc 01       	movw	r30, r24
     a92:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	32 e2       	ldi	r19, 0x22	; 34
     a98:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     a9a:	fc 01       	movw	r30, r24
     a9c:	32 97       	sbiw	r30, 0x02	; 2
     a9e:	a3 e3       	ldi	r26, 0x33	; 51
     aa0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     aa2:	fc 01       	movw	r30, r24
     aa4:	33 97       	sbiw	r30, 0x03	; 3
     aa6:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     aa8:	fc 01       	movw	r30, r24
     aaa:	34 97       	sbiw	r30, 0x04	; 4
     aac:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     aae:	fc 01       	movw	r30, r24
     ab0:	35 97       	sbiw	r30, 0x05	; 5
     ab2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     ab4:	fc 01       	movw	r30, r24
     ab6:	36 97       	sbiw	r30, 0x06	; 6
     ab8:	60 e8       	ldi	r22, 0x80	; 128
     aba:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     abc:	fc 01       	movw	r30, r24
     abe:	37 97       	sbiw	r30, 0x07	; 7
     ac0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     ac2:	fc 01       	movw	r30, r24
     ac4:	38 97       	sbiw	r30, 0x08	; 8
     ac6:	62 e0       	ldi	r22, 0x02	; 2
     ac8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     aca:	fc 01       	movw	r30, r24
     acc:	39 97       	sbiw	r30, 0x09	; 9
     ace:	63 e0       	ldi	r22, 0x03	; 3
     ad0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     ad2:	fc 01       	movw	r30, r24
     ad4:	3a 97       	sbiw	r30, 0x0a	; 10
     ad6:	64 e0       	ldi	r22, 0x04	; 4
     ad8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     ada:	fc 01       	movw	r30, r24
     adc:	3b 97       	sbiw	r30, 0x0b	; 11
     ade:	65 e0       	ldi	r22, 0x05	; 5
     ae0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     ae2:	fc 01       	movw	r30, r24
     ae4:	3c 97       	sbiw	r30, 0x0c	; 12
     ae6:	66 e0       	ldi	r22, 0x06	; 6
     ae8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     aea:	fc 01       	movw	r30, r24
     aec:	3d 97       	sbiw	r30, 0x0d	; 13
     aee:	67 e0       	ldi	r22, 0x07	; 7
     af0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     af2:	fc 01       	movw	r30, r24
     af4:	3e 97       	sbiw	r30, 0x0e	; 14
     af6:	68 e0       	ldi	r22, 0x08	; 8
     af8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     afa:	fc 01       	movw	r30, r24
     afc:	3f 97       	sbiw	r30, 0x0f	; 15
     afe:	69 e0       	ldi	r22, 0x09	; 9
     b00:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     b02:	fc 01       	movw	r30, r24
     b04:	70 97       	sbiw	r30, 0x10	; 16
     b06:	60 e1       	ldi	r22, 0x10	; 16
     b08:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     b0a:	fc 01       	movw	r30, r24
     b0c:	71 97       	sbiw	r30, 0x11	; 17
     b0e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     b10:	fc 01       	movw	r30, r24
     b12:	72 97       	sbiw	r30, 0x12	; 18
     b14:	22 e1       	ldi	r18, 0x12	; 18
     b16:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     b18:	fc 01       	movw	r30, r24
     b1a:	73 97       	sbiw	r30, 0x13	; 19
     b1c:	23 e1       	ldi	r18, 0x13	; 19
     b1e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     b20:	fc 01       	movw	r30, r24
     b22:	74 97       	sbiw	r30, 0x14	; 20
     b24:	24 e1       	ldi	r18, 0x14	; 20
     b26:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     b28:	fc 01       	movw	r30, r24
     b2a:	75 97       	sbiw	r30, 0x15	; 21
     b2c:	25 e1       	ldi	r18, 0x15	; 21
     b2e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     b30:	fc 01       	movw	r30, r24
     b32:	76 97       	sbiw	r30, 0x16	; 22
     b34:	26 e1       	ldi	r18, 0x16	; 22
     b36:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     b38:	fc 01       	movw	r30, r24
     b3a:	77 97       	sbiw	r30, 0x17	; 23
     b3c:	27 e1       	ldi	r18, 0x17	; 23
     b3e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     b40:	fc 01       	movw	r30, r24
     b42:	78 97       	sbiw	r30, 0x18	; 24
     b44:	28 e1       	ldi	r18, 0x18	; 24
     b46:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     b48:	fc 01       	movw	r30, r24
     b4a:	79 97       	sbiw	r30, 0x19	; 25
     b4c:	29 e1       	ldi	r18, 0x19	; 25
     b4e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     b50:	fc 01       	movw	r30, r24
     b52:	7a 97       	sbiw	r30, 0x1a	; 26
     b54:	20 e2       	ldi	r18, 0x20	; 32
     b56:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     b58:	fc 01       	movw	r30, r24
     b5a:	7b 97       	sbiw	r30, 0x1b	; 27
     b5c:	21 e2       	ldi	r18, 0x21	; 33
     b5e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     b60:	fc 01       	movw	r30, r24
     b62:	7c 97       	sbiw	r30, 0x1c	; 28
     b64:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     b66:	fc 01       	movw	r30, r24
     b68:	7d 97       	sbiw	r30, 0x1d	; 29
     b6a:	23 e2       	ldi	r18, 0x23	; 35
     b6c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b6e:	fc 01       	movw	r30, r24
     b70:	7e 97       	sbiw	r30, 0x1e	; 30
     b72:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b74:	fc 01       	movw	r30, r24
     b76:	7f 97       	sbiw	r30, 0x1f	; 31
     b78:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     b7a:	fc 01       	movw	r30, r24
     b7c:	b0 97       	sbiw	r30, 0x20	; 32
     b7e:	26 e2       	ldi	r18, 0x26	; 38
     b80:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     b82:	fc 01       	movw	r30, r24
     b84:	b1 97       	sbiw	r30, 0x21	; 33
     b86:	27 e2       	ldi	r18, 0x27	; 39
     b88:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     b8a:	fc 01       	movw	r30, r24
     b8c:	b2 97       	sbiw	r30, 0x22	; 34
     b8e:	28 e2       	ldi	r18, 0x28	; 40
     b90:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     b92:	fc 01       	movw	r30, r24
     b94:	b3 97       	sbiw	r30, 0x23	; 35
     b96:	29 e2       	ldi	r18, 0x29	; 41
     b98:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     b9a:	fc 01       	movw	r30, r24
     b9c:	b4 97       	sbiw	r30, 0x24	; 36
     b9e:	20 e3       	ldi	r18, 0x30	; 48
     ba0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     ba2:	fc 01       	movw	r30, r24
     ba4:	b5 97       	sbiw	r30, 0x25	; 37
     ba6:	21 e3       	ldi	r18, 0x31	; 49
     ba8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     baa:	86 97       	sbiw	r24, 0x26	; 38
}
     bac:	08 95       	ret

00000bae <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     bae:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     bb0:	8c e7       	ldi	r24, 0x7C	; 124
     bb2:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     bb4:	8b e0       	ldi	r24, 0x0B	; 11
     bb6:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     bb8:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     bba:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     bbc:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     bbe:	a0 91 93 03 	lds	r26, 0x0393
     bc2:	b0 91 94 03 	lds	r27, 0x0394
     bc6:	cd 91       	ld	r28, X+
     bc8:	cd bf       	out	0x3d, r28	; 61
     bca:	dd 91       	ld	r29, X+
     bcc:	de bf       	out	0x3e, r29	; 62
     bce:	ff 91       	pop	r31
     bd0:	ef 91       	pop	r30
     bd2:	df 91       	pop	r29
     bd4:	cf 91       	pop	r28
     bd6:	bf 91       	pop	r27
     bd8:	af 91       	pop	r26
     bda:	9f 91       	pop	r25
     bdc:	8f 91       	pop	r24
     bde:	7f 91       	pop	r23
     be0:	6f 91       	pop	r22
     be2:	5f 91       	pop	r21
     be4:	4f 91       	pop	r20
     be6:	3f 91       	pop	r19
     be8:	2f 91       	pop	r18
     bea:	1f 91       	pop	r17
     bec:	0f 91       	pop	r16
     bee:	ff 90       	pop	r15
     bf0:	ef 90       	pop	r14
     bf2:	df 90       	pop	r13
     bf4:	cf 90       	pop	r12
     bf6:	bf 90       	pop	r11
     bf8:	af 90       	pop	r10
     bfa:	9f 90       	pop	r9
     bfc:	8f 90       	pop	r8
     bfe:	7f 90       	pop	r7
     c00:	6f 90       	pop	r6
     c02:	5f 90       	pop	r5
     c04:	4f 90       	pop	r4
     c06:	3f 90       	pop	r3
     c08:	2f 90       	pop	r2
     c0a:	1f 90       	pop	r1
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     c12:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	08 95       	ret

00000c18 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     c18:	08 95       	ret

00000c1a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c1a:	0f 92       	push	r0
     c1c:	0f b6       	in	r0, 0x3f	; 63
     c1e:	f8 94       	cli
     c20:	0f 92       	push	r0
     c22:	1f 92       	push	r1
     c24:	11 24       	eor	r1, r1
     c26:	2f 92       	push	r2
     c28:	3f 92       	push	r3
     c2a:	4f 92       	push	r4
     c2c:	5f 92       	push	r5
     c2e:	6f 92       	push	r6
     c30:	7f 92       	push	r7
     c32:	8f 92       	push	r8
     c34:	9f 92       	push	r9
     c36:	af 92       	push	r10
     c38:	bf 92       	push	r11
     c3a:	cf 92       	push	r12
     c3c:	df 92       	push	r13
     c3e:	ef 92       	push	r14
     c40:	ff 92       	push	r15
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	2f 93       	push	r18
     c48:	3f 93       	push	r19
     c4a:	4f 93       	push	r20
     c4c:	5f 93       	push	r21
     c4e:	6f 93       	push	r22
     c50:	7f 93       	push	r23
     c52:	8f 93       	push	r24
     c54:	9f 93       	push	r25
     c56:	af 93       	push	r26
     c58:	bf 93       	push	r27
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	ef 93       	push	r30
     c60:	ff 93       	push	r31
     c62:	a0 91 93 03 	lds	r26, 0x0393
     c66:	b0 91 94 03 	lds	r27, 0x0394
     c6a:	0d b6       	in	r0, 0x3d	; 61
     c6c:	0d 92       	st	X+, r0
     c6e:	0e b6       	in	r0, 0x3e	; 62
     c70:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c72:	0e 94 96 10 	call	0x212c	; 0x212c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c76:	a0 91 93 03 	lds	r26, 0x0393
     c7a:	b0 91 94 03 	lds	r27, 0x0394
     c7e:	cd 91       	ld	r28, X+
     c80:	cd bf       	out	0x3d, r28	; 61
     c82:	dd 91       	ld	r29, X+
     c84:	de bf       	out	0x3e, r29	; 62
     c86:	ff 91       	pop	r31
     c88:	ef 91       	pop	r30
     c8a:	df 91       	pop	r29
     c8c:	cf 91       	pop	r28
     c8e:	bf 91       	pop	r27
     c90:	af 91       	pop	r26
     c92:	9f 91       	pop	r25
     c94:	8f 91       	pop	r24
     c96:	7f 91       	pop	r23
     c98:	6f 91       	pop	r22
     c9a:	5f 91       	pop	r21
     c9c:	4f 91       	pop	r20
     c9e:	3f 91       	pop	r19
     ca0:	2f 91       	pop	r18
     ca2:	1f 91       	pop	r17
     ca4:	0f 91       	pop	r16
     ca6:	ff 90       	pop	r15
     ca8:	ef 90       	pop	r14
     caa:	df 90       	pop	r13
     cac:	cf 90       	pop	r12
     cae:	bf 90       	pop	r11
     cb0:	af 90       	pop	r10
     cb2:	9f 90       	pop	r9
     cb4:	8f 90       	pop	r8
     cb6:	7f 90       	pop	r7
     cb8:	6f 90       	pop	r6
     cba:	5f 90       	pop	r5
     cbc:	4f 90       	pop	r4
     cbe:	3f 90       	pop	r3
     cc0:	2f 90       	pop	r2
     cc2:	1f 90       	pop	r1
     cc4:	0f 90       	pop	r0
     cc6:	0f be       	out	0x3f, r0	; 63
     cc8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cca:	08 95       	ret

00000ccc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ccc:	0f 92       	push	r0
     cce:	0f b6       	in	r0, 0x3f	; 63
     cd0:	f8 94       	cli
     cd2:	0f 92       	push	r0
     cd4:	1f 92       	push	r1
     cd6:	11 24       	eor	r1, r1
     cd8:	2f 92       	push	r2
     cda:	3f 92       	push	r3
     cdc:	4f 92       	push	r4
     cde:	5f 92       	push	r5
     ce0:	6f 92       	push	r6
     ce2:	7f 92       	push	r7
     ce4:	8f 92       	push	r8
     ce6:	9f 92       	push	r9
     ce8:	af 92       	push	r10
     cea:	bf 92       	push	r11
     cec:	cf 92       	push	r12
     cee:	df 92       	push	r13
     cf0:	ef 92       	push	r14
     cf2:	ff 92       	push	r15
     cf4:	0f 93       	push	r16
     cf6:	1f 93       	push	r17
     cf8:	2f 93       	push	r18
     cfa:	3f 93       	push	r19
     cfc:	4f 93       	push	r20
     cfe:	5f 93       	push	r21
     d00:	6f 93       	push	r22
     d02:	7f 93       	push	r23
     d04:	8f 93       	push	r24
     d06:	9f 93       	push	r25
     d08:	af 93       	push	r26
     d0a:	bf 93       	push	r27
     d0c:	cf 93       	push	r28
     d0e:	df 93       	push	r29
     d10:	ef 93       	push	r30
     d12:	ff 93       	push	r31
     d14:	a0 91 93 03 	lds	r26, 0x0393
     d18:	b0 91 94 03 	lds	r27, 0x0394
     d1c:	0d b6       	in	r0, 0x3d	; 61
     d1e:	0d 92       	st	X+, r0
     d20:	0e b6       	in	r0, 0x3e	; 62
     d22:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d24:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskIncrementTick>
     d28:	88 23       	and	r24, r24
     d2a:	11 f0       	breq	.+4      	; 0xd30 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     d2c:	0e 94 96 10 	call	0x212c	; 0x212c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d30:	a0 91 93 03 	lds	r26, 0x0393
     d34:	b0 91 94 03 	lds	r27, 0x0394
     d38:	cd 91       	ld	r28, X+
     d3a:	cd bf       	out	0x3d, r28	; 61
     d3c:	dd 91       	ld	r29, X+
     d3e:	de bf       	out	0x3e, r29	; 62
     d40:	ff 91       	pop	r31
     d42:	ef 91       	pop	r30
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	bf 91       	pop	r27
     d4a:	af 91       	pop	r26
     d4c:	9f 91       	pop	r25
     d4e:	8f 91       	pop	r24
     d50:	7f 91       	pop	r23
     d52:	6f 91       	pop	r22
     d54:	5f 91       	pop	r21
     d56:	4f 91       	pop	r20
     d58:	3f 91       	pop	r19
     d5a:	2f 91       	pop	r18
     d5c:	1f 91       	pop	r17
     d5e:	0f 91       	pop	r16
     d60:	ff 90       	pop	r15
     d62:	ef 90       	pop	r14
     d64:	df 90       	pop	r13
     d66:	cf 90       	pop	r12
     d68:	bf 90       	pop	r11
     d6a:	af 90       	pop	r10
     d6c:	9f 90       	pop	r9
     d6e:	8f 90       	pop	r8
     d70:	7f 90       	pop	r7
     d72:	6f 90       	pop	r6
     d74:	5f 90       	pop	r5
     d76:	4f 90       	pop	r4
     d78:	3f 90       	pop	r3
     d7a:	2f 90       	pop	r2
     d7c:	1f 90       	pop	r1
     d7e:	0f 90       	pop	r0
     d80:	0f be       	out	0x3f, r0	; 63
     d82:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d84:	08 95       	ret

00000d86 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     d86:	0e 94 66 06 	call	0xccc	; 0xccc <vPortYieldFromTick>
		asm volatile ( "reti" );
     d8a:	18 95       	reti

00000d8c <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d8c:	0f b6       	in	r0, 0x3f	; 63
     d8e:	f8 94       	cli
     d90:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d92:	fc 01       	movw	r30, r24
     d94:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d96:	0f 90       	pop	r0
     d98:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
     d9a:	81 e0       	ldi	r24, 0x01	; 1
     d9c:	91 11       	cpse	r25, r1
     d9e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     da0:	08 95       	ret

00000da2 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     da2:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     da4:	44 8d       	ldd	r20, Z+28	; 0x1c
     da6:	44 23       	and	r20, r20
     da8:	c1 f0       	breq	.+48     	; 0xdda <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     daa:	26 81       	ldd	r18, Z+6	; 0x06
     dac:	37 81       	ldd	r19, Z+7	; 0x07
     dae:	24 0f       	add	r18, r20
     db0:	31 1d       	adc	r19, r1
     db2:	37 83       	std	Z+7, r19	; 0x07
     db4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     db6:	a2 81       	ldd	r26, Z+2	; 0x02
     db8:	b3 81       	ldd	r27, Z+3	; 0x03
     dba:	2a 17       	cp	r18, r26
     dbc:	3b 07       	cpc	r19, r27
     dbe:	20 f0       	brcs	.+8      	; 0xdc8 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     dc0:	20 81       	ld	r18, Z
     dc2:	31 81       	ldd	r19, Z+1	; 0x01
     dc4:	37 83       	std	Z+7, r19	; 0x07
     dc6:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     dc8:	36 81       	ldd	r19, Z+6	; 0x06
     dca:	27 81       	ldd	r18, Z+7	; 0x07
     dcc:	86 2f       	mov	r24, r22
     dce:	97 2f       	mov	r25, r23
     dd0:	63 2f       	mov	r22, r19
     dd2:	72 2f       	mov	r23, r18
     dd4:	50 e0       	ldi	r21, 0x00	; 0
     dd6:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <memcpy>
     dda:	08 95       	ret

00000ddc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     ddc:	ef 92       	push	r14
     dde:	ff 92       	push	r15
     de0:	0f 93       	push	r16
     de2:	1f 93       	push	r17
     de4:	cf 93       	push	r28
     de6:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     de8:	0f b6       	in	r0, 0x3f	; 63
     dea:	f8 94       	cli
     dec:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     dee:	fc 01       	movw	r30, r24
     df0:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     df2:	1c 16       	cp	r1, r28
     df4:	cc f4       	brge	.+50     	; 0xe28 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     df6:	81 89       	ldd	r24, Z+17	; 0x11
     df8:	88 23       	and	r24, r24
     dfa:	31 f4       	brne	.+12     	; 0xe08 <prvUnlockQueue+0x2c>
     dfc:	15 c0       	rjmp	.+42     	; 0xe28 <prvUnlockQueue+0x4c>
     dfe:	f8 01       	movw	r30, r16
     e00:	81 89       	ldd	r24, Z+17	; 0x11
     e02:	88 23       	and	r24, r24
     e04:	41 f4       	brne	.+16     	; 0xe16 <prvUnlockQueue+0x3a>
     e06:	10 c0       	rjmp	.+32     	; 0xe28 <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e08:	0f 2e       	mov	r0, r31
     e0a:	f1 e1       	ldi	r31, 0x11	; 17
     e0c:	ef 2e       	mov	r14, r31
     e0e:	ff 24       	eor	r15, r15
     e10:	f0 2d       	mov	r31, r0
     e12:	e0 0e       	add	r14, r16
     e14:	f1 1e       	adc	r15, r17
     e16:	c7 01       	movw	r24, r14
     e18:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
     e1c:	88 23       	and	r24, r24
     e1e:	11 f0       	breq	.+4      	; 0xe24 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     e20:	0e 94 31 12 	call	0x2462	; 0x2462 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     e24:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e26:	59 f7       	brne	.-42     	; 0xdfe <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     e28:	8f ef       	ldi	r24, 0xFF	; 255
     e2a:	f8 01       	movw	r30, r16
     e2c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     e38:	f8 01       	movw	r30, r16
     e3a:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     e3c:	1c 16       	cp	r1, r28
     e3e:	c4 f4       	brge	.+48     	; 0xe70 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e40:	80 85       	ldd	r24, Z+8	; 0x08
     e42:	88 23       	and	r24, r24
     e44:	31 f4       	brne	.+12     	; 0xe52 <prvUnlockQueue+0x76>
     e46:	14 c0       	rjmp	.+40     	; 0xe70 <prvUnlockQueue+0x94>
     e48:	f8 01       	movw	r30, r16
     e4a:	80 85       	ldd	r24, Z+8	; 0x08
     e4c:	88 23       	and	r24, r24
     e4e:	39 f4       	brne	.+14     	; 0xe5e <prvUnlockQueue+0x82>
     e50:	0f c0       	rjmp	.+30     	; 0xe70 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e52:	ee 24       	eor	r14, r14
     e54:	ff 24       	eor	r15, r15
     e56:	68 94       	set
     e58:	e3 f8       	bld	r14, 3
     e5a:	e0 0e       	add	r14, r16
     e5c:	f1 1e       	adc	r15, r17
     e5e:	c7 01       	movw	r24, r14
     e60:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
     e64:	88 23       	and	r24, r24
     e66:	11 f0       	breq	.+4      	; 0xe6c <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
     e68:	0e 94 31 12 	call	0x2462	; 0x2462 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     e6c:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     e6e:	61 f7       	brne	.-40     	; 0xe48 <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     e70:	8f ef       	ldi	r24, 0xFF	; 255
     e72:	f8 01       	movw	r30, r16
     e74:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e76:	0f 90       	pop	r0
     e78:	0f be       	out	0x3f, r0	; 63
}
     e7a:	cf 91       	pop	r28
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	ff 90       	pop	r15
     e82:	ef 90       	pop	r14
     e84:	08 95       	ret

00000e86 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     e86:	0f 93       	push	r16
     e88:	1f 93       	push	r17
     e8a:	cf 93       	push	r28
     e8c:	df 93       	push	r29
     e8e:	ec 01       	movw	r28, r24
     e90:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     e92:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     e94:	4c 8d       	ldd	r20, Y+28	; 0x1c
     e96:	44 23       	and	r20, r20
     e98:	61 f4       	brne	.+24     	; 0xeb2 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e9a:	88 81       	ld	r24, Y
     e9c:	99 81       	ldd	r25, Y+1	; 0x01
     e9e:	00 97       	sbiw	r24, 0x00	; 0
     ea0:	09 f0       	breq	.+2      	; 0xea4 <prvCopyDataToQueue+0x1e>
     ea2:	42 c0       	rjmp	.+132    	; 0xf28 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     ea4:	8a 81       	ldd	r24, Y+2	; 0x02
     ea6:	9b 81       	ldd	r25, Y+3	; 0x03
     ea8:	0e 94 98 12 	call	0x2530	; 0x2530 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     eac:	1b 82       	std	Y+3, r1	; 0x03
     eae:	1a 82       	std	Y+2, r1	; 0x02
     eb0:	42 c0       	rjmp	.+132    	; 0xf36 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     eb2:	11 23       	and	r17, r17
     eb4:	b9 f4       	brne	.+46     	; 0xee4 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	9d 81       	ldd	r25, Y+5	; 0x05
     eba:	50 e0       	ldi	r21, 0x00	; 0
     ebc:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ec0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ec2:	8c 81       	ldd	r24, Y+4	; 0x04
     ec4:	9d 81       	ldd	r25, Y+5	; 0x05
     ec6:	82 0f       	add	r24, r18
     ec8:	91 1d       	adc	r25, r1
     eca:	9d 83       	std	Y+5, r25	; 0x05
     ecc:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ece:	2a 81       	ldd	r18, Y+2	; 0x02
     ed0:	3b 81       	ldd	r19, Y+3	; 0x03
     ed2:	82 17       	cp	r24, r18
     ed4:	93 07       	cpc	r25, r19
     ed6:	50 f1       	brcs	.+84     	; 0xf2c <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ed8:	88 81       	ld	r24, Y
     eda:	99 81       	ldd	r25, Y+1	; 0x01
     edc:	9d 83       	std	Y+5, r25	; 0x05
     ede:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     ee0:	80 e0       	ldi	r24, 0x00	; 0
     ee2:	29 c0       	rjmp	.+82     	; 0xf36 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ee4:	8e 81       	ldd	r24, Y+6	; 0x06
     ee6:	9f 81       	ldd	r25, Y+7	; 0x07
     ee8:	50 e0       	ldi	r21, 0x00	; 0
     eea:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     eee:	4c 8d       	ldd	r20, Y+28	; 0x1c
     ef0:	50 e0       	ldi	r21, 0x00	; 0
     ef2:	50 95       	com	r21
     ef4:	41 95       	neg	r20
     ef6:	5f 4f       	sbci	r21, 0xFF	; 255
     ef8:	8e 81       	ldd	r24, Y+6	; 0x06
     efa:	9f 81       	ldd	r25, Y+7	; 0x07
     efc:	84 0f       	add	r24, r20
     efe:	95 1f       	adc	r25, r21
     f00:	9f 83       	std	Y+7, r25	; 0x07
     f02:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f04:	28 81       	ld	r18, Y
     f06:	39 81       	ldd	r19, Y+1	; 0x01
     f08:	82 17       	cp	r24, r18
     f0a:	93 07       	cpc	r25, r19
     f0c:	30 f4       	brcc	.+12     	; 0xf1a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f0e:	8a 81       	ldd	r24, Y+2	; 0x02
     f10:	9b 81       	ldd	r25, Y+3	; 0x03
     f12:	84 0f       	add	r24, r20
     f14:	95 1f       	adc	r25, r21
     f16:	9f 83       	std	Y+7, r25	; 0x07
     f18:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     f1a:	12 30       	cpi	r17, 0x02	; 2
     f1c:	49 f4       	brne	.+18     	; 0xf30 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f1e:	00 23       	and	r16, r16
     f20:	49 f0       	breq	.+18     	; 0xf34 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     f22:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	07 c0       	rjmp	.+14     	; 0xf36 <prvCopyDataToQueue+0xb0>
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	05 c0       	rjmp	.+10     	; 0xf36 <prvCopyDataToQueue+0xb0>
     f2c:	80 e0       	ldi	r24, 0x00	; 0
     f2e:	03 c0       	rjmp	.+6      	; 0xf36 <prvCopyDataToQueue+0xb0>
     f30:	80 e0       	ldi	r24, 0x00	; 0
     f32:	01 c0       	rjmp	.+2      	; 0xf36 <prvCopyDataToQueue+0xb0>
     f34:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     f36:	0f 5f       	subi	r16, 0xFF	; 255
     f38:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	08 95       	ret

00000f44 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     f4a:	0f b6       	in	r0, 0x3f	; 63
     f4c:	f8 94       	cli
     f4e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     f50:	48 81       	ld	r20, Y
     f52:	59 81       	ldd	r21, Y+1	; 0x01
     f54:	2b 8d       	ldd	r18, Y+27	; 0x1b
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	ec 8d       	ldd	r30, Y+28	; 0x1c
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	2e 9f       	mul	r18, r30
     f5e:	c0 01       	movw	r24, r0
     f60:	2f 9f       	mul	r18, r31
     f62:	90 0d       	add	r25, r0
     f64:	3e 9f       	mul	r19, r30
     f66:	90 0d       	add	r25, r0
     f68:	11 24       	eor	r1, r1
     f6a:	84 0f       	add	r24, r20
     f6c:	95 1f       	adc	r25, r21
     f6e:	9b 83       	std	Y+3, r25	; 0x03
     f70:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     f72:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     f74:	5d 83       	std	Y+5, r21	; 0x05
     f76:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     f78:	c9 01       	movw	r24, r18
     f7a:	01 97       	sbiw	r24, 0x01	; 1
     f7c:	e8 9f       	mul	r30, r24
     f7e:	90 01       	movw	r18, r0
     f80:	e9 9f       	mul	r30, r25
     f82:	30 0d       	add	r19, r0
     f84:	f8 9f       	mul	r31, r24
     f86:	30 0d       	add	r19, r0
     f88:	11 24       	eor	r1, r1
     f8a:	24 0f       	add	r18, r20
     f8c:	35 1f       	adc	r19, r21
     f8e:	3f 83       	std	Y+7, r19	; 0x07
     f90:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     f92:	8f ef       	ldi	r24, 0xFF	; 255
     f94:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     f96:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     f98:	66 23       	and	r22, r22
     f9a:	61 f4       	brne	.+24     	; 0xfb4 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f9c:	88 85       	ldd	r24, Y+8	; 0x08
     f9e:	88 23       	and	r24, r24
     fa0:	89 f0       	breq	.+34     	; 0xfc4 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fa2:	ce 01       	movw	r24, r28
     fa4:	08 96       	adiw	r24, 0x08	; 8
     fa6:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
     faa:	88 23       	and	r24, r24
     fac:	59 f0       	breq	.+22     	; 0xfc4 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     fae:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
     fb2:	08 c0       	rjmp	.+16     	; 0xfc4 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     fb4:	ce 01       	movw	r24, r28
     fb6:	08 96       	adiw	r24, 0x08	; 8
     fb8:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     fbc:	ce 01       	movw	r24, r28
     fbe:	41 96       	adiw	r24, 0x11	; 17
     fc0:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     fc8:	81 e0       	ldi	r24, 0x01	; 1
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	08 95       	ret

00000fd0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     fd0:	0f 93       	push	r16
     fd2:	1f 93       	push	r17
     fd4:	cf 93       	push	r28
     fd6:	df 93       	push	r29
     fd8:	08 2f       	mov	r16, r24
     fda:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     fdc:	66 23       	and	r22, r22
     fde:	21 f0       	breq	.+8      	; 0xfe8 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     fe0:	68 9f       	mul	r22, r24
     fe2:	c0 01       	movw	r24, r0
     fe4:	11 24       	eor	r1, r1
     fe6:	02 c0       	rjmp	.+4      	; 0xfec <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     fe8:	80 e0       	ldi	r24, 0x00	; 0
     fea:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     fec:	4f 96       	adiw	r24, 0x1f	; 31
     fee:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <pvPortMalloc>
     ff2:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     ff4:	00 97       	sbiw	r24, 0x00	; 0
     ff6:	71 f0       	breq	.+28     	; 0x1014 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     ff8:	11 23       	and	r17, r17
     ffa:	19 f4       	brne	.+6      	; 0x1002 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     ffc:	99 83       	std	Y+1, r25	; 0x01
     ffe:	88 83       	st	Y, r24
    1000:	03 c0       	rjmp	.+6      	; 0x1008 <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1002:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1004:	99 83       	std	Y+1, r25	; 0x01
    1006:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1008:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    100a:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    100c:	ce 01       	movw	r24, r28
    100e:	61 e0       	ldi	r22, 0x01	; 1
    1010:	0e 94 a2 07 	call	0xf44	; 0xf44 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1014:	8c 2f       	mov	r24, r28
    1016:	9d 2f       	mov	r25, r29
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	08 95       	ret

00001022 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1022:	8f 92       	push	r8
    1024:	9f 92       	push	r9
    1026:	bf 92       	push	r11
    1028:	cf 92       	push	r12
    102a:	df 92       	push	r13
    102c:	ef 92       	push	r14
    102e:	ff 92       	push	r15
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	00 d0       	rcall	.+0      	; 0x103a <xQueueGenericSend+0x18>
    103a:	00 d0       	rcall	.+0      	; 0x103c <xQueueGenericSend+0x1a>
    103c:	0f 92       	push	r0
    103e:	cd b7       	in	r28, 0x3d	; 61
    1040:	de b7       	in	r29, 0x3e	; 62
    1042:	8c 01       	movw	r16, r24
    1044:	4b 01       	movw	r8, r22
    1046:	5d 83       	std	Y+5, r21	; 0x05
    1048:	4c 83       	std	Y+4, r20	; 0x04
    104a:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    104c:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    104e:	bb 24       	eor	r11, r11
    1050:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1052:	cc 24       	eor	r12, r12
    1054:	dd 24       	eor	r13, r13
    1056:	68 94       	set
    1058:	c3 f8       	bld	r12, 3
    105a:	c8 0e       	add	r12, r24
    105c:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    105e:	0f b6       	in	r0, 0x3f	; 63
    1060:	f8 94       	cli
    1062:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1064:	f8 01       	movw	r30, r16
    1066:	92 8d       	ldd	r25, Z+26	; 0x1a
    1068:	83 8d       	ldd	r24, Z+27	; 0x1b
    106a:	98 17       	cp	r25, r24
    106c:	18 f0       	brcs	.+6      	; 0x1074 <xQueueGenericSend+0x52>
    106e:	f2 e0       	ldi	r31, 0x02	; 2
    1070:	ef 16       	cp	r14, r31
    1072:	d1 f4       	brne	.+52     	; 0x10a8 <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1074:	c8 01       	movw	r24, r16
    1076:	b4 01       	movw	r22, r8
    1078:	4e 2d       	mov	r20, r14
    107a:	0e 94 43 07 	call	0xe86	; 0xe86 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    107e:	f8 01       	movw	r30, r16
    1080:	91 89       	ldd	r25, Z+17	; 0x11
    1082:	99 23       	and	r25, r25
    1084:	49 f0       	breq	.+18     	; 0x1098 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1086:	c8 01       	movw	r24, r16
    1088:	41 96       	adiw	r24, 0x11	; 17
    108a:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    108e:	88 23       	and	r24, r24
    1090:	39 f0       	breq	.+14     	; 0x10a0 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1092:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    1096:	04 c0       	rjmp	.+8      	; 0x10a0 <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1098:	88 23       	and	r24, r24
    109a:	11 f0       	breq	.+4      	; 0x10a0 <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    109c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    10a0:	0f 90       	pop	r0
    10a2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10a4:	81 e0       	ldi	r24, 0x01	; 1
    10a6:	52 c0       	rjmp	.+164    	; 0x114c <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    10a8:	8c 81       	ldd	r24, Y+4	; 0x04
    10aa:	9d 81       	ldd	r25, Y+5	; 0x05
    10ac:	00 97       	sbiw	r24, 0x00	; 0
    10ae:	21 f4       	brne	.+8      	; 0x10b8 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10b0:	0f 90       	pop	r0
    10b2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	4a c0       	rjmp	.+148    	; 0x114c <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    10b8:	ff 20       	and	r15, r15
    10ba:	29 f4       	brne	.+10     	; 0x10c6 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10bc:	ce 01       	movw	r24, r28
    10be:	01 96       	adiw	r24, 0x01	; 1
    10c0:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    10c4:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    10c6:	0f 90       	pop	r0
    10c8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10ca:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10ce:	0f b6       	in	r0, 0x3f	; 63
    10d0:	f8 94       	cli
    10d2:	0f 92       	push	r0
    10d4:	f8 01       	movw	r30, r16
    10d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    10d8:	8f 3f       	cpi	r24, 0xFF	; 255
    10da:	09 f4       	brne	.+2      	; 0x10de <xQueueGenericSend+0xbc>
    10dc:	15 8e       	std	Z+29, r1	; 0x1d
    10de:	f8 01       	movw	r30, r16
    10e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    10e2:	8f 3f       	cpi	r24, 0xFF	; 255
    10e4:	09 f4       	brne	.+2      	; 0x10e8 <xQueueGenericSend+0xc6>
    10e6:	16 8e       	std	Z+30, r1	; 0x1e
    10e8:	0f 90       	pop	r0
    10ea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10ec:	ce 01       	movw	r24, r28
    10ee:	01 96       	adiw	r24, 0x01	; 1
    10f0:	be 01       	movw	r22, r28
    10f2:	6c 5f       	subi	r22, 0xFC	; 252
    10f4:	7f 4f       	sbci	r23, 0xFF	; 255
    10f6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskCheckForTimeOut>
    10fa:	88 23       	and	r24, r24
    10fc:	09 f5       	brne	.+66     	; 0x1140 <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    10fe:	0f b6       	in	r0, 0x3f	; 63
    1100:	f8 94       	cli
    1102:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1104:	f8 01       	movw	r30, r16
    1106:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    110c:	f8 01       	movw	r30, r16
    110e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1110:	98 17       	cp	r25, r24
    1112:	81 f4       	brne	.+32     	; 0x1134 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1114:	6c 81       	ldd	r22, Y+4	; 0x04
    1116:	7d 81       	ldd	r23, Y+5	; 0x05
    1118:	c6 01       	movw	r24, r12
    111a:	0e 94 41 11 	call	0x2282	; 0x2282 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    111e:	c8 01       	movw	r24, r16
    1120:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1124:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
    1128:	88 23       	and	r24, r24
    112a:	09 f0       	breq	.+2      	; 0x112e <xQueueGenericSend+0x10c>
    112c:	98 cf       	rjmp	.-208    	; 0x105e <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    112e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    1132:	95 cf       	rjmp	.-214    	; 0x105e <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1134:	c8 01       	movw	r24, r16
    1136:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    113a:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
    113e:	8f cf       	rjmp	.-226    	; 0x105e <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1140:	c8 01       	movw	r24, r16
    1142:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1146:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    114a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    114c:	0f 90       	pop	r0
    114e:	0f 90       	pop	r0
    1150:	0f 90       	pop	r0
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
    1156:	df 91       	pop	r29
    1158:	cf 91       	pop	r28
    115a:	1f 91       	pop	r17
    115c:	0f 91       	pop	r16
    115e:	ff 90       	pop	r15
    1160:	ef 90       	pop	r14
    1162:	df 90       	pop	r13
    1164:	cf 90       	pop	r12
    1166:	bf 90       	pop	r11
    1168:	9f 90       	pop	r9
    116a:	8f 90       	pop	r8
    116c:	08 95       	ret

0000116e <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    116e:	cf 93       	push	r28
    1170:	df 93       	push	r29
    1172:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1174:	81 e0       	ldi	r24, 0x01	; 1
    1176:	60 e0       	ldi	r22, 0x00	; 0
    1178:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xQueueGenericCreate>
    117c:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    117e:	00 97       	sbiw	r24, 0x00	; 0
    1180:	61 f0       	breq	.+24     	; 0x119a <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1182:	1b 82       	std	Y+3, r1	; 0x03
    1184:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1186:	19 82       	std	Y+1, r1	; 0x01
    1188:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    118a:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    118c:	60 e0       	ldi	r22, 0x00	; 0
    118e:	70 e0       	ldi	r23, 0x00	; 0
    1190:	40 e0       	ldi	r20, 0x00	; 0
    1192:	50 e0       	ldi	r21, 0x00	; 0
    1194:	20 e0       	ldi	r18, 0x00	; 0
    1196:	0e 94 11 08 	call	0x1022	; 0x1022 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    119a:	8c 2f       	mov	r24, r28
    119c:	9d 2f       	mov	r25, r29
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	08 95       	ret

000011a4 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    11a4:	ef 92       	push	r14
    11a6:	ff 92       	push	r15
    11a8:	0f 93       	push	r16
    11aa:	1f 93       	push	r17
    11ac:	cf 93       	push	r28
    11ae:	8c 01       	movw	r16, r24
    11b0:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11b2:	fc 01       	movw	r30, r24
    11b4:	92 8d       	ldd	r25, Z+26	; 0x1a
    11b6:	83 8d       	ldd	r24, Z+27	; 0x1b
    11b8:	98 17       	cp	r25, r24
    11ba:	10 f0       	brcs	.+4      	; 0x11c0 <xQueueGenericSendFromISR+0x1c>
    11bc:	22 30       	cpi	r18, 0x02	; 2
    11be:	f1 f4       	brne	.+60     	; 0x11fc <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    11c0:	f8 01       	movw	r30, r16
    11c2:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11c4:	c8 01       	movw	r24, r16
    11c6:	42 2f       	mov	r20, r18
    11c8:	0e 94 43 07 	call	0xe86	; 0xe86 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    11cc:	cf 3f       	cpi	r28, 0xFF	; 255
    11ce:	89 f4       	brne	.+34     	; 0x11f2 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11d0:	f8 01       	movw	r30, r16
    11d2:	81 89       	ldd	r24, Z+17	; 0x11
    11d4:	88 23       	and	r24, r24
    11d6:	a1 f0       	breq	.+40     	; 0x1200 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11d8:	c8 01       	movw	r24, r16
    11da:	41 96       	adiw	r24, 0x11	; 17
    11dc:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    11e0:	88 23       	and	r24, r24
    11e2:	81 f0       	breq	.+32     	; 0x1204 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    11e4:	e1 14       	cp	r14, r1
    11e6:	f1 04       	cpc	r15, r1
    11e8:	79 f0       	breq	.+30     	; 0x1208 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	f7 01       	movw	r30, r14
    11ee:	80 83       	st	Z, r24
    11f0:	0c c0       	rjmp	.+24     	; 0x120a <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    11f2:	cf 5f       	subi	r28, 0xFF	; 255
    11f4:	f8 01       	movw	r30, r16
    11f6:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	07 c0       	rjmp	.+14     	; 0x120a <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	05 c0       	rjmp	.+10     	; 0x120a <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	03 c0       	rjmp	.+6      	; 0x120a <xQueueGenericSendFromISR+0x66>
    1204:	81 e0       	ldi	r24, 0x01	; 1
    1206:	01 c0       	rjmp	.+2      	; 0x120a <xQueueGenericSendFromISR+0x66>
    1208:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    120a:	cf 91       	pop	r28
    120c:	1f 91       	pop	r17
    120e:	0f 91       	pop	r16
    1210:	ff 90       	pop	r15
    1212:	ef 90       	pop	r14
    1214:	08 95       	ret

00001216 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	fc 01       	movw	r30, r24
    121c:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    121e:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1220:	93 8d       	ldd	r25, Z+27	; 0x1b
    1222:	89 17       	cp	r24, r25
    1224:	b8 f4       	brcc	.+46     	; 0x1254 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1226:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1228:	8f 5f       	subi	r24, 0xFF	; 255
    122a:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    122c:	9f 3f       	cpi	r25, 0xFF	; 255
    122e:	71 f4       	brne	.+28     	; 0x124c <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1230:	81 89       	ldd	r24, Z+17	; 0x11
    1232:	88 23       	and	r24, r24
    1234:	89 f0       	breq	.+34     	; 0x1258 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1236:	cf 01       	movw	r24, r30
    1238:	41 96       	adiw	r24, 0x11	; 17
    123a:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    123e:	88 23       	and	r24, r24
    1240:	69 f0       	breq	.+26     	; 0x125c <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1242:	20 97       	sbiw	r28, 0x00	; 0
    1244:	69 f0       	breq	.+26     	; 0x1260 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	88 83       	st	Y, r24
    124a:	0b c0       	rjmp	.+22     	; 0x1262 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    124c:	9f 5f       	subi	r25, 0xFF	; 255
    124e:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	07 c0       	rjmp	.+14     	; 0x1262 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1254:	80 e0       	ldi	r24, 0x00	; 0
    1256:	05 c0       	rjmp	.+10     	; 0x1262 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	03 c0       	rjmp	.+6      	; 0x1262 <xQueueGiveFromISR+0x4c>
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	01 c0       	rjmp	.+2      	; 0x1262 <xQueueGiveFromISR+0x4c>
    1260:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	08 95       	ret

00001268 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1268:	8f 92       	push	r8
    126a:	9f 92       	push	r9
    126c:	af 92       	push	r10
    126e:	bf 92       	push	r11
    1270:	cf 92       	push	r12
    1272:	df 92       	push	r13
    1274:	ef 92       	push	r14
    1276:	ff 92       	push	r15
    1278:	0f 93       	push	r16
    127a:	1f 93       	push	r17
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	00 d0       	rcall	.+0      	; 0x1282 <xQueueGenericReceive+0x1a>
    1282:	00 d0       	rcall	.+0      	; 0x1284 <xQueueGenericReceive+0x1c>
    1284:	0f 92       	push	r0
    1286:	cd b7       	in	r28, 0x3d	; 61
    1288:	de b7       	in	r29, 0x3e	; 62
    128a:	7c 01       	movw	r14, r24
    128c:	4b 01       	movw	r8, r22
    128e:	5d 83       	std	Y+5, r21	; 0x05
    1290:	4c 83       	std	Y+4, r20	; 0x04
    1292:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1294:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1296:	dd 24       	eor	r13, r13
    1298:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    129a:	0f 2e       	mov	r0, r31
    129c:	f1 e1       	ldi	r31, 0x11	; 17
    129e:	af 2e       	mov	r10, r31
    12a0:	bb 24       	eor	r11, r11
    12a2:	f0 2d       	mov	r31, r0
    12a4:	a8 0e       	add	r10, r24
    12a6:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	f8 94       	cli
    12ac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12ae:	f7 01       	movw	r30, r14
    12b0:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    12b2:	11 23       	and	r17, r17
    12b4:	99 f1       	breq	.+102    	; 0x131c <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    12b6:	a6 80       	ldd	r10, Z+6	; 0x06
    12b8:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    12ba:	c7 01       	movw	r24, r14
    12bc:	b4 01       	movw	r22, r8
    12be:	0e 94 d1 06 	call	0xda2	; 0xda2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    12c2:	cc 20       	and	r12, r12
    12c4:	c9 f4       	brne	.+50     	; 0x12f8 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    12c6:	11 50       	subi	r17, 0x01	; 1
    12c8:	f7 01       	movw	r30, r14
    12ca:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12cc:	80 81       	ld	r24, Z
    12ce:	91 81       	ldd	r25, Z+1	; 0x01
    12d0:	00 97       	sbiw	r24, 0x00	; 0
    12d2:	29 f4       	brne	.+10     	; 0x12de <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    12d4:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <pvTaskIncrementMutexHeldCount>
    12d8:	f7 01       	movw	r30, r14
    12da:	93 83       	std	Z+3, r25	; 0x03
    12dc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12de:	f7 01       	movw	r30, r14
    12e0:	80 85       	ldd	r24, Z+8	; 0x08
    12e2:	88 23       	and	r24, r24
    12e4:	b9 f0       	breq	.+46     	; 0x1314 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12e6:	c7 01       	movw	r24, r14
    12e8:	08 96       	adiw	r24, 0x08	; 8
    12ea:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    12ee:	88 23       	and	r24, r24
    12f0:	89 f0       	breq	.+34     	; 0x1314 <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    12f2:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    12f6:	0e c0       	rjmp	.+28     	; 0x1314 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    12f8:	f7 01       	movw	r30, r14
    12fa:	b7 82       	std	Z+7, r11	; 0x07
    12fc:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12fe:	81 89       	ldd	r24, Z+17	; 0x11
    1300:	88 23       	and	r24, r24
    1302:	41 f0       	breq	.+16     	; 0x1314 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1304:	c7 01       	movw	r24, r14
    1306:	41 96       	adiw	r24, 0x11	; 17
    1308:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    130c:	88 23       	and	r24, r24
    130e:	11 f0       	breq	.+4      	; 0x1314 <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1310:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1314:	0f 90       	pop	r0
    1316:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	61 c0       	rjmp	.+194    	; 0x13de <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    131c:	8c 81       	ldd	r24, Y+4	; 0x04
    131e:	9d 81       	ldd	r25, Y+5	; 0x05
    1320:	00 97       	sbiw	r24, 0x00	; 0
    1322:	21 f4       	brne	.+8      	; 0x132c <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1328:	80 e0       	ldi	r24, 0x00	; 0
    132a:	59 c0       	rjmp	.+178    	; 0x13de <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    132c:	00 23       	and	r16, r16
    132e:	29 f4       	brne	.+10     	; 0x133a <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1330:	ce 01       	movw	r24, r28
    1332:	01 96       	adiw	r24, 0x01	; 1
    1334:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1338:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    133a:	0f 90       	pop	r0
    133c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    133e:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1342:	0f b6       	in	r0, 0x3f	; 63
    1344:	f8 94       	cli
    1346:	0f 92       	push	r0
    1348:	f7 01       	movw	r30, r14
    134a:	85 8d       	ldd	r24, Z+29	; 0x1d
    134c:	8f 3f       	cpi	r24, 0xFF	; 255
    134e:	09 f4       	brne	.+2      	; 0x1352 <xQueueGenericReceive+0xea>
    1350:	15 8e       	std	Z+29, r1	; 0x1d
    1352:	f7 01       	movw	r30, r14
    1354:	86 8d       	ldd	r24, Z+30	; 0x1e
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	09 f4       	brne	.+2      	; 0x135c <xQueueGenericReceive+0xf4>
    135a:	16 8e       	std	Z+30, r1	; 0x1e
    135c:	0f 90       	pop	r0
    135e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1360:	ce 01       	movw	r24, r28
    1362:	01 96       	adiw	r24, 0x01	; 1
    1364:	be 01       	movw	r22, r28
    1366:	6c 5f       	subi	r22, 0xFC	; 252
    1368:	7f 4f       	sbci	r23, 0xFF	; 255
    136a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskCheckForTimeOut>
    136e:	88 23       	and	r24, r24
    1370:	51 f5       	brne	.+84     	; 0x13c6 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1372:	c7 01       	movw	r24, r14
    1374:	0e 94 c6 06 	call	0xd8c	; 0xd8c <prvIsQueueEmpty>
    1378:	88 23       	and	r24, r24
    137a:	f9 f0       	breq	.+62     	; 0x13ba <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    137c:	f7 01       	movw	r30, r14
    137e:	80 81       	ld	r24, Z
    1380:	91 81       	ldd	r25, Z+1	; 0x01
    1382:	00 97       	sbiw	r24, 0x00	; 0
    1384:	51 f4       	brne	.+20     	; 0x139a <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	f8 94       	cli
    138a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    138c:	f7 01       	movw	r30, r14
    138e:	82 81       	ldd	r24, Z+2	; 0x02
    1390:	93 81       	ldd	r25, Z+3	; 0x03
    1392:	0e 94 3a 12 	call	0x2474	; 0x2474 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1396:	0f 90       	pop	r0
    1398:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    139a:	6c 81       	ldd	r22, Y+4	; 0x04
    139c:	7d 81       	ldd	r23, Y+5	; 0x05
    139e:	c5 01       	movw	r24, r10
    13a0:	0e 94 41 11 	call	0x2282	; 0x2282 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    13a4:	c7 01       	movw	r24, r14
    13a6:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    13aa:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
    13ae:	88 23       	and	r24, r24
    13b0:	09 f0       	breq	.+2      	; 0x13b4 <xQueueGenericReceive+0x14c>
    13b2:	7a cf       	rjmp	.-268    	; 0x12a8 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    13b4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    13b8:	77 cf       	rjmp	.-274    	; 0x12a8 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13ba:	c7 01       	movw	r24, r14
    13bc:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13c0:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
    13c4:	71 cf       	rjmp	.-286    	; 0x12a8 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    13c6:	c7 01       	movw	r24, r14
    13c8:	0e 94 ee 06 	call	0xddc	; 0xddc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13cc:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13d0:	c7 01       	movw	r24, r14
    13d2:	0e 94 c6 06 	call	0xd8c	; 0xd8c <prvIsQueueEmpty>
    13d6:	88 23       	and	r24, r24
    13d8:	09 f4       	brne	.+2      	; 0x13dc <xQueueGenericReceive+0x174>
    13da:	66 cf       	rjmp	.-308    	; 0x12a8 <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    13dc:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    13de:	0f 90       	pop	r0
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	0f 90       	pop	r0
    13e6:	0f 90       	pop	r0
    13e8:	df 91       	pop	r29
    13ea:	cf 91       	pop	r28
    13ec:	1f 91       	pop	r17
    13ee:	0f 91       	pop	r16
    13f0:	ff 90       	pop	r15
    13f2:	ef 90       	pop	r14
    13f4:	df 90       	pop	r13
    13f6:	cf 90       	pop	r12
    13f8:	bf 90       	pop	r11
    13fa:	af 90       	pop	r10
    13fc:	9f 90       	pop	r9
    13fe:	8f 90       	pop	r8
    1400:	08 95       	ret

00001402 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1402:	ef 92       	push	r14
    1404:	ff 92       	push	r15
    1406:	0f 93       	push	r16
    1408:	1f 93       	push	r17
    140a:	cf 93       	push	r28
    140c:	df 93       	push	r29
    140e:	8c 01       	movw	r16, r24
    1410:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1412:	fc 01       	movw	r30, r24
    1414:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1416:	cc 23       	and	r28, r28
    1418:	e9 f0       	breq	.+58     	; 0x1454 <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    141a:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    141c:	0e 94 d1 06 	call	0xda2	; 0xda2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1420:	c1 50       	subi	r28, 0x01	; 1
    1422:	f8 01       	movw	r30, r16
    1424:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1426:	df 3f       	cpi	r29, 0xFF	; 255
    1428:	81 f4       	brne	.+32     	; 0x144a <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    142a:	80 85       	ldd	r24, Z+8	; 0x08
    142c:	88 23       	and	r24, r24
    142e:	a1 f0       	breq	.+40     	; 0x1458 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1430:	c8 01       	movw	r24, r16
    1432:	08 96       	adiw	r24, 0x08	; 8
    1434:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <xTaskRemoveFromEventList>
    1438:	88 23       	and	r24, r24
    143a:	81 f0       	breq	.+32     	; 0x145c <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    143c:	e1 14       	cp	r14, r1
    143e:	f1 04       	cpc	r15, r1
    1440:	79 f0       	breq	.+30     	; 0x1460 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	f7 01       	movw	r30, r14
    1446:	80 83       	st	Z, r24
    1448:	0c c0       	rjmp	.+24     	; 0x1462 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    144a:	df 5f       	subi	r29, 0xFF	; 255
    144c:	f8 01       	movw	r30, r16
    144e:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	07 c0       	rjmp	.+14     	; 0x1462 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    1454:	80 e0       	ldi	r24, 0x00	; 0
    1456:	05 c0       	rjmp	.+10     	; 0x1462 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	03 c0       	rjmp	.+6      	; 0x1462 <xQueueReceiveFromISR+0x60>
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	01 c0       	rjmp	.+2      	; 0x1462 <xQueueReceiveFromISR+0x60>
    1460:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	08 95       	ret

00001470 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1470:	0f 93       	push	r16
    1472:	1f 93       	push	r17
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    147a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    147c:	88 23       	and	r24, r24
    147e:	49 f0       	breq	.+18     	; 0x1492 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1480:	0e 81       	ldd	r16, Y+6	; 0x06
    1482:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1484:	ce 01       	movw	r24, r28
    1486:	0e 94 d1 06 	call	0xda2	; 0xda2 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    148a:	1f 83       	std	Y+7, r17	; 0x07
    148c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	01 c0       	rjmp	.+2      	; 0x1494 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1492:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1494:	df 91       	pop	r29
    1496:	cf 91       	pop	r28
    1498:	1f 91       	pop	r17
    149a:	0f 91       	pop	r16
    149c:	08 95       	ret

0000149e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    14a4:	fc 01       	movw	r30, r24
    14a6:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    14ac:	08 95       	ret

000014ae <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    14ae:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    14b6:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    14b8:	0f 90       	pop	r0
    14ba:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    14bc:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    14be:	89 1b       	sub	r24, r25
    14c0:	08 95       	ret

000014c2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    14c2:	fc 01       	movw	r30, r24
    14c4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    14c6:	08 95       	ret

000014c8 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    14c8:	fc 01       	movw	r30, r24
    14ca:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	91 11       	cpse	r25, r1
    14d0:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    14d2:	08 95       	ret

000014d4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    14d4:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    14d6:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	93 8d       	ldd	r25, Z+27	; 0x1b
    14dc:	29 13       	cpse	r18, r25
    14de:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    14e0:	08 95       	ret

000014e2 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    14e2:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    14e4:	80 91 02 04 	lds	r24, 0x0402
    14e8:	90 91 03 04 	lds	r25, 0x0403
    14ec:	00 97       	sbiw	r24, 0x00	; 0
    14ee:	51 f0       	breq	.+20     	; 0x1504 <vQueueAddToRegistry+0x22>
    14f0:	e6 e0       	ldi	r30, 0x06	; 6
    14f2:	f4 e0       	ldi	r31, 0x04	; 4
    14f4:	21 e0       	ldi	r18, 0x01	; 1
    14f6:	30 e0       	ldi	r19, 0x00	; 0
    14f8:	a9 01       	movw	r20, r18
    14fa:	80 81       	ld	r24, Z
    14fc:	91 81       	ldd	r25, Z+1	; 0x01
    14fe:	00 97       	sbiw	r24, 0x00	; 0
    1500:	79 f4       	brne	.+30     	; 0x1520 <vQueueAddToRegistry+0x3e>
    1502:	02 c0       	rjmp	.+4      	; 0x1508 <vQueueAddToRegistry+0x26>
    1504:	40 e0       	ldi	r20, 0x00	; 0
    1506:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1508:	fa 01       	movw	r30, r20
    150a:	ee 0f       	add	r30, r30
    150c:	ff 1f       	adc	r31, r31
    150e:	ee 0f       	add	r30, r30
    1510:	ff 1f       	adc	r31, r31
    1512:	ee 5f       	subi	r30, 0xFE	; 254
    1514:	fb 4f       	sbci	r31, 0xFB	; 251
    1516:	71 83       	std	Z+1, r23	; 0x01
    1518:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    151a:	b3 83       	std	Z+3, r27	; 0x03
    151c:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    151e:	08 95       	ret
    1520:	2f 5f       	subi	r18, 0xFF	; 255
    1522:	3f 4f       	sbci	r19, 0xFF	; 255
    1524:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1526:	28 30       	cpi	r18, 0x08	; 8
    1528:	31 05       	cpc	r19, r1
    152a:	31 f7       	brne	.-52     	; 0x14f8 <vQueueAddToRegistry+0x16>
    152c:	08 95       	ret

0000152e <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    152e:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1530:	80 91 04 04 	lds	r24, 0x0404
    1534:	90 91 05 04 	lds	r25, 0x0405
    1538:	84 17       	cp	r24, r20
    153a:	95 07       	cpc	r25, r21
    153c:	59 f0       	breq	.+22     	; 0x1554 <pcQueueGetName+0x26>
    153e:	e8 e0       	ldi	r30, 0x08	; 8
    1540:	f4 e0       	ldi	r31, 0x04	; 4
    1542:	21 e0       	ldi	r18, 0x01	; 1
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	b9 01       	movw	r22, r18
    1548:	80 81       	ld	r24, Z
    154a:	91 81       	ldd	r25, Z+1	; 0x01
    154c:	84 17       	cp	r24, r20
    154e:	95 07       	cpc	r25, r21
    1550:	69 f4       	brne	.+26     	; 0x156c <pcQueueGetName+0x3e>
    1552:	02 c0       	rjmp	.+4      	; 0x1558 <pcQueueGetName+0x2a>
    1554:	60 e0       	ldi	r22, 0x00	; 0
    1556:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    1558:	fb 01       	movw	r30, r22
    155a:	ee 0f       	add	r30, r30
    155c:	ff 1f       	adc	r31, r31
    155e:	ee 0f       	add	r30, r30
    1560:	ff 1f       	adc	r31, r31
    1562:	ee 5f       	subi	r30, 0xFE	; 254
    1564:	fb 4f       	sbci	r31, 0xFB	; 251
    1566:	80 81       	ld	r24, Z
    1568:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    156a:	08 95       	ret
    156c:	2f 5f       	subi	r18, 0xFF	; 255
    156e:	3f 4f       	sbci	r19, 0xFF	; 255
    1570:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1572:	28 30       	cpi	r18, 0x08	; 8
    1574:	31 05       	cpc	r19, r1
    1576:	39 f7       	brne	.-50     	; 0x1546 <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    157c:	08 95       	ret

0000157e <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    157e:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1580:	80 91 04 04 	lds	r24, 0x0404
    1584:	90 91 05 04 	lds	r25, 0x0405
    1588:	84 17       	cp	r24, r20
    158a:	95 07       	cpc	r25, r21
    158c:	59 f0       	breq	.+22     	; 0x15a4 <vQueueUnregisterQueue+0x26>
    158e:	e8 e0       	ldi	r30, 0x08	; 8
    1590:	f4 e0       	ldi	r31, 0x04	; 4
    1592:	21 e0       	ldi	r18, 0x01	; 1
    1594:	30 e0       	ldi	r19, 0x00	; 0
    1596:	b9 01       	movw	r22, r18
    1598:	80 81       	ld	r24, Z
    159a:	91 81       	ldd	r25, Z+1	; 0x01
    159c:	84 17       	cp	r24, r20
    159e:	95 07       	cpc	r25, r21
    15a0:	79 f4       	brne	.+30     	; 0x15c0 <vQueueUnregisterQueue+0x42>
    15a2:	02 c0       	rjmp	.+4      	; 0x15a8 <vQueueUnregisterQueue+0x2a>
    15a4:	60 e0       	ldi	r22, 0x00	; 0
    15a6:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    15a8:	fb 01       	movw	r30, r22
    15aa:	ee 0f       	add	r30, r30
    15ac:	ff 1f       	adc	r31, r31
    15ae:	ee 0f       	add	r30, r30
    15b0:	ff 1f       	adc	r31, r31
    15b2:	ee 5f       	subi	r30, 0xFE	; 254
    15b4:	fb 4f       	sbci	r31, 0xFB	; 251
    15b6:	11 82       	std	Z+1, r1	; 0x01
    15b8:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    15ba:	13 82       	std	Z+3, r1	; 0x03
    15bc:	12 82       	std	Z+2, r1	; 0x02
				break;
    15be:	08 95       	ret
    15c0:	2f 5f       	subi	r18, 0xFF	; 255
    15c2:	3f 4f       	sbci	r19, 0xFF	; 255
    15c4:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    15c6:	28 30       	cpi	r18, 0x08	; 8
    15c8:	31 05       	cpc	r19, r1
    15ca:	29 f7       	brne	.-54     	; 0x1596 <vQueueUnregisterQueue+0x18>
    15cc:	08 95       	ret

000015ce <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    15ce:	cf 93       	push	r28
    15d0:	df 93       	push	r29
    15d2:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    15d4:	0e 94 bf 0a 	call	0x157e	; 0x157e <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    15d8:	ce 01       	movw	r24, r28
    15da:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	08 95       	ret

000015e4 <task1>:
}

void task1(void *PV)
{
	char x;
	DDRD|=(1<<7);
    15e4:	8f 9a       	sbi	0x11, 7	; 17
	while(1)
	{
	x=xSemaphoreTake(my_sem,10000);
    15e6:	80 91 22 04 	lds	r24, 0x0422
    15ea:	90 91 23 04 	lds	r25, 0x0423
    15ee:	60 e0       	ldi	r22, 0x00	; 0
    15f0:	70 e0       	ldi	r23, 0x00	; 0
    15f2:	40 e1       	ldi	r20, 0x10	; 16
    15f4:	57 e2       	ldi	r21, 0x27	; 39
    15f6:	20 e0       	ldi	r18, 0x00	; 0
    15f8:	0e 94 34 09 	call	0x1268	; 0x1268 <xQueueGenericReceive>
	if(x==1)
    15fc:	81 30       	cpi	r24, 0x01	; 1
    15fe:	99 f7       	brne	.-26     	; 0x15e6 <task1+0x2>
		{
		PORTD^=(1<<7);
    1600:	82 b3       	in	r24, 0x12	; 18
    1602:	80 58       	subi	r24, 0x80	; 128
    1604:	82 bb       	out	0x12, r24	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1606:	8f ef       	ldi	r24, 0xFF	; 255
    1608:	99 e6       	ldi	r25, 0x69	; 105
    160a:	a8 e1       	ldi	r26, 0x18	; 24
    160c:	81 50       	subi	r24, 0x01	; 1
    160e:	90 40       	sbci	r25, 0x00	; 0
    1610:	a0 40       	sbci	r26, 0x00	; 0
    1612:	e1 f7       	brne	.-8      	; 0x160c <task1+0x28>
    1614:	00 c0       	rjmp	.+0      	; 0x1616 <task1+0x32>
    1616:	00 00       	nop
		_delay_ms(1000);
		xSemaphoreGive(my_sem);
    1618:	80 91 22 04 	lds	r24, 0x0422
    161c:	90 91 23 04 	lds	r25, 0x0423
    1620:	60 e0       	ldi	r22, 0x00	; 0
    1622:	70 e0       	ldi	r23, 0x00	; 0
    1624:	40 e0       	ldi	r20, 0x00	; 0
    1626:	50 e0       	ldi	r21, 0x00	; 0
    1628:	20 e0       	ldi	r18, 0x00	; 0
    162a:	0e 94 11 08 	call	0x1022	; 0x1022 <xQueueGenericSend>
    162e:	db cf       	rjmp	.-74     	; 0x15e6 <task1+0x2>

00001630 <main>:

SemaphoreHandle_t my_sem ;
int main(void)
{
	
	xTaskCreate(task1,"M",100,NULL,1,NULL);
    1630:	82 ef       	ldi	r24, 0xF2	; 242
    1632:	9a e0       	ldi	r25, 0x0A	; 10
    1634:	62 e6       	ldi	r22, 0x62	; 98
    1636:	70 e0       	ldi	r23, 0x00	; 0
    1638:	44 e6       	ldi	r20, 0x64	; 100
    163a:	50 e0       	ldi	r21, 0x00	; 0
    163c:	20 e0       	ldi	r18, 0x00	; 0
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	01 e0       	ldi	r16, 0x01	; 1
    1642:	ee 24       	eor	r14, r14
    1644:	ff 24       	eor	r15, r15
    1646:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xTaskCreate>
	sei();
    164a:	78 94       	sei
	GICR|=(1<<INT0);
    164c:	8b b7       	in	r24, 0x3b	; 59
    164e:	80 64       	ori	r24, 0x40	; 64
    1650:	8b bf       	out	0x3b, r24	; 59
	MCUCR|=(1<<ISC00)|(1<<ISC01);
    1652:	85 b7       	in	r24, 0x35	; 53
    1654:	83 60       	ori	r24, 0x03	; 3
    1656:	85 bf       	out	0x35, r24	; 53
	my_sem=xSemaphoreCreateBinary();
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	60 e0       	ldi	r22, 0x00	; 0
    165c:	43 e0       	ldi	r20, 0x03	; 3
    165e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xQueueGenericCreate>
    1662:	90 93 23 04 	sts	0x0423, r25
    1666:	80 93 22 04 	sts	0x0422, r24
	vTaskStartScheduler();
    166a:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <vTaskStartScheduler>
    166e:	ff cf       	rjmp	.-2      	; 0x166e <main+0x3e>

00001670 <__vector_1>:
		}		
	}
}

ISR(INT0_vect)
{
    1670:	1f 92       	push	r1
    1672:	0f 92       	push	r0
    1674:	0f b6       	in	r0, 0x3f	; 63
    1676:	0f 92       	push	r0
    1678:	11 24       	eor	r1, r1
    167a:	2f 93       	push	r18
    167c:	3f 93       	push	r19
    167e:	4f 93       	push	r20
    1680:	5f 93       	push	r21
    1682:	6f 93       	push	r22
    1684:	7f 93       	push	r23
    1686:	8f 93       	push	r24
    1688:	9f 93       	push	r25
    168a:	af 93       	push	r26
    168c:	bf 93       	push	r27
    168e:	ef 93       	push	r30
    1690:	ff 93       	push	r31
	xSemaphoreGiveFromISR(my_sem,NULL);
    1692:	80 91 22 04 	lds	r24, 0x0422
    1696:	90 91 23 04 	lds	r25, 0x0423
    169a:	60 e0       	ldi	r22, 0x00	; 0
    169c:	70 e0       	ldi	r23, 0x00	; 0
    169e:	0e 94 0b 09 	call	0x1216	; 0x1216 <xQueueGiveFromISR>
}
    16a2:	ff 91       	pop	r31
    16a4:	ef 91       	pop	r30
    16a6:	bf 91       	pop	r27
    16a8:	af 91       	pop	r26
    16aa:	9f 91       	pop	r25
    16ac:	8f 91       	pop	r24
    16ae:	7f 91       	pop	r23
    16b0:	6f 91       	pop	r22
    16b2:	5f 91       	pop	r21
    16b4:	4f 91       	pop	r20
    16b6:	3f 91       	pop	r19
    16b8:	2f 91       	pop	r18
    16ba:	0f 90       	pop	r0
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	0f 90       	pop	r0
    16c0:	1f 90       	pop	r1
    16c2:	18 95       	reti

000016c4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    16c4:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    16c6:	82 85       	ldd	r24, Z+10	; 0x0a
    16c8:	93 85       	ldd	r25, Z+11	; 0x0b
    16ca:	23 e0       	ldi	r18, 0x03	; 3
    16cc:	87 3f       	cpi	r24, 0xF7	; 247
    16ce:	92 07       	cpc	r25, r18
    16d0:	61 f4       	brne	.+24     	; 0x16ea <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    16d2:	24 89       	ldd	r18, Z+20	; 0x14
    16d4:	35 89       	ldd	r19, Z+21	; 0x15
    16d6:	83 e0       	ldi	r24, 0x03	; 3
    16d8:	25 3e       	cpi	r18, 0xE5	; 229
    16da:	38 07       	cpc	r19, r24
    16dc:	41 f0       	breq	.+16     	; 0x16ee <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	21 15       	cp	r18, r1
    16e2:	31 05       	cpc	r19, r1
    16e4:	29 f0       	breq	.+10     	; 0x16f0 <prvTaskIsTaskSuspended+0x2c>
    16e6:	80 e0       	ldi	r24, 0x00	; 0
    16e8:	08 95       	ret
    16ea:	80 e0       	ldi	r24, 0x00	; 0
    16ec:	08 95       	ret
    16ee:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    16f0:	08 95       	ret

000016f2 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    16f2:	e0 91 a3 03 	lds	r30, 0x03A3
    16f6:	f0 91 a4 03 	lds	r31, 0x03A4
    16fa:	80 81       	ld	r24, Z
    16fc:	88 23       	and	r24, r24
    16fe:	39 f4       	brne	.+14     	; 0x170e <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1700:	8f ef       	ldi	r24, 0xFF	; 255
    1702:	9f ef       	ldi	r25, 0xFF	; 255
    1704:	90 93 97 03 	sts	0x0397, r25
    1708:	80 93 96 03 	sts	0x0396, r24
    170c:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    170e:	e0 91 a3 03 	lds	r30, 0x03A3
    1712:	f0 91 a4 03 	lds	r31, 0x03A4
    1716:	05 80       	ldd	r0, Z+5	; 0x05
    1718:	f6 81       	ldd	r31, Z+6	; 0x06
    171a:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    171c:	06 80       	ldd	r0, Z+6	; 0x06
    171e:	f7 81       	ldd	r31, Z+7	; 0x07
    1720:	e0 2d       	mov	r30, r0
    1722:	82 81       	ldd	r24, Z+2	; 0x02
    1724:	93 81       	ldd	r25, Z+3	; 0x03
    1726:	90 93 97 03 	sts	0x0397, r25
    172a:	80 93 96 03 	sts	0x0396, r24
    172e:	08 95       	ret

00001730 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1730:	ef 92       	push	r14
    1732:	ff 92       	push	r15
    1734:	1f 93       	push	r17
    1736:	cf 93       	push	r28
    1738:	df 93       	push	r29
    173a:	ec 01       	movw	r28, r24
    173c:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    173e:	e0 90 9d 03 	lds	r14, 0x039D
    1742:	f0 90 9e 03 	lds	r15, 0x039E
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1746:	80 91 93 03 	lds	r24, 0x0393
    174a:	90 91 94 03 	lds	r25, 0x0394
    174e:	02 96       	adiw	r24, 0x02	; 2
    1750:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1754:	8f ef       	ldi	r24, 0xFF	; 255
    1756:	cf 3f       	cpi	r28, 0xFF	; 255
    1758:	d8 07       	cpc	r29, r24
    175a:	69 f4       	brne	.+26     	; 0x1776 <prvAddCurrentTaskToDelayedList+0x46>
    175c:	11 23       	and	r17, r17
    175e:	59 f0       	breq	.+22     	; 0x1776 <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1760:	60 91 93 03 	lds	r22, 0x0393
    1764:	70 91 94 03 	lds	r23, 0x0394
    1768:	6e 5f       	subi	r22, 0xFE	; 254
    176a:	7f 4f       	sbci	r23, 0xFF	; 255
    176c:	87 ef       	ldi	r24, 0xF7	; 247
    176e:	93 e0       	ldi	r25, 0x03	; 3
    1770:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    1774:	2f c0       	rjmp	.+94     	; 0x17d4 <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1776:	ce 0d       	add	r28, r14
    1778:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    177a:	e0 91 93 03 	lds	r30, 0x0393
    177e:	f0 91 94 03 	lds	r31, 0x0394
    1782:	d3 83       	std	Z+3, r29	; 0x03
    1784:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    1786:	ce 15       	cp	r28, r14
    1788:	df 05       	cpc	r29, r15
    178a:	68 f4       	brcc	.+26     	; 0x17a6 <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    178c:	80 91 a1 03 	lds	r24, 0x03A1
    1790:	90 91 a2 03 	lds	r25, 0x03A2
    1794:	60 91 93 03 	lds	r22, 0x0393
    1798:	70 91 94 03 	lds	r23, 0x0394
    179c:	6e 5f       	subi	r22, 0xFE	; 254
    179e:	7f 4f       	sbci	r23, 0xFF	; 255
    17a0:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInsert>
    17a4:	17 c0       	rjmp	.+46     	; 0x17d4 <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    17a6:	80 91 a3 03 	lds	r24, 0x03A3
    17aa:	90 91 a4 03 	lds	r25, 0x03A4
    17ae:	60 91 93 03 	lds	r22, 0x0393
    17b2:	70 91 94 03 	lds	r23, 0x0394
    17b6:	6e 5f       	subi	r22, 0xFE	; 254
    17b8:	7f 4f       	sbci	r23, 0xFF	; 255
    17ba:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    17be:	80 91 96 03 	lds	r24, 0x0396
    17c2:	90 91 97 03 	lds	r25, 0x0397
    17c6:	c8 17       	cp	r28, r24
    17c8:	d9 07       	cpc	r29, r25
    17ca:	20 f4       	brcc	.+8      	; 0x17d4 <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    17cc:	d0 93 97 03 	sts	0x0397, r29
    17d0:	c0 93 96 03 	sts	0x0396, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
    17da:	ff 90       	pop	r15
    17dc:	ef 90       	pop	r14
    17de:	08 95       	ret

000017e0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    17e0:	cf 93       	push	r28
    17e2:	df 93       	push	r29
    17e4:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    17e6:	8f 89       	ldd	r24, Y+23	; 0x17
    17e8:	98 8d       	ldd	r25, Y+24	; 0x18
    17ea:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
			vPortFree( pxTCB );
    17ee:	ce 01       	movw	r24, r28
    17f0:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    17f4:	df 91       	pop	r29
    17f6:	cf 91       	pop	r28
    17f8:	08 95       	ret

000017fa <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    17fa:	2f 92       	push	r2
    17fc:	3f 92       	push	r3
    17fe:	4f 92       	push	r4
    1800:	5f 92       	push	r5
    1802:	6f 92       	push	r6
    1804:	7f 92       	push	r7
    1806:	8f 92       	push	r8
    1808:	9f 92       	push	r9
    180a:	af 92       	push	r10
    180c:	bf 92       	push	r11
    180e:	df 92       	push	r13
    1810:	ef 92       	push	r14
    1812:	ff 92       	push	r15
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	3c 01       	movw	r6, r24
    181e:	5b 01       	movw	r10, r22
    1820:	ea 01       	movw	r28, r20
    1822:	29 01       	movw	r4, r18
    1824:	d0 2e       	mov	r13, r16
    1826:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1828:	ca 01       	movw	r24, r20
    182a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <pvPortMalloc>
    182e:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1830:	00 97       	sbiw	r24, 0x00	; 0
    1832:	09 f4       	brne	.+2      	; 0x1836 <xTaskCreate+0x3c>
    1834:	ed c0       	rjmp	.+474    	; 0x1a10 <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1836:	8a e2       	ldi	r24, 0x2A	; 42
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <pvPortMalloc>
    183e:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1840:	00 97       	sbiw	r24, 0x00	; 0
    1842:	81 f0       	breq	.+32     	; 0x1864 <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1844:	fc 01       	movw	r30, r24
    1846:	f0 8e       	std	Z+24, r15	; 0x18
    1848:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    184a:	21 97       	sbiw	r28, 0x01	; 1
    184c:	17 01       	movw	r2, r14
    184e:	2c 0e       	add	r2, r28
    1850:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1852:	f5 01       	movw	r30, r10
    1854:	80 81       	ld	r24, Z
    1856:	f8 01       	movw	r30, r16
    1858:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    185a:	f5 01       	movw	r30, r10
    185c:	80 81       	ld	r24, Z
    185e:	88 23       	and	r24, r24
    1860:	31 f4       	brne	.+12     	; 0x186e <xTaskCreate+0x74>
    1862:	13 c0       	rjmp	.+38     	; 0x188a <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1864:	c7 01       	movw	r24, r14
    1866:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    186a:	8f ef       	ldi	r24, 0xFF	; 255
    186c:	d6 c0       	rjmp	.+428    	; 0x1a1a <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    186e:	e8 01       	movw	r28, r16
    1870:	6a 96       	adiw	r28, 0x1a	; 26
    1872:	d5 01       	movw	r26, r10
    1874:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1876:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1878:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    187a:	9d 91       	ld	r25, X+
    187c:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    187e:	90 81       	ld	r25, Z
    1880:	99 23       	and	r25, r25
    1882:	19 f0       	breq	.+6      	; 0x188a <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1884:	8f 5f       	subi	r24, 0xFF	; 255
    1886:	8a 30       	cpi	r24, 0x0A	; 10
    1888:	b9 f7       	brne	.-18     	; 0x1878 <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    188a:	f8 01       	movw	r30, r16
    188c:	12 a2       	lds	r17, 0x92
    188e:	cd 2d       	mov	r28, r13
    1890:	c5 30       	cpi	r28, 0x05	; 5
    1892:	08 f0       	brcs	.+2      	; 0x1896 <xTaskCreate+0x9c>
    1894:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1896:	f8 01       	movw	r30, r16
    1898:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    189a:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    189c:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    189e:	ee 24       	eor	r14, r14
    18a0:	ff 24       	eor	r15, r15
    18a2:	68 94       	set
    18a4:	e1 f8       	bld	r14, 1
    18a6:	e0 0e       	add	r14, r16
    18a8:	f1 1e       	adc	r15, r17
    18aa:	c7 01       	movw	r24, r14
    18ac:	0e 94 ca 04 	call	0x994	; 0x994 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    18b0:	c8 01       	movw	r24, r16
    18b2:	0c 96       	adiw	r24, 0x0c	; 12
    18b4:	0e 94 ca 04 	call	0x994	; 0x994 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    18b8:	f8 01       	movw	r30, r16
    18ba:	11 87       	std	Z+9, r17	; 0x09
    18bc:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18be:	85 e0       	ldi	r24, 0x05	; 5
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	8c 1b       	sub	r24, r28
    18c4:	91 09       	sbc	r25, r1
    18c6:	95 87       	std	Z+13, r25	; 0x0d
    18c8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    18ca:	13 8b       	std	Z+19, r17	; 0x13
    18cc:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    18ce:	15 a2       	lds	r17, 0x95
    18d0:	16 a2       	lds	r17, 0x96
    18d2:	17 a2       	lds	r17, 0x97
    18d4:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    18d6:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    18d8:	c1 01       	movw	r24, r2
    18da:	b3 01       	movw	r22, r6
    18dc:	a2 01       	movw	r20, r4
    18de:	0e 94 47 05 	call	0xa8e	; 0xa8e <pxPortInitialiseStack>
    18e2:	f8 01       	movw	r30, r16
    18e4:	91 83       	std	Z+1, r25	; 0x01
    18e6:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    18e8:	81 14       	cp	r8, r1
    18ea:	91 04       	cpc	r9, r1
    18ec:	19 f0       	breq	.+6      	; 0x18f4 <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    18ee:	f4 01       	movw	r30, r8
    18f0:	11 83       	std	Z+1, r17	; 0x01
    18f2:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    18fa:	80 91 9f 03 	lds	r24, 0x039F
    18fe:	8f 5f       	subi	r24, 0xFF	; 255
    1900:	80 93 9f 03 	sts	0x039F, r24
		if( pxCurrentTCB == NULL )
    1904:	80 91 93 03 	lds	r24, 0x0393
    1908:	90 91 94 03 	lds	r25, 0x0394
    190c:	00 97       	sbiw	r24, 0x00	; 0
    190e:	09 f0       	breq	.+2      	; 0x1912 <xTaskCreate+0x118>
    1910:	3f c0       	rjmp	.+126    	; 0x1990 <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1912:	10 93 94 03 	sts	0x0394, r17
    1916:	00 93 93 03 	sts	0x0393, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    191a:	80 91 9f 03 	lds	r24, 0x039F
    191e:	81 30       	cpi	r24, 0x01	; 1
    1920:	09 f0       	breq	.+2      	; 0x1924 <xTaskCreate+0x12a>
    1922:	47 c0       	rjmp	.+142    	; 0x19b2 <xTaskCreate+0x1b8>
    1924:	c0 e0       	ldi	r28, 0x00	; 0
    1926:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1928:	ce 01       	movw	r24, r28
    192a:	88 0f       	add	r24, r24
    192c:	99 1f       	adc	r25, r25
    192e:	88 0f       	add	r24, r24
    1930:	99 1f       	adc	r25, r25
    1932:	88 0f       	add	r24, r24
    1934:	99 1f       	adc	r25, r25
    1936:	8c 0f       	add	r24, r28
    1938:	9d 1f       	adc	r25, r29
    193a:	8a 55       	subi	r24, 0x5A	; 90
    193c:	9c 4f       	sbci	r25, 0xFC	; 252
    193e:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
    1942:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1944:	c5 30       	cpi	r28, 0x05	; 5
    1946:	d1 05       	cpc	r29, r1
    1948:	79 f7       	brne	.-34     	; 0x1928 <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    194a:	c3 ed       	ldi	r28, 0xD3	; 211
    194c:	d3 e0       	ldi	r29, 0x03	; 3
    194e:	ce 01       	movw	r24, r28
    1950:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1954:	0f 2e       	mov	r0, r31
    1956:	fc ed       	ldi	r31, 0xDC	; 220
    1958:	af 2e       	mov	r10, r31
    195a:	f3 e0       	ldi	r31, 0x03	; 3
    195c:	bf 2e       	mov	r11, r31
    195e:	f0 2d       	mov	r31, r0
    1960:	c5 01       	movw	r24, r10
    1962:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1966:	85 ee       	ldi	r24, 0xE5	; 229
    1968:	93 e0       	ldi	r25, 0x03	; 3
    196a:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    196e:	8e ee       	ldi	r24, 0xEE	; 238
    1970:	93 e0       	ldi	r25, 0x03	; 3
    1972:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1976:	87 ef       	ldi	r24, 0xF7	; 247
    1978:	93 e0       	ldi	r25, 0x03	; 3
    197a:	0e 94 bc 04 	call	0x978	; 0x978 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    197e:	d0 93 a4 03 	sts	0x03A4, r29
    1982:	c0 93 a3 03 	sts	0x03A3, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1986:	b0 92 a2 03 	sts	0x03A2, r11
    198a:	a0 92 a1 03 	sts	0x03A1, r10
    198e:	11 c0       	rjmp	.+34     	; 0x19b2 <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1990:	80 91 9b 03 	lds	r24, 0x039B
    1994:	88 23       	and	r24, r24
    1996:	69 f4       	brne	.+26     	; 0x19b2 <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1998:	e0 91 93 03 	lds	r30, 0x0393
    199c:	f0 91 94 03 	lds	r31, 0x0394
    19a0:	96 89       	ldd	r25, Z+22	; 0x16
    19a2:	f8 01       	movw	r30, r16
    19a4:	86 89       	ldd	r24, Z+22	; 0x16
    19a6:	89 17       	cp	r24, r25
    19a8:	20 f0       	brcs	.+8      	; 0x19b2 <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    19aa:	10 93 94 03 	sts	0x0394, r17
    19ae:	00 93 93 03 	sts	0x0393, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    19b2:	80 91 a5 03 	lds	r24, 0x03A5
    19b6:	8f 5f       	subi	r24, 0xFF	; 255
    19b8:	80 93 a5 03 	sts	0x03A5, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    19bc:	f8 01       	movw	r30, r16
    19be:	86 89       	ldd	r24, Z+22	; 0x16
    19c0:	90 91 9c 03 	lds	r25, 0x039C
    19c4:	98 17       	cp	r25, r24
    19c6:	10 f4       	brcc	.+4      	; 0x19cc <xTaskCreate+0x1d2>
    19c8:	80 93 9c 03 	sts	0x039C, r24
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	9c 01       	movw	r18, r24
    19d0:	22 0f       	add	r18, r18
    19d2:	33 1f       	adc	r19, r19
    19d4:	22 0f       	add	r18, r18
    19d6:	33 1f       	adc	r19, r19
    19d8:	22 0f       	add	r18, r18
    19da:	33 1f       	adc	r19, r19
    19dc:	82 0f       	add	r24, r18
    19de:	93 1f       	adc	r25, r19
    19e0:	8a 55       	subi	r24, 0x5A	; 90
    19e2:	9c 4f       	sbci	r25, 0xFC	; 252
    19e4:	b7 01       	movw	r22, r14
    19e6:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    19ee:	80 91 9b 03 	lds	r24, 0x039B
    19f2:	88 23       	and	r24, r24
    19f4:	79 f0       	breq	.+30     	; 0x1a14 <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    19f6:	e0 91 93 03 	lds	r30, 0x0393
    19fa:	f0 91 94 03 	lds	r31, 0x0394
    19fe:	96 89       	ldd	r25, Z+22	; 0x16
    1a00:	f8 01       	movw	r30, r16
    1a02:	86 89       	ldd	r24, Z+22	; 0x16
    1a04:	98 17       	cp	r25, r24
    1a06:	40 f4       	brcc	.+16     	; 0x1a18 <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1a08:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	05 c0       	rjmp	.+10     	; 0x1a1a <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a10:	8f ef       	ldi	r24, 0xFF	; 255
    1a12:	03 c0       	rjmp	.+6      	; 0x1a1a <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <xTaskCreate+0x220>
    1a18:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1a1a:	df 91       	pop	r29
    1a1c:	cf 91       	pop	r28
    1a1e:	1f 91       	pop	r17
    1a20:	0f 91       	pop	r16
    1a22:	ff 90       	pop	r15
    1a24:	ef 90       	pop	r14
    1a26:	df 90       	pop	r13
    1a28:	bf 90       	pop	r11
    1a2a:	af 90       	pop	r10
    1a2c:	9f 90       	pop	r9
    1a2e:	8f 90       	pop	r8
    1a30:	7f 90       	pop	r7
    1a32:	6f 90       	pop	r6
    1a34:	5f 90       	pop	r5
    1a36:	4f 90       	pop	r4
    1a38:	3f 90       	pop	r3
    1a3a:	2f 90       	pop	r2
    1a3c:	08 95       	ret

00001a3e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1a46:	0f b6       	in	r0, 0x3f	; 63
    1a48:	f8 94       	cli
    1a4a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1a4c:	00 97       	sbiw	r24, 0x00	; 0
    1a4e:	29 f4       	brne	.+10     	; 0x1a5a <vTaskDelete+0x1c>
    1a50:	c0 91 93 03 	lds	r28, 0x0393
    1a54:	d0 91 94 03 	lds	r29, 0x0394
    1a58:	01 c0       	rjmp	.+2      	; 0x1a5c <vTaskDelete+0x1e>
    1a5a:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1a5c:	8e 01       	movw	r16, r28
    1a5e:	0e 5f       	subi	r16, 0xFE	; 254
    1a60:	1f 4f       	sbci	r17, 0xFF	; 255
    1a62:	c8 01       	movw	r24, r16
    1a64:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1a68:	8c 89       	ldd	r24, Y+20	; 0x14
    1a6a:	9d 89       	ldd	r25, Y+21	; 0x15
    1a6c:	00 97       	sbiw	r24, 0x00	; 0
    1a6e:	21 f0       	breq	.+8      	; 0x1a78 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1a70:	ce 01       	movw	r24, r28
    1a72:	0c 96       	adiw	r24, 0x0c	; 12
    1a74:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1a78:	80 91 a5 03 	lds	r24, 0x03A5
    1a7c:	8f 5f       	subi	r24, 0xFF	; 255
    1a7e:	80 93 a5 03 	sts	0x03A5, r24

			if( pxTCB == pxCurrentTCB )
    1a82:	80 91 93 03 	lds	r24, 0x0393
    1a86:	90 91 94 03 	lds	r25, 0x0394
    1a8a:	c8 17       	cp	r28, r24
    1a8c:	d9 07       	cpc	r29, r25
    1a8e:	59 f4       	brne	.+22     	; 0x1aa6 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1a90:	8e ee       	ldi	r24, 0xEE	; 238
    1a92:	93 e0       	ldi	r25, 0x03	; 3
    1a94:	b8 01       	movw	r22, r16
    1a96:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1a9a:	80 91 a0 03 	lds	r24, 0x03A0
    1a9e:	8f 5f       	subi	r24, 0xFF	; 255
    1aa0:	80 93 a0 03 	sts	0x03A0, r24
    1aa4:	0a c0       	rjmp	.+20     	; 0x1aba <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1aa6:	80 91 9f 03 	lds	r24, 0x039F
    1aaa:	81 50       	subi	r24, 0x01	; 1
    1aac:	80 93 9f 03 	sts	0x039F, r24
				prvDeleteTCB( pxTCB );
    1ab0:	ce 01       	movw	r24, r28
    1ab2:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1ab6:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1aba:	0f 90       	pop	r0
    1abc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1abe:	80 91 9b 03 	lds	r24, 0x039B
    1ac2:	88 23       	and	r24, r24
    1ac4:	49 f0       	breq	.+18     	; 0x1ad8 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    1ac6:	80 91 93 03 	lds	r24, 0x0393
    1aca:	90 91 94 03 	lds	r25, 0x0394
    1ace:	c8 17       	cp	r28, r24
    1ad0:	d9 07       	cpc	r29, r25
    1ad2:	11 f4       	brne	.+4      	; 0x1ad8 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1ad4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1ad8:	df 91       	pop	r29
    1ada:	cf 91       	pop	r28
    1adc:	1f 91       	pop	r17
    1ade:	0f 91       	pop	r16
    1ae0:	08 95       	ret

00001ae2 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1ae2:	0f b6       	in	r0, 0x3f	; 63
    1ae4:	f8 94       	cli
    1ae6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1ae8:	00 97       	sbiw	r24, 0x00	; 0
    1aea:	29 f4       	brne	.+10     	; 0x1af6 <uxTaskPriorityGet+0x14>
    1aec:	e0 91 93 03 	lds	r30, 0x0393
    1af0:	f0 91 94 03 	lds	r31, 0x0394
    1af4:	01 c0       	rjmp	.+2      	; 0x1af8 <uxTaskPriorityGet+0x16>
    1af6:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1afc:	86 89       	ldd	r24, Z+22	; 0x16
    1afe:	08 95       	ret

00001b00 <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1b00:	00 97       	sbiw	r24, 0x00	; 0
    1b02:	29 f4       	brne	.+10     	; 0x1b0e <uxTaskPriorityGetFromISR+0xe>
    1b04:	e0 91 93 03 	lds	r30, 0x0393
    1b08:	f0 91 94 03 	lds	r31, 0x0394
    1b0c:	01 c0       	rjmp	.+2      	; 0x1b10 <uxTaskPriorityGetFromISR+0x10>
    1b0e:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1b10:	86 89       	ldd	r24, Z+22	; 0x16
    1b12:	08 95       	ret

00001b14 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1b14:	ef 92       	push	r14
    1b16:	ff 92       	push	r15
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
    1b1c:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1b1e:	65 30       	cpi	r22, 0x05	; 5
    1b20:	08 f0       	brcs	.+2      	; 0x1b24 <vTaskPrioritySet+0x10>
    1b22:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1b24:	0f b6       	in	r0, 0x3f	; 63
    1b26:	f8 94       	cli
    1b28:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1b2a:	00 97       	sbiw	r24, 0x00	; 0
    1b2c:	29 f4       	brne	.+10     	; 0x1b38 <vTaskPrioritySet+0x24>
    1b2e:	c0 91 93 03 	lds	r28, 0x0393
    1b32:	d0 91 94 03 	lds	r29, 0x0394
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <vTaskPrioritySet+0x26>
    1b38:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1b3a:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1b3c:	26 17       	cp	r18, r22
    1b3e:	09 f4       	brne	.+2      	; 0x1b42 <vTaskPrioritySet+0x2e>
    1b40:	61 c0       	rjmp	.+194    	; 0x1c04 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1b42:	26 17       	cp	r18, r22
    1b44:	88 f4       	brcc	.+34     	; 0x1b68 <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    1b46:	80 91 93 03 	lds	r24, 0x0393
    1b4a:	90 91 94 03 	lds	r25, 0x0394
    1b4e:	c8 17       	cp	r28, r24
    1b50:	d9 07       	cpc	r29, r25
    1b52:	a1 f0       	breq	.+40     	; 0x1b7c <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1b54:	e0 91 93 03 	lds	r30, 0x0393
    1b58:	f0 91 94 03 	lds	r31, 0x0394
						{
							xYieldRequired = pdTRUE;
    1b5c:	11 e0       	ldi	r17, 0x01	; 1
    1b5e:	86 89       	ldd	r24, Z+22	; 0x16
    1b60:	68 17       	cp	r22, r24
    1b62:	68 f4       	brcc	.+26     	; 0x1b7e <vTaskPrioritySet+0x6a>
    1b64:	10 e0       	ldi	r17, 0x00	; 0
    1b66:	0b c0       	rjmp	.+22     	; 0x1b7e <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1b68:	80 91 93 03 	lds	r24, 0x0393
    1b6c:	90 91 94 03 	lds	r25, 0x0394
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    1b70:	11 e0       	ldi	r17, 0x01	; 1
    1b72:	c8 17       	cp	r28, r24
    1b74:	d9 07       	cpc	r29, r25
    1b76:	19 f0       	breq	.+6      	; 0x1b7e <vTaskPrioritySet+0x6a>
    1b78:	10 e0       	ldi	r17, 0x00	; 0
    1b7a:	01 c0       	rjmp	.+2      	; 0x1b7e <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1b7c:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1b7e:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1b80:	28 17       	cp	r18, r24
    1b82:	09 f4       	brne	.+2      	; 0x1b86 <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    1b84:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1b86:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1b88:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b8a:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b8c:	33 23       	and	r19, r19
    1b8e:	34 f0       	brlt	.+12     	; 0x1b9c <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b90:	25 e0       	ldi	r18, 0x05	; 5
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	26 1b       	sub	r18, r22
    1b96:	31 09       	sbc	r19, r1
    1b98:	3d 87       	std	Y+13, r19	; 0x0d
    1b9a:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	9c 01       	movw	r18, r24
    1ba0:	22 0f       	add	r18, r18
    1ba2:	33 1f       	adc	r19, r19
    1ba4:	22 0f       	add	r18, r18
    1ba6:	33 1f       	adc	r19, r19
    1ba8:	22 0f       	add	r18, r18
    1baa:	33 1f       	adc	r19, r19
    1bac:	82 0f       	add	r24, r18
    1bae:	93 1f       	adc	r25, r19
    1bb0:	8a 55       	subi	r24, 0x5A	; 90
    1bb2:	9c 4f       	sbci	r25, 0xFC	; 252
    1bb4:	2a 85       	ldd	r18, Y+10	; 0x0a
    1bb6:	3b 85       	ldd	r19, Y+11	; 0x0b
    1bb8:	28 17       	cp	r18, r24
    1bba:	39 07       	cpc	r19, r25
    1bbc:	f9 f4       	brne	.+62     	; 0x1bfc <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1bbe:	ee 24       	eor	r14, r14
    1bc0:	ff 24       	eor	r15, r15
    1bc2:	68 94       	set
    1bc4:	e1 f8       	bld	r14, 1
    1bc6:	ec 0e       	add	r14, r28
    1bc8:	fd 1e       	adc	r15, r29
    1bca:	c7 01       	movw	r24, r14
    1bcc:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1bd0:	8e 89       	ldd	r24, Y+22	; 0x16
    1bd2:	90 91 9c 03 	lds	r25, 0x039C
    1bd6:	98 17       	cp	r25, r24
    1bd8:	10 f4       	brcc	.+4      	; 0x1bde <vTaskPrioritySet+0xca>
    1bda:	80 93 9c 03 	sts	0x039C, r24
    1bde:	90 e0       	ldi	r25, 0x00	; 0
    1be0:	9c 01       	movw	r18, r24
    1be2:	22 0f       	add	r18, r18
    1be4:	33 1f       	adc	r19, r19
    1be6:	22 0f       	add	r18, r18
    1be8:	33 1f       	adc	r19, r19
    1bea:	22 0f       	add	r18, r18
    1bec:	33 1f       	adc	r19, r19
    1bee:	82 0f       	add	r24, r18
    1bf0:	93 1f       	adc	r25, r19
    1bf2:	8a 55       	subi	r24, 0x5A	; 90
    1bf4:	9c 4f       	sbci	r25, 0xFC	; 252
    1bf6:	b7 01       	movw	r22, r14
    1bf8:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1bfc:	11 23       	and	r17, r17
    1bfe:	11 f0       	breq	.+4      	; 0x1c04 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1c00:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1c04:	0f 90       	pop	r0
    1c06:	0f be       	out	0x3f, r0	; 63
	}
    1c08:	df 91       	pop	r29
    1c0a:	cf 91       	pop	r28
    1c0c:	1f 91       	pop	r17
    1c0e:	ff 90       	pop	r15
    1c10:	ef 90       	pop	r14
    1c12:	08 95       	ret

00001c14 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1c14:	0f 93       	push	r16
    1c16:	1f 93       	push	r17
    1c18:	cf 93       	push	r28
    1c1a:	df 93       	push	r29
    1c1c:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1c1e:	00 97       	sbiw	r24, 0x00	; 0
    1c20:	b9 f1       	breq	.+110    	; 0x1c90 <vTaskResume+0x7c>
    1c22:	80 91 93 03 	lds	r24, 0x0393
    1c26:	90 91 94 03 	lds	r25, 0x0394
    1c2a:	c8 17       	cp	r28, r24
    1c2c:	d9 07       	cpc	r29, r25
    1c2e:	81 f1       	breq	.+96     	; 0x1c90 <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    1c30:	0f b6       	in	r0, 0x3f	; 63
    1c32:	f8 94       	cli
    1c34:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1c36:	ce 01       	movw	r24, r28
    1c38:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <prvTaskIsTaskSuspended>
    1c3c:	88 23       	and	r24, r24
    1c3e:	31 f1       	breq	.+76     	; 0x1c8c <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    1c40:	8e 01       	movw	r16, r28
    1c42:	0e 5f       	subi	r16, 0xFE	; 254
    1c44:	1f 4f       	sbci	r17, 0xFF	; 255
    1c46:	c8 01       	movw	r24, r16
    1c48:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1c4c:	8e 89       	ldd	r24, Y+22	; 0x16
    1c4e:	90 91 9c 03 	lds	r25, 0x039C
    1c52:	98 17       	cp	r25, r24
    1c54:	10 f4       	brcc	.+4      	; 0x1c5a <vTaskResume+0x46>
    1c56:	80 93 9c 03 	sts	0x039C, r24
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	9c 01       	movw	r18, r24
    1c5e:	22 0f       	add	r18, r18
    1c60:	33 1f       	adc	r19, r19
    1c62:	22 0f       	add	r18, r18
    1c64:	33 1f       	adc	r19, r19
    1c66:	22 0f       	add	r18, r18
    1c68:	33 1f       	adc	r19, r19
    1c6a:	82 0f       	add	r24, r18
    1c6c:	93 1f       	adc	r25, r19
    1c6e:	8a 55       	subi	r24, 0x5A	; 90
    1c70:	9c 4f       	sbci	r25, 0xFC	; 252
    1c72:	b8 01       	movw	r22, r16
    1c74:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c78:	e0 91 93 03 	lds	r30, 0x0393
    1c7c:	f0 91 94 03 	lds	r31, 0x0394
    1c80:	9e 89       	ldd	r25, Y+22	; 0x16
    1c82:	86 89       	ldd	r24, Z+22	; 0x16
    1c84:	98 17       	cp	r25, r24
    1c86:	10 f0       	brcs	.+4      	; 0x1c8c <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    1c88:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1c8c:	0f 90       	pop	r0
    1c8e:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	08 95       	ret

00001c9a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    1c9a:	ef 92       	push	r14
    1c9c:	ff 92       	push	r15
    1c9e:	1f 93       	push	r17
    1ca0:	cf 93       	push	r28
    1ca2:	df 93       	push	r29
    1ca4:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1ca6:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <prvTaskIsTaskSuspended>
    1caa:	88 23       	and	r24, r24
    1cac:	b9 f1       	breq	.+110    	; 0x1d1c <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1cae:	80 91 95 03 	lds	r24, 0x0395
    1cb2:	88 23       	and	r24, r24
    1cb4:	51 f5       	brne	.+84     	; 0x1d0a <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1cb6:	e0 91 93 03 	lds	r30, 0x0393
    1cba:	f0 91 94 03 	lds	r31, 0x0394

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1cbe:	11 e0       	ldi	r17, 0x01	; 1
    1cc0:	9e 89       	ldd	r25, Y+22	; 0x16
    1cc2:	86 89       	ldd	r24, Z+22	; 0x16
    1cc4:	98 17       	cp	r25, r24
    1cc6:	08 f4       	brcc	.+2      	; 0x1cca <xTaskResumeFromISR+0x30>
    1cc8:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1cca:	ee 24       	eor	r14, r14
    1ccc:	ff 24       	eor	r15, r15
    1cce:	68 94       	set
    1cd0:	e1 f8       	bld	r14, 1
    1cd2:	ec 0e       	add	r14, r28
    1cd4:	fd 1e       	adc	r15, r29
    1cd6:	c7 01       	movw	r24, r14
    1cd8:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1cdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cde:	90 91 9c 03 	lds	r25, 0x039C
    1ce2:	98 17       	cp	r25, r24
    1ce4:	10 f4       	brcc	.+4      	; 0x1cea <xTaskResumeFromISR+0x50>
    1ce6:	80 93 9c 03 	sts	0x039C, r24
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	9c 01       	movw	r18, r24
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	22 0f       	add	r18, r18
    1cf4:	33 1f       	adc	r19, r19
    1cf6:	22 0f       	add	r18, r18
    1cf8:	33 1f       	adc	r19, r19
    1cfa:	82 0f       	add	r24, r18
    1cfc:	93 1f       	adc	r25, r19
    1cfe:	8a 55       	subi	r24, 0x5A	; 90
    1d00:	9c 4f       	sbci	r25, 0xFC	; 252
    1d02:	b7 01       	movw	r22, r14
    1d04:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    1d08:	0a c0       	rjmp	.+20     	; 0x1d1e <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1d0a:	be 01       	movw	r22, r28
    1d0c:	64 5f       	subi	r22, 0xF4	; 244
    1d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d10:	85 ee       	ldi	r24, 0xE5	; 229
    1d12:	93 e0       	ldi	r25, 0x03	; 3
    1d14:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1d18:	10 e0       	ldi	r17, 0x00	; 0
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <xTaskResumeFromISR+0x84>
    1d1c:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1d1e:	81 2f       	mov	r24, r17
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	1f 91       	pop	r17
    1d26:	ff 90       	pop	r15
    1d28:	ef 90       	pop	r14
    1d2a:	08 95       	ret

00001d2c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1d2c:	ef 92       	push	r14
    1d2e:	ff 92       	push	r15
    1d30:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1d32:	8b e0       	ldi	r24, 0x0B	; 11
    1d34:	90 e1       	ldi	r25, 0x10	; 16
    1d36:	64 e6       	ldi	r22, 0x64	; 100
    1d38:	70 e0       	ldi	r23, 0x00	; 0
    1d3a:	48 ec       	ldi	r20, 0xC8	; 200
    1d3c:	50 e0       	ldi	r21, 0x00	; 0
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	00 e0       	ldi	r16, 0x00	; 0
    1d44:	0f 2e       	mov	r0, r31
    1d46:	f0 e0       	ldi	r31, 0x00	; 0
    1d48:	ef 2e       	mov	r14, r31
    1d4a:	f4 e0       	ldi	r31, 0x04	; 4
    1d4c:	ff 2e       	mov	r15, r31
    1d4e:	f0 2d       	mov	r31, r0
    1d50:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1d54:	81 30       	cpi	r24, 0x01	; 1
    1d56:	81 f4       	brne	.+32     	; 0x1d78 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1d58:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1d5a:	8f ef       	ldi	r24, 0xFF	; 255
    1d5c:	9f ef       	ldi	r25, 0xFF	; 255
    1d5e:	90 93 97 03 	sts	0x0397, r25
    1d62:	80 93 96 03 	sts	0x0396, r24
		xSchedulerRunning = pdTRUE;
    1d66:	81 e0       	ldi	r24, 0x01	; 1
    1d68:	80 93 9b 03 	sts	0x039B, r24
		xTickCount = ( TickType_t ) 0U;
    1d6c:	10 92 9e 03 	sts	0x039E, r1
    1d70:	10 92 9d 03 	sts	0x039D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d74:	0e 94 d7 05 	call	0xbae	; 0xbae <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1d78:	0f 91       	pop	r16
    1d7a:	ff 90       	pop	r15
    1d7c:	ef 90       	pop	r14
    1d7e:	08 95       	ret

00001d80 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1d80:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1d82:	10 92 9b 03 	sts	0x039B, r1
	vPortEndScheduler();
    1d86:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortEndScheduler>
}
    1d8a:	08 95       	ret

00001d8c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1d8c:	80 91 95 03 	lds	r24, 0x0395
    1d90:	8f 5f       	subi	r24, 0xFF	; 255
    1d92:	80 93 95 03 	sts	0x0395, r24
}
    1d96:	08 95       	ret

00001d98 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1d9e:	80 91 9d 03 	lds	r24, 0x039D
    1da2:	90 91 9e 03 	lds	r25, 0x039E
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1da6:	0f 90       	pop	r0
    1da8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1daa:	08 95       	ret

00001dac <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1dac:	80 91 9d 03 	lds	r24, 0x039D
    1db0:	90 91 9e 03 	lds	r25, 0x039E
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1db4:	08 95       	ret

00001db6 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1db6:	80 91 9f 03 	lds	r24, 0x039F
}
    1dba:	08 95       	ret

00001dbc <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1dbc:	00 97       	sbiw	r24, 0x00	; 0
    1dbe:	21 f4       	brne	.+8      	; 0x1dc8 <pcTaskGetName+0xc>
    1dc0:	80 91 93 03 	lds	r24, 0x0393
    1dc4:	90 91 94 03 	lds	r25, 0x0394
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    1dc8:	49 96       	adiw	r24, 0x19	; 25
}
    1dca:	08 95       	ret

00001dcc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1dcc:	cf 92       	push	r12
    1dce:	df 92       	push	r13
    1dd0:	ef 92       	push	r14
    1dd2:	ff 92       	push	r15
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1ddc:	80 91 95 03 	lds	r24, 0x0395
    1de0:	88 23       	and	r24, r24
    1de2:	09 f0       	breq	.+2      	; 0x1de6 <xTaskIncrementTick+0x1a>
    1de4:	82 c0       	rjmp	.+260    	; 0x1eea <xTaskIncrementTick+0x11e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1de6:	c0 90 9d 03 	lds	r12, 0x039D
    1dea:	d0 90 9e 03 	lds	r13, 0x039E
    1dee:	08 94       	sec
    1df0:	c1 1c       	adc	r12, r1
    1df2:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1df4:	d0 92 9e 03 	sts	0x039E, r13
    1df8:	c0 92 9d 03 	sts	0x039D, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    1dfc:	c1 14       	cp	r12, r1
    1dfe:	d1 04       	cpc	r13, r1
    1e00:	b9 f4       	brne	.+46     	; 0x1e30 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    1e02:	80 91 a3 03 	lds	r24, 0x03A3
    1e06:	90 91 a4 03 	lds	r25, 0x03A4
    1e0a:	20 91 a1 03 	lds	r18, 0x03A1
    1e0e:	30 91 a2 03 	lds	r19, 0x03A2
    1e12:	30 93 a4 03 	sts	0x03A4, r19
    1e16:	20 93 a3 03 	sts	0x03A3, r18
    1e1a:	90 93 a2 03 	sts	0x03A2, r25
    1e1e:	80 93 a1 03 	sts	0x03A1, r24
    1e22:	80 91 98 03 	lds	r24, 0x0398
    1e26:	8f 5f       	subi	r24, 0xFF	; 255
    1e28:	80 93 98 03 	sts	0x0398, r24
    1e2c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1e30:	80 91 96 03 	lds	r24, 0x0396
    1e34:	90 91 97 03 	lds	r25, 0x0397
    1e38:	c8 16       	cp	r12, r24
    1e3a:	d9 06       	cpc	r13, r25
    1e3c:	20 f4       	brcc	.+8      	; 0x1e46 <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1e3e:	ff 24       	eor	r15, r15
    1e40:	5a c0       	rjmp	.+180    	; 0x1ef6 <xTaskIncrementTick+0x12a>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1e42:	fe 2c       	mov	r15, r14
    1e44:	03 c0       	rjmp	.+6      	; 0x1e4c <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1e46:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1e48:	ee 24       	eor	r14, r14
    1e4a:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1e4c:	e0 91 a3 03 	lds	r30, 0x03A3
    1e50:	f0 91 a4 03 	lds	r31, 0x03A4
    1e54:	80 81       	ld	r24, Z
    1e56:	88 23       	and	r24, r24
    1e58:	39 f4       	brne	.+14     	; 0x1e68 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e5a:	8f ef       	ldi	r24, 0xFF	; 255
    1e5c:	9f ef       	ldi	r25, 0xFF	; 255
    1e5e:	90 93 97 03 	sts	0x0397, r25
    1e62:	80 93 96 03 	sts	0x0396, r24
					break;
    1e66:	47 c0       	rjmp	.+142    	; 0x1ef6 <xTaskIncrementTick+0x12a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1e68:	e0 91 a3 03 	lds	r30, 0x03A3
    1e6c:	f0 91 a4 03 	lds	r31, 0x03A4
    1e70:	05 80       	ldd	r0, Z+5	; 0x05
    1e72:	f6 81       	ldd	r31, Z+6	; 0x06
    1e74:	e0 2d       	mov	r30, r0
    1e76:	c6 81       	ldd	r28, Z+6	; 0x06
    1e78:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e7c:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1e7e:	c8 16       	cp	r12, r24
    1e80:	d9 06       	cpc	r13, r25
    1e82:	28 f4       	brcc	.+10     	; 0x1e8e <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1e84:	90 93 97 03 	sts	0x0397, r25
    1e88:	80 93 96 03 	sts	0x0396, r24
						break;
    1e8c:	34 c0       	rjmp	.+104    	; 0x1ef6 <xTaskIncrementTick+0x12a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1e8e:	8e 01       	movw	r16, r28
    1e90:	0e 5f       	subi	r16, 0xFE	; 254
    1e92:	1f 4f       	sbci	r17, 0xFF	; 255
    1e94:	c8 01       	movw	r24, r16
    1e96:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1e9a:	8c 89       	ldd	r24, Y+20	; 0x14
    1e9c:	9d 89       	ldd	r25, Y+21	; 0x15
    1e9e:	00 97       	sbiw	r24, 0x00	; 0
    1ea0:	21 f0       	breq	.+8      	; 0x1eaa <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1ea2:	ce 01       	movw	r24, r28
    1ea4:	0c 96       	adiw	r24, 0x0c	; 12
    1ea6:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1eaa:	8e 89       	ldd	r24, Y+22	; 0x16
    1eac:	90 91 9c 03 	lds	r25, 0x039C
    1eb0:	98 17       	cp	r25, r24
    1eb2:	10 f4       	brcc	.+4      	; 0x1eb8 <xTaskIncrementTick+0xec>
    1eb4:	80 93 9c 03 	sts	0x039C, r24
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
    1eba:	9c 01       	movw	r18, r24
    1ebc:	22 0f       	add	r18, r18
    1ebe:	33 1f       	adc	r19, r19
    1ec0:	22 0f       	add	r18, r18
    1ec2:	33 1f       	adc	r19, r19
    1ec4:	22 0f       	add	r18, r18
    1ec6:	33 1f       	adc	r19, r19
    1ec8:	82 0f       	add	r24, r18
    1eca:	93 1f       	adc	r25, r19
    1ecc:	8a 55       	subi	r24, 0x5A	; 90
    1ece:	9c 4f       	sbci	r25, 0xFC	; 252
    1ed0:	b8 01       	movw	r22, r16
    1ed2:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ed6:	e0 91 93 03 	lds	r30, 0x0393
    1eda:	f0 91 94 03 	lds	r31, 0x0394
    1ede:	9e 89       	ldd	r25, Y+22	; 0x16
    1ee0:	86 89       	ldd	r24, Z+22	; 0x16
    1ee2:	98 17       	cp	r25, r24
    1ee4:	08 f0       	brcs	.+2      	; 0x1ee8 <xTaskIncrementTick+0x11c>
    1ee6:	ad cf       	rjmp	.-166    	; 0x1e42 <xTaskIncrementTick+0x76>
    1ee8:	b1 cf       	rjmp	.-158    	; 0x1e4c <xTaskIncrementTick+0x80>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1eea:	80 91 9a 03 	lds	r24, 0x039A
    1eee:	8f 5f       	subi	r24, 0xFF	; 255
    1ef0:	80 93 9a 03 	sts	0x039A, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1ef4:	ff 24       	eor	r15, r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1ef6:	80 91 99 03 	lds	r24, 0x0399
    1efa:	88 23       	and	r24, r24
    1efc:	11 f0       	breq	.+4      	; 0x1f02 <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
    1efe:	ff 24       	eor	r15, r15
    1f00:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1f02:	8f 2d       	mov	r24, r15
    1f04:	df 91       	pop	r29
    1f06:	cf 91       	pop	r28
    1f08:	1f 91       	pop	r17
    1f0a:	0f 91       	pop	r16
    1f0c:	ff 90       	pop	r15
    1f0e:	ef 90       	pop	r14
    1f10:	df 90       	pop	r13
    1f12:	cf 90       	pop	r12
    1f14:	08 95       	ret

00001f16 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1f16:	df 92       	push	r13
    1f18:	ef 92       	push	r14
    1f1a:	ff 92       	push	r15
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1f24:	0f b6       	in	r0, 0x3f	; 63
    1f26:	f8 94       	cli
    1f28:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1f2a:	80 91 95 03 	lds	r24, 0x0395
    1f2e:	81 50       	subi	r24, 0x01	; 1
    1f30:	80 93 95 03 	sts	0x0395, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1f34:	80 91 95 03 	lds	r24, 0x0395
    1f38:	88 23       	and	r24, r24
    1f3a:	09 f0       	breq	.+2      	; 0x1f3e <xTaskResumeAll+0x28>
    1f3c:	5f c0       	rjmp	.+190    	; 0x1ffc <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1f3e:	80 91 9f 03 	lds	r24, 0x039F
    1f42:	88 23       	and	r24, r24
    1f44:	91 f5       	brne	.+100    	; 0x1faa <xTaskResumeAll+0x94>
    1f46:	5d c0       	rjmp	.+186    	; 0x2002 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1f48:	e0 91 ea 03 	lds	r30, 0x03EA
    1f4c:	f0 91 eb 03 	lds	r31, 0x03EB
    1f50:	c6 81       	ldd	r28, Z+6	; 0x06
    1f52:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1f54:	ce 01       	movw	r24, r28
    1f56:	0c 96       	adiw	r24, 0x0c	; 12
    1f58:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1f5c:	8e 01       	movw	r16, r28
    1f5e:	0e 5f       	subi	r16, 0xFE	; 254
    1f60:	1f 4f       	sbci	r17, 0xFF	; 255
    1f62:	c8 01       	movw	r24, r16
    1f64:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1f68:	8e 89       	ldd	r24, Y+22	; 0x16
    1f6a:	90 91 9c 03 	lds	r25, 0x039C
    1f6e:	98 17       	cp	r25, r24
    1f70:	10 f4       	brcc	.+4      	; 0x1f76 <xTaskResumeAll+0x60>
    1f72:	80 93 9c 03 	sts	0x039C, r24
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	9c 01       	movw	r18, r24
    1f7a:	22 0f       	add	r18, r18
    1f7c:	33 1f       	adc	r19, r19
    1f7e:	22 0f       	add	r18, r18
    1f80:	33 1f       	adc	r19, r19
    1f82:	22 0f       	add	r18, r18
    1f84:	33 1f       	adc	r19, r19
    1f86:	82 0f       	add	r24, r18
    1f88:	93 1f       	adc	r25, r19
    1f8a:	8a 55       	subi	r24, 0x5A	; 90
    1f8c:	9c 4f       	sbci	r25, 0xFC	; 252
    1f8e:	b8 01       	movw	r22, r16
    1f90:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1f94:	e0 91 93 03 	lds	r30, 0x0393
    1f98:	f0 91 94 03 	lds	r31, 0x0394
    1f9c:	9e 89       	ldd	r25, Y+22	; 0x16
    1f9e:	86 89       	ldd	r24, Z+22	; 0x16
    1fa0:	98 17       	cp	r25, r24
    1fa2:	68 f0       	brcs	.+26     	; 0x1fbe <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    1fa4:	d0 92 99 03 	sts	0x0399, r13
    1fa8:	0a c0       	rjmp	.+20     	; 0x1fbe <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1faa:	c0 e0       	ldi	r28, 0x00	; 0
    1fac:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1fae:	0f 2e       	mov	r0, r31
    1fb0:	f5 ee       	ldi	r31, 0xE5	; 229
    1fb2:	ef 2e       	mov	r14, r31
    1fb4:	f3 e0       	ldi	r31, 0x03	; 3
    1fb6:	ff 2e       	mov	r15, r31
    1fb8:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1fba:	dd 24       	eor	r13, r13
    1fbc:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1fbe:	f7 01       	movw	r30, r14
    1fc0:	80 81       	ld	r24, Z
    1fc2:	88 23       	and	r24, r24
    1fc4:	09 f6       	brne	.-126    	; 0x1f48 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1fc6:	20 97       	sbiw	r28, 0x00	; 0
    1fc8:	11 f0       	breq	.+4      	; 0x1fce <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1fca:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1fce:	c0 91 9a 03 	lds	r28, 0x039A

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1fd2:	cc 23       	and	r28, r28
    1fd4:	59 f0       	breq	.+22     	; 0x1fec <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    1fd6:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1fd8:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskIncrementTick>
    1fdc:	88 23       	and	r24, r24
    1fde:	11 f0       	breq	.+4      	; 0x1fe4 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    1fe0:	00 93 99 03 	sts	0x0399, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1fe4:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1fe6:	c1 f7       	brne	.-16     	; 0x1fd8 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    1fe8:	10 92 9a 03 	sts	0x039A, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1fec:	80 91 99 03 	lds	r24, 0x0399
    1ff0:	88 23       	and	r24, r24
    1ff2:	31 f0       	breq	.+12     	; 0x2000 <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1ff4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	03 c0       	rjmp	.+6      	; 0x2002 <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	01 c0       	rjmp	.+2      	; 0x2002 <xTaskResumeAll+0xec>
    2000:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2002:	0f 90       	pop	r0
    2004:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2006:	df 91       	pop	r29
    2008:	cf 91       	pop	r28
    200a:	1f 91       	pop	r17
    200c:	0f 91       	pop	r16
    200e:	ff 90       	pop	r15
    2010:	ef 90       	pop	r14
    2012:	df 90       	pop	r13
    2014:	08 95       	ret

00002016 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2016:	0e ee       	ldi	r16, 0xEE	; 238
    2018:	13 e0       	ldi	r17, 0x03	; 3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    201a:	0f 2e       	mov	r0, r31
    201c:	f6 ea       	ldi	r31, 0xA6	; 166
    201e:	ef 2e       	mov	r14, r31
    2020:	f3 e0       	ldi	r31, 0x03	; 3
    2022:	ff 2e       	mov	r15, r31
    2024:	f0 2d       	mov	r31, r0
    2026:	24 c0       	rjmp	.+72     	; 0x2070 <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2028:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    202c:	f8 01       	movw	r30, r16
    202e:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    2030:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2034:	cc 23       	and	r28, r28
    2036:	e1 f0       	breq	.+56     	; 0x2070 <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	f8 94       	cli
    203c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    203e:	e0 91 f3 03 	lds	r30, 0x03F3
    2042:	f0 91 f4 03 	lds	r31, 0x03F4
    2046:	c6 81       	ldd	r28, Z+6	; 0x06
    2048:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    204a:	ce 01       	movw	r24, r28
    204c:	02 96       	adiw	r24, 0x02	; 2
    204e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					--uxCurrentNumberOfTasks;
    2052:	80 91 9f 03 	lds	r24, 0x039F
    2056:	81 50       	subi	r24, 0x01	; 1
    2058:	80 93 9f 03 	sts	0x039F, r24
					--uxDeletedTasksWaitingCleanUp;
    205c:	80 91 a0 03 	lds	r24, 0x03A0
    2060:	81 50       	subi	r24, 0x01	; 1
    2062:	80 93 a0 03 	sts	0x03A0, r24
				}
				taskEXIT_CRITICAL();
    2066:	0f 90       	pop	r0
    2068:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    206a:	ce 01       	movw	r24, r28
    206c:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2070:	80 91 a0 03 	lds	r24, 0x03A0
    2074:	88 23       	and	r24, r24
    2076:	c1 f6       	brne	.-80     	; 0x2028 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2078:	f7 01       	movw	r30, r14
    207a:	80 81       	ld	r24, Z
    207c:	82 30       	cpi	r24, 0x02	; 2
    207e:	c0 f3       	brcs	.-16     	; 0x2070 <prvIdleTask+0x5a>
			{
				taskYIELD();
    2080:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    2084:	f5 cf       	rjmp	.-22     	; 0x2070 <prvIdleTask+0x5a>

00002086 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
    208a:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    208c:	00 97       	sbiw	r24, 0x00	; 0
    208e:	51 f0       	breq	.+20     	; 0x20a4 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2090:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2094:	ce 01       	movw	r24, r28
    2096:	60 e0       	ldi	r22, 0x00	; 0
    2098:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    209c:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20a0:	88 23       	and	r24, r24
    20a2:	11 f4       	brne	.+4      	; 0x20a8 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    20a4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    20a8:	df 91       	pop	r29
    20aa:	cf 91       	pop	r28
    20ac:	08 95       	ret

000020ae <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	8c 01       	movw	r16, r24
    20b8:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    20ba:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    20be:	80 91 9d 03 	lds	r24, 0x039D
    20c2:	90 91 9e 03 	lds	r25, 0x039E

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    20c6:	f8 01       	movw	r30, r16
    20c8:	20 81       	ld	r18, Z
    20ca:	31 81       	ldd	r19, Z+1	; 0x01
    20cc:	c2 0f       	add	r28, r18
    20ce:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    20d0:	82 17       	cp	r24, r18
    20d2:	93 07       	cpc	r25, r19
    20d4:	48 f4       	brcc	.+18     	; 0x20e8 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    20d6:	c2 17       	cp	r28, r18
    20d8:	d3 07       	cpc	r29, r19
    20da:	f8 f4       	brcc	.+62     	; 0x211a <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    20dc:	d1 83       	std	Z+1, r29	; 0x01
    20de:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    20e0:	8c 17       	cp	r24, r28
    20e2:	9d 07       	cpc	r25, r29
    20e4:	78 f4       	brcc	.+30     	; 0x2104 <vTaskDelayUntil+0x56>
    20e6:	07 c0       	rjmp	.+14     	; 0x20f6 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    20e8:	c2 17       	cp	r28, r18
    20ea:	d3 07       	cpc	r29, r19
    20ec:	90 f0       	brcs	.+36     	; 0x2112 <vTaskDelayUntil+0x64>
    20ee:	8c 17       	cp	r24, r28
    20f0:	9d 07       	cpc	r25, r29
    20f2:	78 f0       	brcs	.+30     	; 0x2112 <vTaskDelayUntil+0x64>
    20f4:	12 c0       	rjmp	.+36     	; 0x211a <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    20f6:	9e 01       	movw	r18, r28
    20f8:	28 1b       	sub	r18, r24
    20fa:	39 0b       	sbc	r19, r25
    20fc:	c9 01       	movw	r24, r18
    20fe:	60 e0       	ldi	r22, 0x00	; 0
    2100:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2104:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2108:	88 23       	and	r24, r24
    210a:	59 f4       	brne	.+22     	; 0x2122 <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    210c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    2110:	08 c0       	rjmp	.+16     	; 0x2122 <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2112:	f8 01       	movw	r30, r16
    2114:	d1 83       	std	Z+1, r29	; 0x01
    2116:	c0 83       	st	Z, r28
    2118:	ee cf       	rjmp	.-36     	; 0x20f6 <vTaskDelayUntil+0x48>
    211a:	f8 01       	movw	r30, r16
    211c:	d1 83       	std	Z+1, r29	; 0x01
    211e:	c0 83       	st	Z, r28
    2120:	f1 cf       	rjmp	.-30     	; 0x2104 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2122:	df 91       	pop	r29
    2124:	cf 91       	pop	r28
    2126:	1f 91       	pop	r17
    2128:	0f 91       	pop	r16
    212a:	08 95       	ret

0000212c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    212c:	80 91 95 03 	lds	r24, 0x0395
    2130:	88 23       	and	r24, r24
    2132:	21 f0       	breq	.+8      	; 0x213c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2134:	81 e0       	ldi	r24, 0x01	; 1
    2136:	80 93 99 03 	sts	0x0399, r24
    213a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    213c:	10 92 99 03 	sts	0x0399, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2140:	20 91 9c 03 	lds	r18, 0x039C
    2144:	82 2f       	mov	r24, r18
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	fc 01       	movw	r30, r24
    214a:	ee 0f       	add	r30, r30
    214c:	ff 1f       	adc	r31, r31
    214e:	ee 0f       	add	r30, r30
    2150:	ff 1f       	adc	r31, r31
    2152:	ee 0f       	add	r30, r30
    2154:	ff 1f       	adc	r31, r31
    2156:	e8 0f       	add	r30, r24
    2158:	f9 1f       	adc	r31, r25
    215a:	ea 55       	subi	r30, 0x5A	; 90
    215c:	fc 4f       	sbci	r31, 0xFC	; 252
    215e:	30 81       	ld	r19, Z
    2160:	33 23       	and	r19, r19
    2162:	89 f4       	brne	.+34     	; 0x2186 <vTaskSwitchContext+0x5a>
    2164:	21 50       	subi	r18, 0x01	; 1
    2166:	82 2f       	mov	r24, r18
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	fc 01       	movw	r30, r24
    216c:	ee 0f       	add	r30, r30
    216e:	ff 1f       	adc	r31, r31
    2170:	ee 0f       	add	r30, r30
    2172:	ff 1f       	adc	r31, r31
    2174:	ee 0f       	add	r30, r30
    2176:	ff 1f       	adc	r31, r31
    2178:	e8 0f       	add	r30, r24
    217a:	f9 1f       	adc	r31, r25
    217c:	ea 55       	subi	r30, 0x5A	; 90
    217e:	fc 4f       	sbci	r31, 0xFC	; 252
    2180:	30 81       	ld	r19, Z
    2182:	33 23       	and	r19, r19
    2184:	79 f3       	breq	.-34     	; 0x2164 <vTaskSwitchContext+0x38>
    2186:	dc 01       	movw	r26, r24
    2188:	aa 0f       	add	r26, r26
    218a:	bb 1f       	adc	r27, r27
    218c:	aa 0f       	add	r26, r26
    218e:	bb 1f       	adc	r27, r27
    2190:	aa 0f       	add	r26, r26
    2192:	bb 1f       	adc	r27, r27
    2194:	8a 0f       	add	r24, r26
    2196:	9b 1f       	adc	r25, r27
    2198:	dc 01       	movw	r26, r24
    219a:	aa 55       	subi	r26, 0x5A	; 90
    219c:	bc 4f       	sbci	r27, 0xFC	; 252
    219e:	11 96       	adiw	r26, 0x01	; 1
    21a0:	ed 91       	ld	r30, X+
    21a2:	fc 91       	ld	r31, X
    21a4:	12 97       	sbiw	r26, 0x02	; 2
    21a6:	02 80       	ldd	r0, Z+2	; 0x02
    21a8:	f3 81       	ldd	r31, Z+3	; 0x03
    21aa:	e0 2d       	mov	r30, r0
    21ac:	12 96       	adiw	r26, 0x02	; 2
    21ae:	fc 93       	st	X, r31
    21b0:	ee 93       	st	-X, r30
    21b2:	11 97       	sbiw	r26, 0x01	; 1
    21b4:	cd 01       	movw	r24, r26
    21b6:	03 96       	adiw	r24, 0x03	; 3
    21b8:	e8 17       	cp	r30, r24
    21ba:	f9 07       	cpc	r31, r25
    21bc:	31 f4       	brne	.+12     	; 0x21ca <vTaskSwitchContext+0x9e>
    21be:	82 81       	ldd	r24, Z+2	; 0x02
    21c0:	93 81       	ldd	r25, Z+3	; 0x03
    21c2:	12 96       	adiw	r26, 0x02	; 2
    21c4:	9c 93       	st	X, r25
    21c6:	8e 93       	st	-X, r24
    21c8:	11 97       	sbiw	r26, 0x01	; 1
    21ca:	11 96       	adiw	r26, 0x01	; 1
    21cc:	ed 91       	ld	r30, X+
    21ce:	fc 91       	ld	r31, X
    21d0:	12 97       	sbiw	r26, 0x02	; 2
    21d2:	86 81       	ldd	r24, Z+6	; 0x06
    21d4:	97 81       	ldd	r25, Z+7	; 0x07
    21d6:	90 93 94 03 	sts	0x0394, r25
    21da:	80 93 93 03 	sts	0x0393, r24
    21de:	20 93 9c 03 	sts	0x039C, r18
    21e2:	08 95       	ret

000021e4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    21e4:	0f 93       	push	r16
    21e6:	1f 93       	push	r17
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    21ec:	0f b6       	in	r0, 0x3f	; 63
    21ee:	f8 94       	cli
    21f0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    21f2:	00 97       	sbiw	r24, 0x00	; 0
    21f4:	29 f4       	brne	.+10     	; 0x2200 <vTaskSuspend+0x1c>
    21f6:	00 91 93 03 	lds	r16, 0x0393
    21fa:	10 91 94 03 	lds	r17, 0x0394
    21fe:	01 c0       	rjmp	.+2      	; 0x2202 <vTaskSuspend+0x1e>
    2200:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2202:	e8 01       	movw	r28, r16
    2204:	22 96       	adiw	r28, 0x02	; 2
    2206:	ce 01       	movw	r24, r28
    2208:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    220c:	f8 01       	movw	r30, r16
    220e:	84 89       	ldd	r24, Z+20	; 0x14
    2210:	95 89       	ldd	r25, Z+21	; 0x15
    2212:	00 97       	sbiw	r24, 0x00	; 0
    2214:	21 f0       	breq	.+8      	; 0x221e <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2216:	c8 01       	movw	r24, r16
    2218:	0c 96       	adiw	r24, 0x0c	; 12
    221a:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    221e:	87 ef       	ldi	r24, 0xF7	; 247
    2220:	93 e0       	ldi	r25, 0x03	; 3
    2222:	be 01       	movw	r22, r28
    2224:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2228:	0f 90       	pop	r0
    222a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    222c:	80 91 9b 03 	lds	r24, 0x039B
    2230:	88 23       	and	r24, r24
    2232:	39 f0       	breq	.+14     	; 0x2242 <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    223a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    223e:	0f 90       	pop	r0
    2240:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    2242:	80 91 93 03 	lds	r24, 0x0393
    2246:	90 91 94 03 	lds	r25, 0x0394
    224a:	08 17       	cp	r16, r24
    224c:	19 07       	cpc	r17, r25
    224e:	a1 f4       	brne	.+40     	; 0x2278 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    2250:	80 91 9b 03 	lds	r24, 0x039B
    2254:	88 23       	and	r24, r24
    2256:	19 f0       	breq	.+6      	; 0x225e <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2258:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    225c:	0d c0       	rjmp	.+26     	; 0x2278 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    225e:	80 91 9f 03 	lds	r24, 0x039F
    2262:	90 91 f7 03 	lds	r25, 0x03F7
    2266:	98 17       	cp	r25, r24
    2268:	29 f4       	brne	.+10     	; 0x2274 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    226a:	10 92 94 03 	sts	0x0394, r1
    226e:	10 92 93 03 	sts	0x0393, r1
    2272:	02 c0       	rjmp	.+4      	; 0x2278 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    2274:	0e 94 96 10 	call	0x212c	; 0x212c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2278:	df 91       	pop	r29
    227a:	cf 91       	pop	r28
    227c:	1f 91       	pop	r17
    227e:	0f 91       	pop	r16
    2280:	08 95       	ret

00002282 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2288:	60 91 93 03 	lds	r22, 0x0393
    228c:	70 91 94 03 	lds	r23, 0x0394
    2290:	64 5f       	subi	r22, 0xF4	; 244
    2292:	7f 4f       	sbci	r23, 0xFF	; 255
    2294:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2298:	ce 01       	movw	r24, r28
    229a:	61 e0       	ldi	r22, 0x01	; 1
    229c:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>
}
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	08 95       	ret

000022a6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    22a6:	cf 93       	push	r28
    22a8:	df 93       	push	r29
    22aa:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    22ac:	e0 91 93 03 	lds	r30, 0x0393
    22b0:	f0 91 94 03 	lds	r31, 0x0394
    22b4:	70 68       	ori	r23, 0x80	; 128
    22b6:	75 87       	std	Z+13, r23	; 0x0d
    22b8:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    22ba:	60 91 93 03 	lds	r22, 0x0393
    22be:	70 91 94 03 	lds	r23, 0x0394
    22c2:	64 5f       	subi	r22, 0xF4	; 244
    22c4:	7f 4f       	sbci	r23, 0xFF	; 255
    22c6:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    22ca:	ce 01       	movw	r24, r28
    22cc:	61 e0       	ldi	r22, 0x01	; 1
    22ce:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>
}
    22d2:	df 91       	pop	r29
    22d4:	cf 91       	pop	r28
    22d6:	08 95       	ret

000022d8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    22d8:	0f 93       	push	r16
    22da:	1f 93       	push	r17
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22e0:	dc 01       	movw	r26, r24
    22e2:	15 96       	adiw	r26, 0x05	; 5
    22e4:	ed 91       	ld	r30, X+
    22e6:	fc 91       	ld	r31, X
    22e8:	16 97       	sbiw	r26, 0x06	; 6
    22ea:	06 81       	ldd	r16, Z+6	; 0x06
    22ec:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    22ee:	e8 01       	movw	r28, r16
    22f0:	2c 96       	adiw	r28, 0x0c	; 12
    22f2:	ce 01       	movw	r24, r28
    22f4:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    22f8:	80 91 95 03 	lds	r24, 0x0395
    22fc:	88 23       	and	r24, r24
    22fe:	e9 f4       	brne	.+58     	; 0x233a <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2300:	e8 01       	movw	r28, r16
    2302:	22 96       	adiw	r28, 0x02	; 2
    2304:	ce 01       	movw	r24, r28
    2306:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    230a:	f8 01       	movw	r30, r16
    230c:	86 89       	ldd	r24, Z+22	; 0x16
    230e:	90 91 9c 03 	lds	r25, 0x039C
    2312:	98 17       	cp	r25, r24
    2314:	10 f4       	brcc	.+4      	; 0x231a <xTaskRemoveFromEventList+0x42>
    2316:	80 93 9c 03 	sts	0x039C, r24
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	9c 01       	movw	r18, r24
    231e:	22 0f       	add	r18, r18
    2320:	33 1f       	adc	r19, r19
    2322:	22 0f       	add	r18, r18
    2324:	33 1f       	adc	r19, r19
    2326:	22 0f       	add	r18, r18
    2328:	33 1f       	adc	r19, r19
    232a:	82 0f       	add	r24, r18
    232c:	93 1f       	adc	r25, r19
    232e:	8a 55       	subi	r24, 0x5A	; 90
    2330:	9c 4f       	sbci	r25, 0xFC	; 252
    2332:	be 01       	movw	r22, r28
    2334:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    2338:	05 c0       	rjmp	.+10     	; 0x2344 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    233a:	85 ee       	ldi	r24, 0xE5	; 229
    233c:	93 e0       	ldi	r25, 0x03	; 3
    233e:	be 01       	movw	r22, r28
    2340:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2344:	e0 91 93 03 	lds	r30, 0x0393
    2348:	f0 91 94 03 	lds	r31, 0x0394
    234c:	d8 01       	movw	r26, r16
    234e:	56 96       	adiw	r26, 0x16	; 22
    2350:	9c 91       	ld	r25, X
    2352:	56 97       	sbiw	r26, 0x16	; 22
    2354:	86 89       	ldd	r24, Z+22	; 0x16
    2356:	89 17       	cp	r24, r25
    2358:	20 f4       	brcc	.+8      	; 0x2362 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	80 93 99 03 	sts	0x0399, r24
    2360:	01 c0       	rjmp	.+2      	; 0x2364 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    2362:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	1f 91       	pop	r17
    236a:	0f 91       	pop	r16
    236c:	08 95       	ret

0000236e <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    236e:	0f 93       	push	r16
    2370:	1f 93       	push	r17
    2372:	cf 93       	push	r28
    2374:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2376:	70 68       	ori	r23, 0x80	; 128
    2378:	fc 01       	movw	r30, r24
    237a:	71 83       	std	Z+1, r23	; 0x01
    237c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    237e:	c6 81       	ldd	r28, Z+6	; 0x06
    2380:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2382:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2386:	8e 01       	movw	r16, r28
    2388:	0e 5f       	subi	r16, 0xFE	; 254
    238a:	1f 4f       	sbci	r17, 0xFF	; 255
    238c:	c8 01       	movw	r24, r16
    238e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2392:	8e 89       	ldd	r24, Y+22	; 0x16
    2394:	90 91 9c 03 	lds	r25, 0x039C
    2398:	98 17       	cp	r25, r24
    239a:	10 f4       	brcc	.+4      	; 0x23a0 <xTaskRemoveFromUnorderedEventList+0x32>
    239c:	80 93 9c 03 	sts	0x039C, r24
    23a0:	90 e0       	ldi	r25, 0x00	; 0
    23a2:	9c 01       	movw	r18, r24
    23a4:	22 0f       	add	r18, r18
    23a6:	33 1f       	adc	r19, r19
    23a8:	22 0f       	add	r18, r18
    23aa:	33 1f       	adc	r19, r19
    23ac:	22 0f       	add	r18, r18
    23ae:	33 1f       	adc	r19, r19
    23b0:	82 0f       	add	r24, r18
    23b2:	93 1f       	adc	r25, r19
    23b4:	8a 55       	subi	r24, 0x5A	; 90
    23b6:	9c 4f       	sbci	r25, 0xFC	; 252
    23b8:	b8 01       	movw	r22, r16
    23ba:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    23be:	e0 91 93 03 	lds	r30, 0x0393
    23c2:	f0 91 94 03 	lds	r31, 0x0394
    23c6:	9e 89       	ldd	r25, Y+22	; 0x16
    23c8:	86 89       	ldd	r24, Z+22	; 0x16
    23ca:	89 17       	cp	r24, r25
    23cc:	20 f4       	brcc	.+8      	; 0x23d6 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	80 93 99 03 	sts	0x0399, r24
    23d4:	01 c0       	rjmp	.+2      	; 0x23d8 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    23d6:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    23d8:	df 91       	pop	r29
    23da:	cf 91       	pop	r28
    23dc:	1f 91       	pop	r17
    23de:	0f 91       	pop	r16
    23e0:	08 95       	ret

000023e2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    23e2:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    23e4:	80 91 98 03 	lds	r24, 0x0398
    23e8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    23ea:	80 91 9d 03 	lds	r24, 0x039D
    23ee:	90 91 9e 03 	lds	r25, 0x039E
    23f2:	92 83       	std	Z+2, r25	; 0x02
    23f4:	81 83       	std	Z+1, r24	; 0x01
}
    23f6:	08 95       	ret

000023f8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    23f8:	fc 01       	movw	r30, r24
    23fa:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    23fc:	0f b6       	in	r0, 0x3f	; 63
    23fe:	f8 94       	cli
    2400:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2402:	60 91 9d 03 	lds	r22, 0x039D
    2406:	70 91 9e 03 	lds	r23, 0x039E
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    240a:	4d 91       	ld	r20, X+
    240c:	5c 91       	ld	r21, X
    240e:	11 97       	sbiw	r26, 0x01	; 1
    2410:	8f ef       	ldi	r24, 0xFF	; 255
    2412:	4f 3f       	cpi	r20, 0xFF	; 255
    2414:	58 07       	cpc	r21, r24
    2416:	e9 f0       	breq	.+58     	; 0x2452 <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2418:	80 91 98 03 	lds	r24, 0x0398
    241c:	90 81       	ld	r25, Z
    241e:	98 17       	cp	r25, r24
    2420:	29 f0       	breq	.+10     	; 0x242c <xTaskCheckForTimeOut+0x34>
    2422:	81 81       	ldd	r24, Z+1	; 0x01
    2424:	92 81       	ldd	r25, Z+2	; 0x02
    2426:	68 17       	cp	r22, r24
    2428:	79 07       	cpc	r23, r25
    242a:	a8 f4       	brcc	.+42     	; 0x2456 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    242c:	81 81       	ldd	r24, Z+1	; 0x01
    242e:	92 81       	ldd	r25, Z+2	; 0x02
    2430:	9b 01       	movw	r18, r22
    2432:	28 1b       	sub	r18, r24
    2434:	39 0b       	sbc	r19, r25
    2436:	24 17       	cp	r18, r20
    2438:	35 07       	cpc	r19, r21
    243a:	78 f4       	brcc	.+30     	; 0x245a <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    243c:	86 1b       	sub	r24, r22
    243e:	97 0b       	sbc	r25, r23
    2440:	84 0f       	add	r24, r20
    2442:	95 1f       	adc	r25, r21
    2444:	8d 93       	st	X+, r24
    2446:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2448:	cf 01       	movw	r24, r30
    244a:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    244e:	80 e0       	ldi	r24, 0x00	; 0
    2450:	05 c0       	rjmp	.+10     	; 0x245c <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2452:	80 e0       	ldi	r24, 0x00	; 0
    2454:	03 c0       	rjmp	.+6      	; 0x245c <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2456:	81 e0       	ldi	r24, 0x01	; 1
    2458:	01 c0       	rjmp	.+2      	; 0x245c <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    245a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    245c:	0f 90       	pop	r0
    245e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2460:	08 95       	ret

00002462 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2462:	81 e0       	ldi	r24, 0x01	; 1
    2464:	80 93 99 03 	sts	0x0399, r24
}
    2468:	08 95       	ret

0000246a <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    246a:	80 91 93 03 	lds	r24, 0x0393
    246e:	90 91 94 03 	lds	r25, 0x0394

		return xReturn;
	}
    2472:	08 95       	ret

00002474 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2474:	0f 93       	push	r16
    2476:	1f 93       	push	r17
    2478:	cf 93       	push	r28
    247a:	df 93       	push	r29
    247c:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    247e:	00 97       	sbiw	r24, 0x00	; 0
    2480:	09 f4       	brne	.+2      	; 0x2484 <vTaskPriorityInherit+0x10>
    2482:	51 c0       	rjmp	.+162    	; 0x2526 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2484:	8e 89       	ldd	r24, Y+22	; 0x16
    2486:	e0 91 93 03 	lds	r30, 0x0393
    248a:	f0 91 94 03 	lds	r31, 0x0394
    248e:	96 89       	ldd	r25, Z+22	; 0x16
    2490:	89 17       	cp	r24, r25
    2492:	08 f0       	brcs	.+2      	; 0x2496 <vTaskPriorityInherit+0x22>
    2494:	48 c0       	rjmp	.+144    	; 0x2526 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2496:	2c 85       	ldd	r18, Y+12	; 0x0c
    2498:	3d 85       	ldd	r19, Y+13	; 0x0d
    249a:	33 23       	and	r19, r19
    249c:	5c f0       	brlt	.+22     	; 0x24b4 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    249e:	e0 91 93 03 	lds	r30, 0x0393
    24a2:	f0 91 94 03 	lds	r31, 0x0394
    24a6:	96 89       	ldd	r25, Z+22	; 0x16
    24a8:	25 e0       	ldi	r18, 0x05	; 5
    24aa:	30 e0       	ldi	r19, 0x00	; 0
    24ac:	29 1b       	sub	r18, r25
    24ae:	31 09       	sbc	r19, r1
    24b0:	3d 87       	std	Y+13, r19	; 0x0d
    24b2:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    24b4:	90 e0       	ldi	r25, 0x00	; 0
    24b6:	9c 01       	movw	r18, r24
    24b8:	22 0f       	add	r18, r18
    24ba:	33 1f       	adc	r19, r19
    24bc:	22 0f       	add	r18, r18
    24be:	33 1f       	adc	r19, r19
    24c0:	22 0f       	add	r18, r18
    24c2:	33 1f       	adc	r19, r19
    24c4:	82 0f       	add	r24, r18
    24c6:	93 1f       	adc	r25, r19
    24c8:	8a 55       	subi	r24, 0x5A	; 90
    24ca:	9c 4f       	sbci	r25, 0xFC	; 252
    24cc:	2a 85       	ldd	r18, Y+10	; 0x0a
    24ce:	3b 85       	ldd	r19, Y+11	; 0x0b
    24d0:	28 17       	cp	r18, r24
    24d2:	39 07       	cpc	r19, r25
    24d4:	11 f5       	brne	.+68     	; 0x251a <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    24d6:	8e 01       	movw	r16, r28
    24d8:	0e 5f       	subi	r16, 0xFE	; 254
    24da:	1f 4f       	sbci	r17, 0xFF	; 255
    24dc:	c8 01       	movw	r24, r16
    24de:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    24e2:	e0 91 93 03 	lds	r30, 0x0393
    24e6:	f0 91 94 03 	lds	r31, 0x0394
    24ea:	86 89       	ldd	r24, Z+22	; 0x16
    24ec:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    24ee:	90 91 9c 03 	lds	r25, 0x039C
    24f2:	98 17       	cp	r25, r24
    24f4:	10 f4       	brcc	.+4      	; 0x24fa <vTaskPriorityInherit+0x86>
    24f6:	80 93 9c 03 	sts	0x039C, r24
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	9c 01       	movw	r18, r24
    24fe:	22 0f       	add	r18, r18
    2500:	33 1f       	adc	r19, r19
    2502:	22 0f       	add	r18, r18
    2504:	33 1f       	adc	r19, r19
    2506:	22 0f       	add	r18, r18
    2508:	33 1f       	adc	r19, r19
    250a:	82 0f       	add	r24, r18
    250c:	93 1f       	adc	r25, r19
    250e:	8a 55       	subi	r24, 0x5A	; 90
    2510:	9c 4f       	sbci	r25, 0xFC	; 252
    2512:	b8 01       	movw	r22, r16
    2514:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    2518:	06 c0       	rjmp	.+12     	; 0x2526 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    251a:	e0 91 93 03 	lds	r30, 0x0393
    251e:	f0 91 94 03 	lds	r31, 0x0394
    2522:	86 89       	ldd	r24, Z+22	; 0x16
    2524:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2526:	df 91       	pop	r29
    2528:	cf 91       	pop	r28
    252a:	1f 91       	pop	r17
    252c:	0f 91       	pop	r16
    252e:	08 95       	ret

00002530 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2530:	0f 93       	push	r16
    2532:	1f 93       	push	r17
    2534:	cf 93       	push	r28
    2536:	df 93       	push	r29
    2538:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    253a:	00 97       	sbiw	r24, 0x00	; 0
    253c:	81 f1       	breq	.+96     	; 0x259e <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    253e:	8c a1       	lds	r24, 0x4c
    2540:	81 50       	subi	r24, 0x01	; 1
    2542:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2544:	2e 89       	ldd	r18, Y+22	; 0x16
    2546:	9b a1       	lds	r25, 0x4b
    2548:	29 17       	cp	r18, r25
    254a:	59 f1       	breq	.+86     	; 0x25a2 <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    254c:	88 23       	and	r24, r24
    254e:	59 f5       	brne	.+86     	; 0x25a6 <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2550:	8e 01       	movw	r16, r28
    2552:	0e 5f       	subi	r16, 0xFE	; 254
    2554:	1f 4f       	sbci	r17, 0xFF	; 255
    2556:	c8 01       	movw	r24, r16
    2558:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    255c:	4b a1       	lds	r20, 0x4b
    255e:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2560:	24 2f       	mov	r18, r20
    2562:	30 e0       	ldi	r19, 0x00	; 0
    2564:	85 e0       	ldi	r24, 0x05	; 5
    2566:	90 e0       	ldi	r25, 0x00	; 0
    2568:	82 1b       	sub	r24, r18
    256a:	93 0b       	sbc	r25, r19
    256c:	9d 87       	std	Y+13, r25	; 0x0d
    256e:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2570:	80 91 9c 03 	lds	r24, 0x039C
    2574:	84 17       	cp	r24, r20
    2576:	10 f4       	brcc	.+4      	; 0x257c <xTaskPriorityDisinherit+0x4c>
    2578:	40 93 9c 03 	sts	0x039C, r20
    257c:	c9 01       	movw	r24, r18
    257e:	88 0f       	add	r24, r24
    2580:	99 1f       	adc	r25, r25
    2582:	88 0f       	add	r24, r24
    2584:	99 1f       	adc	r25, r25
    2586:	88 0f       	add	r24, r24
    2588:	99 1f       	adc	r25, r25
    258a:	28 0f       	add	r18, r24
    258c:	39 1f       	adc	r19, r25
    258e:	c9 01       	movw	r24, r18
    2590:	8a 55       	subi	r24, 0x5A	; 90
    2592:	9c 4f       	sbci	r25, 0xFC	; 252
    2594:	b8 01       	movw	r22, r16
    2596:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	05 c0       	rjmp	.+10     	; 0x25a8 <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	03 c0       	rjmp	.+6      	; 0x25a8 <xTaskPriorityDisinherit+0x78>
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	01 c0       	rjmp	.+2      	; 0x25a8 <xTaskPriorityDisinherit+0x78>
    25a6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    25a8:	df 91       	pop	r29
    25aa:	cf 91       	pop	r28
    25ac:	1f 91       	pop	r17
    25ae:	0f 91       	pop	r16
    25b0:	08 95       	ret

000025b2 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    25b2:	e0 91 93 03 	lds	r30, 0x0393
    25b6:	f0 91 94 03 	lds	r31, 0x0394
    25ba:	84 85       	ldd	r24, Z+12	; 0x0c
    25bc:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    25be:	e0 91 93 03 	lds	r30, 0x0393
    25c2:	f0 91 94 03 	lds	r31, 0x0394
    25c6:	a0 91 93 03 	lds	r26, 0x0393
    25ca:	b0 91 94 03 	lds	r27, 0x0394
    25ce:	56 96       	adiw	r26, 0x16	; 22
    25d0:	4c 91       	ld	r20, X
    25d2:	56 97       	sbiw	r26, 0x16	; 22
    25d4:	25 e0       	ldi	r18, 0x05	; 5
    25d6:	30 e0       	ldi	r19, 0x00	; 0
    25d8:	24 1b       	sub	r18, r20
    25da:	31 09       	sbc	r19, r1
    25dc:	35 87       	std	Z+13, r19	; 0x0d
    25de:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    25e0:	08 95       	ret

000025e2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    25e2:	80 91 93 03 	lds	r24, 0x0393
    25e6:	90 91 94 03 	lds	r25, 0x0394
    25ea:	00 97       	sbiw	r24, 0x00	; 0
    25ec:	39 f0       	breq	.+14     	; 0x25fc <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    25ee:	e0 91 93 03 	lds	r30, 0x0393
    25f2:	f0 91 94 03 	lds	r31, 0x0394
    25f6:	84 a1       	lds	r24, 0x44
    25f8:	8f 5f       	subi	r24, 0xFF	; 255
    25fa:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    25fc:	80 91 93 03 	lds	r24, 0x0393
    2600:	90 91 94 03 	lds	r25, 0x0394
	}
    2604:	08 95       	ret

00002606 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2606:	0f 93       	push	r16
    2608:	1f 93       	push	r17
    260a:	cf 93       	push	r28
    260c:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2614:	e0 91 93 03 	lds	r30, 0x0393
    2618:	f0 91 94 03 	lds	r31, 0x0394
    261c:	85 a1       	lds	r24, 0x45
    261e:	96 a1       	lds	r25, 0x46
    2620:	a7 a1       	lds	r26, 0x47
    2622:	b0 a5       	lds	r27, 0x60
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	a1 05       	cpc	r26, r1
    2628:	b1 05       	cpc	r27, r1
    262a:	79 f4       	brne	.+30     	; 0x264a <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    262c:	e0 91 93 03 	lds	r30, 0x0393
    2630:	f0 91 94 03 	lds	r31, 0x0394
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2638:	61 15       	cp	r22, r1
    263a:	71 05       	cpc	r23, r1
    263c:	31 f0       	breq	.+12     	; 0x264a <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    263e:	cb 01       	movw	r24, r22
    2640:	61 e0       	ldi	r22, 0x01	; 1
    2642:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2646:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    264a:	0f 90       	pop	r0
    264c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2654:	e0 91 93 03 	lds	r30, 0x0393
    2658:	f0 91 94 03 	lds	r31, 0x0394
    265c:	05 a1       	lds	r16, 0x45
    265e:	16 a1       	lds	r17, 0x46
    2660:	27 a1       	lds	r18, 0x47
    2662:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    2664:	01 15       	cp	r16, r1
    2666:	11 05       	cpc	r17, r1
    2668:	21 05       	cpc	r18, r1
    266a:	31 05       	cpc	r19, r1
    266c:	c1 f0       	breq	.+48     	; 0x269e <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    266e:	cc 23       	and	r28, r28
    2670:	49 f0       	breq	.+18     	; 0x2684 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2672:	e0 91 93 03 	lds	r30, 0x0393
    2676:	f0 91 94 03 	lds	r31, 0x0394
    267a:	15 a2       	lds	r17, 0x95
    267c:	16 a2       	lds	r17, 0x96
    267e:	17 a2       	lds	r17, 0x97
    2680:	10 a6       	lds	r17, 0xb0
    2682:	0d c0       	rjmp	.+26     	; 0x269e <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2684:	e0 91 93 03 	lds	r30, 0x0393
    2688:	f0 91 94 03 	lds	r31, 0x0394
    268c:	d9 01       	movw	r26, r18
    268e:	c8 01       	movw	r24, r16
    2690:	01 97       	sbiw	r24, 0x01	; 1
    2692:	a1 09       	sbc	r26, r1
    2694:	b1 09       	sbc	r27, r1
    2696:	85 a3       	lds	r24, 0x55
    2698:	96 a3       	lds	r25, 0x56
    269a:	a7 a3       	lds	r26, 0x57
    269c:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    269e:	e0 91 93 03 	lds	r30, 0x0393
    26a2:	f0 91 94 03 	lds	r31, 0x0394
    26a6:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    26ac:	60 2f       	mov	r22, r16
    26ae:	71 2f       	mov	r23, r17
    26b0:	82 2f       	mov	r24, r18
    26b2:	93 2f       	mov	r25, r19
    26b4:	cf 91       	pop	r28
    26b6:	1f 91       	pop	r17
    26b8:	0f 91       	pop	r16
    26ba:	08 95       	ret

000026bc <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    26bc:	8f 92       	push	r8
    26be:	9f 92       	push	r9
    26c0:	af 92       	push	r10
    26c2:	bf 92       	push	r11
    26c4:	ef 92       	push	r14
    26c6:	ff 92       	push	r15
    26c8:	0f 93       	push	r16
    26ca:	1f 93       	push	r17
    26cc:	dc 01       	movw	r26, r24
    26ce:	cb 01       	movw	r24, r22
    26d0:	49 01       	movw	r8, r18
    26d2:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    26da:	e0 91 93 03 	lds	r30, 0x0393
    26de:	f0 91 94 03 	lds	r31, 0x0394
    26e2:	21 a5       	lds	r18, 0x61
    26e4:	22 30       	cpi	r18, 0x02	; 2
    26e6:	19 f1       	breq	.+70     	; 0x272e <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    26e8:	e0 91 93 03 	lds	r30, 0x0393
    26ec:	f0 91 94 03 	lds	r31, 0x0394
    26f0:	45 a1       	lds	r20, 0x45
    26f2:	56 a1       	lds	r21, 0x46
    26f4:	67 a1       	lds	r22, 0x47
    26f6:	70 a5       	lds	r23, 0x60
    26f8:	80 95       	com	r24
    26fa:	90 95       	com	r25
    26fc:	a0 95       	com	r26
    26fe:	b0 95       	com	r27
    2700:	84 23       	and	r24, r20
    2702:	95 23       	and	r25, r21
    2704:	a6 23       	and	r26, r22
    2706:	b7 23       	and	r27, r23
    2708:	85 a3       	lds	r24, 0x55
    270a:	96 a3       	lds	r25, 0x56
    270c:	a7 a3       	lds	r26, 0x57
    270e:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2710:	e0 91 93 03 	lds	r30, 0x0393
    2714:	f0 91 94 03 	lds	r31, 0x0394
    2718:	81 e0       	ldi	r24, 0x01	; 1
    271a:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    271c:	e1 14       	cp	r14, r1
    271e:	f1 04       	cpc	r15, r1
    2720:	31 f0       	breq	.+12     	; 0x272e <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2722:	c7 01       	movw	r24, r14
    2724:	61 e0       	ldi	r22, 0x01	; 1
    2726:	0e 94 98 0b 	call	0x1730	; 0x1730 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    272a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    272e:	0f 90       	pop	r0
    2730:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2732:	0f b6       	in	r0, 0x3f	; 63
    2734:	f8 94       	cli
    2736:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2738:	01 15       	cp	r16, r1
    273a:	11 05       	cpc	r17, r1
    273c:	69 f0       	breq	.+26     	; 0x2758 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    273e:	e0 91 93 03 	lds	r30, 0x0393
    2742:	f0 91 94 03 	lds	r31, 0x0394
    2746:	85 a1       	lds	r24, 0x45
    2748:	96 a1       	lds	r25, 0x46
    274a:	a7 a1       	lds	r26, 0x47
    274c:	b0 a5       	lds	r27, 0x60
    274e:	f8 01       	movw	r30, r16
    2750:	80 83       	st	Z, r24
    2752:	91 83       	std	Z+1, r25	; 0x01
    2754:	a2 83       	std	Z+2, r26	; 0x02
    2756:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2758:	e0 91 93 03 	lds	r30, 0x0393
    275c:	f0 91 94 03 	lds	r31, 0x0394
    2760:	81 a5       	lds	r24, 0x61
    2762:	81 30       	cpi	r24, 0x01	; 1
    2764:	b1 f0       	breq	.+44     	; 0x2792 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2766:	e0 91 93 03 	lds	r30, 0x0393
    276a:	f0 91 94 03 	lds	r31, 0x0394
    276e:	85 a1       	lds	r24, 0x45
    2770:	96 a1       	lds	r25, 0x46
    2772:	a7 a1       	lds	r26, 0x47
    2774:	b0 a5       	lds	r27, 0x60
    2776:	80 94       	com	r8
    2778:	90 94       	com	r9
    277a:	a0 94       	com	r10
    277c:	b0 94       	com	r11
    277e:	88 22       	and	r8, r24
    2780:	99 22       	and	r9, r25
    2782:	aa 22       	and	r10, r26
    2784:	bb 22       	and	r11, r27
    2786:	85 a2       	lds	r24, 0x95
    2788:	96 a2       	lds	r25, 0x96
    278a:	a7 a2       	lds	r26, 0x97
    278c:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    278e:	81 e0       	ldi	r24, 0x01	; 1
    2790:	01 c0       	rjmp	.+2      	; 0x2794 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2792:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2794:	e0 91 93 03 	lds	r30, 0x0393
    2798:	f0 91 94 03 	lds	r31, 0x0394
    279c:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    279e:	0f 90       	pop	r0
    27a0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    27a2:	1f 91       	pop	r17
    27a4:	0f 91       	pop	r16
    27a6:	ff 90       	pop	r15
    27a8:	ef 90       	pop	r14
    27aa:	bf 90       	pop	r11
    27ac:	af 90       	pop	r10
    27ae:	9f 90       	pop	r9
    27b0:	8f 90       	pop	r8
    27b2:	08 95       	ret

000027b4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    27b4:	0f 93       	push	r16
    27b6:	1f 93       	push	r17
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    27c4:	01 15       	cp	r16, r1
    27c6:	11 05       	cpc	r17, r1
    27c8:	49 f0       	breq	.+18     	; 0x27dc <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    27ca:	8d a1       	lds	r24, 0x4d
    27cc:	9e a1       	lds	r25, 0x4e
    27ce:	af a1       	lds	r26, 0x4f
    27d0:	b8 a5       	lds	r27, 0x68
    27d2:	f8 01       	movw	r30, r16
    27d4:	80 83       	st	Z, r24
    27d6:	91 83       	std	Z+1, r25	; 0x01
    27d8:	a2 83       	std	Z+2, r26	; 0x02
    27da:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    27dc:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    27de:	82 e0       	ldi	r24, 0x02	; 2
    27e0:	89 a7       	lds	r24, 0x79

			switch( eAction )
    27e2:	22 30       	cpi	r18, 0x02	; 2
    27e4:	b9 f0       	breq	.+46     	; 0x2814 <xTaskGenericNotify+0x60>
    27e6:	23 30       	cpi	r18, 0x03	; 3
    27e8:	18 f4       	brcc	.+6      	; 0x27f0 <xTaskGenericNotify+0x3c>
    27ea:	21 30       	cpi	r18, 0x01	; 1
    27ec:	51 f5       	brne	.+84     	; 0x2842 <xTaskGenericNotify+0x8e>
    27ee:	05 c0       	rjmp	.+10     	; 0x27fa <xTaskGenericNotify+0x46>
    27f0:	23 30       	cpi	r18, 0x03	; 3
    27f2:	e1 f0       	breq	.+56     	; 0x282c <xTaskGenericNotify+0x78>
    27f4:	24 30       	cpi	r18, 0x04	; 4
    27f6:	29 f5       	brne	.+74     	; 0x2842 <xTaskGenericNotify+0x8e>
    27f8:	1e c0       	rjmp	.+60     	; 0x2836 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    27fa:	8d a1       	lds	r24, 0x4d
    27fc:	9e a1       	lds	r25, 0x4e
    27fe:	af a1       	lds	r26, 0x4f
    2800:	b8 a5       	lds	r27, 0x68
    2802:	48 2b       	or	r20, r24
    2804:	59 2b       	or	r21, r25
    2806:	6a 2b       	or	r22, r26
    2808:	7b 2b       	or	r23, r27
    280a:	4d a3       	lds	r20, 0x5d
    280c:	5e a3       	lds	r21, 0x5e
    280e:	6f a3       	lds	r22, 0x5f
    2810:	78 a7       	lds	r23, 0x78
					break;
    2812:	17 c0       	rjmp	.+46     	; 0x2842 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2814:	8d a1       	lds	r24, 0x4d
    2816:	9e a1       	lds	r25, 0x4e
    2818:	af a1       	lds	r26, 0x4f
    281a:	b8 a5       	lds	r27, 0x68
    281c:	01 96       	adiw	r24, 0x01	; 1
    281e:	a1 1d       	adc	r26, r1
    2820:	b1 1d       	adc	r27, r1
    2822:	8d a3       	lds	r24, 0x5d
    2824:	9e a3       	lds	r25, 0x5e
    2826:	af a3       	lds	r26, 0x5f
    2828:	b8 a7       	lds	r27, 0x78
					break;
    282a:	0b c0       	rjmp	.+22     	; 0x2842 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    282c:	4d a3       	lds	r20, 0x5d
    282e:	5e a3       	lds	r21, 0x5e
    2830:	6f a3       	lds	r22, 0x5f
    2832:	78 a7       	lds	r23, 0x78
					break;
    2834:	06 c0       	rjmp	.+12     	; 0x2842 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2836:	32 30       	cpi	r19, 0x02	; 2
    2838:	71 f1       	breq	.+92     	; 0x2896 <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    283a:	4d a3       	lds	r20, 0x5d
    283c:	5e a3       	lds	r21, 0x5e
    283e:	6f a3       	lds	r22, 0x5f
    2840:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2842:	31 30       	cpi	r19, 0x01	; 1
    2844:	51 f5       	brne	.+84     	; 0x289a <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2846:	8e 01       	movw	r16, r28
    2848:	0e 5f       	subi	r16, 0xFE	; 254
    284a:	1f 4f       	sbci	r17, 0xFF	; 255
    284c:	c8 01       	movw	r24, r16
    284e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2852:	8e 89       	ldd	r24, Y+22	; 0x16
    2854:	90 91 9c 03 	lds	r25, 0x039C
    2858:	98 17       	cp	r25, r24
    285a:	10 f4       	brcc	.+4      	; 0x2860 <xTaskGenericNotify+0xac>
    285c:	80 93 9c 03 	sts	0x039C, r24
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	9c 01       	movw	r18, r24
    2864:	22 0f       	add	r18, r18
    2866:	33 1f       	adc	r19, r19
    2868:	22 0f       	add	r18, r18
    286a:	33 1f       	adc	r19, r19
    286c:	22 0f       	add	r18, r18
    286e:	33 1f       	adc	r19, r19
    2870:	82 0f       	add	r24, r18
    2872:	93 1f       	adc	r25, r19
    2874:	8a 55       	subi	r24, 0x5A	; 90
    2876:	9c 4f       	sbci	r25, 0xFC	; 252
    2878:	b8 01       	movw	r22, r16
    287a:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    287e:	e0 91 93 03 	lds	r30, 0x0393
    2882:	f0 91 94 03 	lds	r31, 0x0394
    2886:	9e 89       	ldd	r25, Y+22	; 0x16
    2888:	86 89       	ldd	r24, Z+22	; 0x16
    288a:	89 17       	cp	r24, r25
    288c:	40 f4       	brcc	.+16     	; 0x289e <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    288e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <vPortYield>
    2892:	81 e0       	ldi	r24, 0x01	; 1
    2894:	05 c0       	rjmp	.+10     	; 0x28a0 <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2896:	80 e0       	ldi	r24, 0x00	; 0
    2898:	03 c0       	rjmp	.+6      	; 0x28a0 <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	01 c0       	rjmp	.+2      	; 0x28a0 <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    289e:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    28a0:	0f 90       	pop	r0
    28a2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    28a4:	df 91       	pop	r29
    28a6:	cf 91       	pop	r28
    28a8:	1f 91       	pop	r17
    28aa:	0f 91       	pop	r16
    28ac:	08 95       	ret

000028ae <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    28ae:	ef 92       	push	r14
    28b0:	ff 92       	push	r15
    28b2:	0f 93       	push	r16
    28b4:	1f 93       	push	r17
    28b6:	cf 93       	push	r28
    28b8:	df 93       	push	r29
    28ba:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    28bc:	01 15       	cp	r16, r1
    28be:	11 05       	cpc	r17, r1
    28c0:	49 f0       	breq	.+18     	; 0x28d4 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    28c2:	8d a1       	lds	r24, 0x4d
    28c4:	9e a1       	lds	r25, 0x4e
    28c6:	af a1       	lds	r26, 0x4f
    28c8:	b8 a5       	lds	r27, 0x68
    28ca:	f8 01       	movw	r30, r16
    28cc:	80 83       	st	Z, r24
    28ce:	91 83       	std	Z+1, r25	; 0x01
    28d0:	a2 83       	std	Z+2, r26	; 0x02
    28d2:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    28d4:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    28d6:	82 e0       	ldi	r24, 0x02	; 2
    28d8:	89 a7       	lds	r24, 0x79

			switch( eAction )
    28da:	22 30       	cpi	r18, 0x02	; 2
    28dc:	b9 f0       	breq	.+46     	; 0x290c <xTaskGenericNotifyFromISR+0x5e>
    28de:	23 30       	cpi	r18, 0x03	; 3
    28e0:	18 f4       	brcc	.+6      	; 0x28e8 <xTaskGenericNotifyFromISR+0x3a>
    28e2:	21 30       	cpi	r18, 0x01	; 1
    28e4:	59 f5       	brne	.+86     	; 0x293c <xTaskGenericNotifyFromISR+0x8e>
    28e6:	05 c0       	rjmp	.+10     	; 0x28f2 <xTaskGenericNotifyFromISR+0x44>
    28e8:	23 30       	cpi	r18, 0x03	; 3
    28ea:	e1 f0       	breq	.+56     	; 0x2924 <xTaskGenericNotifyFromISR+0x76>
    28ec:	24 30       	cpi	r18, 0x04	; 4
    28ee:	31 f5       	brne	.+76     	; 0x293c <xTaskGenericNotifyFromISR+0x8e>
    28f0:	1e c0       	rjmp	.+60     	; 0x292e <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    28f2:	8d a1       	lds	r24, 0x4d
    28f4:	9e a1       	lds	r25, 0x4e
    28f6:	af a1       	lds	r26, 0x4f
    28f8:	b8 a5       	lds	r27, 0x68
    28fa:	84 2b       	or	r24, r20
    28fc:	95 2b       	or	r25, r21
    28fe:	a6 2b       	or	r26, r22
    2900:	b7 2b       	or	r27, r23
    2902:	8d a3       	lds	r24, 0x5d
    2904:	9e a3       	lds	r25, 0x5e
    2906:	af a3       	lds	r26, 0x5f
    2908:	b8 a7       	lds	r27, 0x78
					break;
    290a:	18 c0       	rjmp	.+48     	; 0x293c <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    290c:	8d a1       	lds	r24, 0x4d
    290e:	9e a1       	lds	r25, 0x4e
    2910:	af a1       	lds	r26, 0x4f
    2912:	b8 a5       	lds	r27, 0x68
    2914:	01 96       	adiw	r24, 0x01	; 1
    2916:	a1 1d       	adc	r26, r1
    2918:	b1 1d       	adc	r27, r1
    291a:	8d a3       	lds	r24, 0x5d
    291c:	9e a3       	lds	r25, 0x5e
    291e:	af a3       	lds	r26, 0x5f
    2920:	b8 a7       	lds	r27, 0x78
					break;
    2922:	0c c0       	rjmp	.+24     	; 0x293c <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2924:	4d a3       	lds	r20, 0x5d
    2926:	5e a3       	lds	r21, 0x5e
    2928:	6f a3       	lds	r22, 0x5f
    292a:	78 a7       	lds	r23, 0x78
					break;
    292c:	07 c0       	rjmp	.+14     	; 0x293c <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    292e:	32 30       	cpi	r19, 0x02	; 2
    2930:	09 f4       	brne	.+2      	; 0x2934 <xTaskGenericNotifyFromISR+0x86>
    2932:	41 c0       	rjmp	.+130    	; 0x29b6 <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2934:	4d a3       	lds	r20, 0x5d
    2936:	5e a3       	lds	r21, 0x5e
    2938:	6f a3       	lds	r22, 0x5f
    293a:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    293c:	31 30       	cpi	r19, 0x01	; 1
    293e:	e9 f5       	brne	.+122    	; 0x29ba <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2940:	80 91 95 03 	lds	r24, 0x0395
    2944:	88 23       	and	r24, r24
    2946:	e9 f4       	brne	.+58     	; 0x2982 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2948:	8e 01       	movw	r16, r28
    294a:	0e 5f       	subi	r16, 0xFE	; 254
    294c:	1f 4f       	sbci	r17, 0xFF	; 255
    294e:	c8 01       	movw	r24, r16
    2950:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2954:	8e 89       	ldd	r24, Y+22	; 0x16
    2956:	90 91 9c 03 	lds	r25, 0x039C
    295a:	98 17       	cp	r25, r24
    295c:	10 f4       	brcc	.+4      	; 0x2962 <xTaskGenericNotifyFromISR+0xb4>
    295e:	80 93 9c 03 	sts	0x039C, r24
    2962:	90 e0       	ldi	r25, 0x00	; 0
    2964:	9c 01       	movw	r18, r24
    2966:	22 0f       	add	r18, r18
    2968:	33 1f       	adc	r19, r19
    296a:	22 0f       	add	r18, r18
    296c:	33 1f       	adc	r19, r19
    296e:	22 0f       	add	r18, r18
    2970:	33 1f       	adc	r19, r19
    2972:	82 0f       	add	r24, r18
    2974:	93 1f       	adc	r25, r19
    2976:	8a 55       	subi	r24, 0x5A	; 90
    2978:	9c 4f       	sbci	r25, 0xFC	; 252
    297a:	b8 01       	movw	r22, r16
    297c:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    2980:	07 c0       	rjmp	.+14     	; 0x2990 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2982:	be 01       	movw	r22, r28
    2984:	64 5f       	subi	r22, 0xF4	; 244
    2986:	7f 4f       	sbci	r23, 0xFF	; 255
    2988:	85 ee       	ldi	r24, 0xE5	; 229
    298a:	93 e0       	ldi	r25, 0x03	; 3
    298c:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2990:	e0 91 93 03 	lds	r30, 0x0393
    2994:	f0 91 94 03 	lds	r31, 0x0394
    2998:	9e 89       	ldd	r25, Y+22	; 0x16
    299a:	86 89       	ldd	r24, Z+22	; 0x16
    299c:	89 17       	cp	r24, r25
    299e:	78 f4       	brcc	.+30     	; 0x29be <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    29a0:	e1 14       	cp	r14, r1
    29a2:	f1 04       	cpc	r15, r1
    29a4:	21 f0       	breq	.+8      	; 0x29ae <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    29a6:	81 e0       	ldi	r24, 0x01	; 1
    29a8:	f7 01       	movw	r30, r14
    29aa:	80 83       	st	Z, r24
    29ac:	09 c0       	rjmp	.+18     	; 0x29c0 <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    29ae:	81 e0       	ldi	r24, 0x01	; 1
    29b0:	80 93 99 03 	sts	0x0399, r24
    29b4:	05 c0       	rjmp	.+10     	; 0x29c0 <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	03 c0       	rjmp	.+6      	; 0x29c0 <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    29ba:	81 e0       	ldi	r24, 0x01	; 1
    29bc:	01 c0       	rjmp	.+2      	; 0x29c0 <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    29be:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    29c0:	df 91       	pop	r29
    29c2:	cf 91       	pop	r28
    29c4:	1f 91       	pop	r17
    29c6:	0f 91       	pop	r16
    29c8:	ff 90       	pop	r15
    29ca:	ef 90       	pop	r14
    29cc:	08 95       	ret

000029ce <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    29ce:	ef 92       	push	r14
    29d0:	ff 92       	push	r15
    29d2:	0f 93       	push	r16
    29d4:	1f 93       	push	r17
    29d6:	cf 93       	push	r28
    29d8:	df 93       	push	r29
    29da:	ec 01       	movw	r28, r24
    29dc:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    29de:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    29e0:	82 e0       	ldi	r24, 0x02	; 2
    29e2:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    29e4:	8d a1       	lds	r24, 0x4d
    29e6:	9e a1       	lds	r25, 0x4e
    29e8:	af a1       	lds	r26, 0x4f
    29ea:	b8 a5       	lds	r27, 0x68
    29ec:	01 96       	adiw	r24, 0x01	; 1
    29ee:	a1 1d       	adc	r26, r1
    29f0:	b1 1d       	adc	r27, r1
    29f2:	8d a3       	lds	r24, 0x5d
    29f4:	9e a3       	lds	r25, 0x5e
    29f6:	af a3       	lds	r26, 0x5f
    29f8:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    29fa:	21 30       	cpi	r18, 0x01	; 1
    29fc:	e9 f5       	brne	.+122    	; 0x2a78 <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29fe:	80 91 95 03 	lds	r24, 0x0395
    2a02:	88 23       	and	r24, r24
    2a04:	01 f5       	brne	.+64     	; 0x2a46 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2a06:	ee 24       	eor	r14, r14
    2a08:	ff 24       	eor	r15, r15
    2a0a:	68 94       	set
    2a0c:	e1 f8       	bld	r14, 1
    2a0e:	ec 0e       	add	r14, r28
    2a10:	fd 1e       	adc	r15, r29
    2a12:	c7 01       	movw	r24, r14
    2a14:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2a18:	8e 89       	ldd	r24, Y+22	; 0x16
    2a1a:	90 91 9c 03 	lds	r25, 0x039C
    2a1e:	98 17       	cp	r25, r24
    2a20:	10 f4       	brcc	.+4      	; 0x2a26 <vTaskNotifyGiveFromISR+0x58>
    2a22:	80 93 9c 03 	sts	0x039C, r24
    2a26:	90 e0       	ldi	r25, 0x00	; 0
    2a28:	9c 01       	movw	r18, r24
    2a2a:	22 0f       	add	r18, r18
    2a2c:	33 1f       	adc	r19, r19
    2a2e:	22 0f       	add	r18, r18
    2a30:	33 1f       	adc	r19, r19
    2a32:	22 0f       	add	r18, r18
    2a34:	33 1f       	adc	r19, r19
    2a36:	82 0f       	add	r24, r18
    2a38:	93 1f       	adc	r25, r19
    2a3a:	8a 55       	subi	r24, 0x5A	; 90
    2a3c:	9c 4f       	sbci	r25, 0xFC	; 252
    2a3e:	b7 01       	movw	r22, r14
    2a40:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
    2a44:	07 c0       	rjmp	.+14     	; 0x2a54 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2a46:	be 01       	movw	r22, r28
    2a48:	64 5f       	subi	r22, 0xF4	; 244
    2a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a4c:	85 ee       	ldi	r24, 0xE5	; 229
    2a4e:	93 e0       	ldi	r25, 0x03	; 3
    2a50:	0e 94 ce 04 	call	0x99c	; 0x99c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a54:	e0 91 93 03 	lds	r30, 0x0393
    2a58:	f0 91 94 03 	lds	r31, 0x0394
    2a5c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a5e:	86 89       	ldd	r24, Z+22	; 0x16
    2a60:	89 17       	cp	r24, r25
    2a62:	50 f4       	brcc	.+20     	; 0x2a78 <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2a64:	01 15       	cp	r16, r1
    2a66:	11 05       	cpc	r17, r1
    2a68:	21 f0       	breq	.+8      	; 0x2a72 <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	f8 01       	movw	r30, r16
    2a6e:	80 83       	st	Z, r24
    2a70:	03 c0       	rjmp	.+6      	; 0x2a78 <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	80 93 99 03 	sts	0x0399, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2a78:	df 91       	pop	r29
    2a7a:	cf 91       	pop	r28
    2a7c:	1f 91       	pop	r17
    2a7e:	0f 91       	pop	r16
    2a80:	ff 90       	pop	r15
    2a82:	ef 90       	pop	r14
    2a84:	08 95       	ret

00002a86 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2a86:	00 97       	sbiw	r24, 0x00	; 0
    2a88:	29 f4       	brne	.+10     	; 0x2a94 <xTaskNotifyStateClear+0xe>
    2a8a:	e0 91 93 03 	lds	r30, 0x0393
    2a8e:	f0 91 94 03 	lds	r31, 0x0394
    2a92:	01 c0       	rjmp	.+2      	; 0x2a96 <xTaskNotifyStateClear+0x10>
    2a94:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    2a96:	0f b6       	in	r0, 0x3f	; 63
    2a98:	f8 94       	cli
    2a9a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2a9c:	81 a5       	lds	r24, 0x61
    2a9e:	82 30       	cpi	r24, 0x02	; 2
    2aa0:	19 f4       	brne	.+6      	; 0x2aa8 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2aa2:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	01 c0       	rjmp	.+2      	; 0x2aaa <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2aaa:	0f 90       	pop	r0
    2aac:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2aae:	08 95       	ret

00002ab0 <memcpy>:
    2ab0:	fb 01       	movw	r30, r22
    2ab2:	dc 01       	movw	r26, r24
    2ab4:	02 c0       	rjmp	.+4      	; 0x2aba <memcpy+0xa>
    2ab6:	01 90       	ld	r0, Z+
    2ab8:	0d 92       	st	X+, r0
    2aba:	41 50       	subi	r20, 0x01	; 1
    2abc:	50 40       	sbci	r21, 0x00	; 0
    2abe:	d8 f7       	brcc	.-10     	; 0x2ab6 <memcpy+0x6>
    2ac0:	08 95       	ret

00002ac2 <_exit>:
    2ac2:	f8 94       	cli

00002ac4 <__stop_program>:
    2ac4:	ff cf       	rjmp	.-2      	; 0x2ac4 <__stop_program>
